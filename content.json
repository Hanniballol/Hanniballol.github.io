{"posts":[{"title":"ADTå®žçŽ°çŠ¶æ€æ¨¡å¼","text":"ADT(ä»£æ•°æ•°æ®ç±»åž‹)æ˜¯å‡½æ•°å¼è¯­éŸ³ä¸­ä¸€ç§å¼ºå¤§çš„è¯­è¨€ç‰¹æ€§ï¼Œè¿™æ¬¡ç”¨å®ƒæ¥å®žçŽ°çŠ¶æ€æ¨¡å¼ çŠ¶æ€æ¨¡å¼ä¸Žç­–ç•¥æ¨¡å¼å­˜åœ¨æŸäº›ç›¸ä¼¼æ€§ï¼Œå®ƒä»¬éƒ½å¯ä»¥å®žçŽ°æŸç§ç®—æ³•ã€ä¸šåŠ¡é€»è¾‘çš„åˆ‡æ¢ã€‚ä»¥ä¸‹æ˜¯çŠ¶æ€æ¨¡å¼çš„å®šä¹‰ï¼š çŠ¶æ€æ¨¡å¼å…è®¸ä¸€ä¸ªå¯¹è±¡åœ¨å…¶å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶æ”¹å˜çš„è¡Œä¸ºï¼Œå¯¹è±¡çœ‹èµ·æ¥ä¼¼ä¹Žä¿®æ”¹äº†å®ƒçš„ç±»ã€‚ çŠ¶æ€æ¨¡å¼å…·ä½“è¡¨çŽ°åœ¨ï¼š çŠ¶æ€å†³å®šè¡Œä¸ºï¼Œå¯¹è±¡çš„è¡Œä¸ºç”±å®ƒå†…éƒ¨çš„çŠ¶æ€å†³å®š å¯¹è±¡çš„çŠ¶æ€åœ¨è¿è¡ŒæœŸè¢«æ”¹å˜æ—¶ï¼Œå®ƒçš„è¡Œä¸ºä¹Ÿä¼šå› æ­¤è€Œæ”¹å˜ã€‚ä»Žè¡¨é¢ä¸Šçœ‹ï¼ŒåŒä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨ä¸åŒçš„è¿è¡Œæ—¶åˆ»ï¼Œè¡Œä¸ºæ˜¯ä¸ä¸€æ ·çš„ï¼Œå°±åƒæ˜¯ç±»è¢«ä¿®æ”¹äº†ä¸€æ · å†æ¬¡ä¸Žç­–ç•¥æ¨¡å¼åšå¯¹æ¯”ï¼Œç­–ç•¥æ¨¡å¼é€šè¿‡åœ¨å®¢æˆ·ç«¯åˆ‡æ¢ä¸åŒçš„ç­–ç•¥å®žçŽ°æ¥æ”¹å˜ç®—æ³•ï¼›è€Œåœ¨çŠ¶æ€æ¨¡å¼ä¸­ï¼Œå¯¹è±¡é€šè¿‡ä¿®æ”¹å†…éƒ¨çš„çŠ¶æ€æ¥åˆ‡æ¢ä¸åŒçš„è¡Œä¸ºæ–¹æ³•ã€‚ çŽ°åœ¨æˆ‘ä»¬ä¸¾ä¸€ä¸ªé¥®æ°´æœºçš„ä¾‹å­ï¼Œå‡å¦‚ä¸€ä¸ªé¥®æ°´æœºæœ‰3ç§å·¥ä½œçŠ¶æ€ï¼Œåˆ†åˆ«ä¸ºæœªå¯åŠ¨ã€åˆ¶å†·æ¨¡å¼ã€åˆ¶çƒ­æ¨¡å¼ï¼Œé‚£ä¹ˆå¯ä»¥ç”¨å¯†å°ç±»æ¥å°è£…ä¸€ä¸ªä»£è¡¨ä¸åŒé¥®æ°´æœºçŠ¶æ€çš„ADTã€‚ sealed class WaterMachineState(open val machine: WaterMachine) { fun turnHeating() { if (this !is Heating) { print(&quot;turn heating&quot;) machine.state = machine.heating } else { print(&quot;The state is already heating mode.&quot;) } } fun turnCooling() { if (this !is Cooling) { print(&quot;turn cooling&quot;) machine.state = machine.cooling } else { print(&quot;The state is already cooling mode.&quot;) } } fun turnOff() { if (this !is Off) { print(&quot;turn off&quot;) machine.state = machine.off } else { print(&quot;The state is already off mode.&quot;) } }}class Off(override val machine: WaterMachine) : WatermachineState(machine)class Heating(override val machine: WaterMachine) : WatermachineState(machine)class Cooling(override val machine: WaterMachine) : WatermachineState(machine) ä»¥ä¸Šä»£ç åˆ†æžï¼š WatermachineStateæ˜¯ä¸€ä¸ªå¯†å°ç±»ï¼Œæ‹¥æœ‰ä¸€ä¸ªæž„é€ å‚æ•°ä¸ºWaterMachineç±»å¯¹è±¡ åœ¨WatermachineStateç±»å¤–éƒ¨æˆ‘ä»¬åˆ†åˆ«å®šä¹‰äº†Off,Heating,Coolingæ¥ä»£è¡¨é¥®æ°´æœºçš„3ç§ä¸åŒçš„å·¥ä½œçŠ¶æ€ï¼Œå®ƒä»¬éƒ½ç»§æ‰¿äº†WaterMachineStateç±»çš„machineæˆå‘˜å±žæ€§åŠ3ä¸ªçŠ¶æ€åˆ‡æ¢çš„æ–¹æ³• åœ¨æ¯ä¸ªåˆ‡æ¢çŠ¶æ€çš„æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡æ”¹å˜machineå¯¹è±¡çš„stateï¼Œæ¥å®žçŽ°åˆ‡æ¢é¥®æ°´æœºçŠ¶æ€çš„ç›®çš„ æŽ¥ç€çœ‹WaterMachineç±»ï¼š class WaterMachine { var state: WaterMachineState val off = Off(this) val heating = Heating(this) val cooling = Cooling(this) init { this.state = off } fun turnHeating() { this.state.turnHeating() } fun turnCooling() { this.state.turnCooling() } fun turnOff() { this.state.turnOff() }} WaterMachineå¾ˆç®€å•ï¼Œå†…éƒ¨ä¸»è¦åŒ…å«äº†ä¸€ä¸‹æˆå‘˜å±žæ€§å’Œæ–¹æ³•ï¼š å¼•ç”¨å¯å˜çš„WaterMachineStateç±»å¯¹è±¡stateï¼Œç”¨æ¥è¡¨ç¤ºå½“å‰é¥®æ°´æœºæ‰€å¤„çš„å·¥ä½œçŠ¶æ€ åˆ†åˆ«è¡¨ç¤º3ç§ä¸åŒçŠ¶æ€çš„æˆå‘˜å±žæ€§ï¼Œoffã€heatingã€coolingï¼Œå®ƒä»¬ä¹Ÿæ˜¯WaterMahineStateç±»çš„3ç§å­ç±»å¯¹è±¡ï¼›å®ƒä»¬é€šè¿‡ä¼ å…¥thisè¿›è¡Œæž„é€ ï¼Œä»Žè€Œå®žçŽ°åœ¨WaterMachineStateçŠ¶æ€ç±»å†…éƒ¨ï¼Œæ”¹å˜WaterMachineç±»çš„stateå¼•ç”¨å€¼ï¼›å½“WaterMachineç±»å¯¹è±¡åˆå§‹åŒ–æ—¶ï¼Œstateé»˜è®¤ä¸ºoffï¼Œå³é¥®æ°´æœºå¤„äºŽæœªå¯åŠ¨çŠ¶æ€ 3ä¸ªç›´æŽ¥è°ƒç”¨çš„é¥®æ°´æœºæ“ä½œæ–¹æ³•ï¼Œåˆ†åˆ«æ‰§è¡Œå¯¹åº”stateå¯¹è±¡çš„3ç§æ“ä½œï¼Œä¾›å®¢æˆ·ç«¯è°ƒç”¨ å¦‚æžœåŠžå…¬å®¤çš„å°ä¼™ä¼´éƒ½å–œæ¬¢å–å†·æ°´ï¼Œæ—©ä¸Šä¸€æ¥å°±ä¼šæŠŠé¥®æ°´æœºè°ƒæ•´ä¸ºåˆ¶å†·æ¨¡å¼ï¼Œä½†Shawæœ‰åƒæ³¡é¢çš„ä¹ æƒ¯ï¼Œä»–æƒ³æ³¡é¢çš„æ—¶å€™ï¼Œå°±ä¼šæŠŠé¥®æ°´æœºå˜ä¸ºåˆ¶çƒ­ï¼Œæ‰€ä»¥æ¯æ¬¡ä»–åƒäº†æ³¡é¢ï¼Œä¸‹ä¸€ä¸ªå–æ°´çš„åŒäº‹å°±éœ€è¦å†åˆ‡æ¢å›žåˆ¶å†·ã€‚æœ€åŽè¦ä¸‹ç­äº†ï¼ŒKimå°±ä¼šå…³é—­é¥®æ°´æœºçš„ç”µæºã€‚ ä¸ºäº†æ»¡è¶³è¿™ä¸€éœ€æ±‚ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ªwaterMachineOpså‡½æ•°ï¼š enum class Moment { EARLY_MORNING, DRINKING_WATER, INSTANCE_NOODLES, AFTER_WORK}fun waterMachineOps(machine: WaterMachine,moment: Moment) { when(moment) { EARLY_MORNING, DRINKING_WATER -&gt; when(machine.state) { !is WatermachineState.Cooling -&gt;machine.turnCooling() } INSTANCE_NOODLES -&gt; when(machine.state) { !is WatermachineState.Heating -&gt; machine.turnHeating() } AFTER_WORK -&gt; when(machine.state) { !is WatermachineState.Off -&gt; machine.turnOff() } }} è¿™ä¸ªæ–¹æ³•å¾ˆå¥½åœ°å¤„ç†äº†ä¸åŒè§’è‰²åœ¨ä¸åŒéœ€æ±‚åœºæ™¯ä¸‹ï¼Œåº”è¯¥å¯¹é¥®æ°´æœºæ‰§è¡Œçš„ä¸åŒæ“ä½œã€‚æ­¤å¤–ï¼Œå½“ç”¨whenè¡¨è¾¾å¼å¤„ç†æžšä¸¾ç±»æ—¶ï¼Œé»˜è®¤çš„æƒ…å†µå¿…é¡»ç”¨elseè¿›è¡Œå¤„ç†ã€‚ç„¶è€Œï¼Œç”±äºŽå¯†å°ç±»åœ¨ç±»åž‹å®‰å…¨ä¸Šçš„é¢å¤–è®¾è®¡ï¼Œæˆ‘ä»¬åœ¨å¤„ç†machineå¯¹è±¡çš„stateå¯¹è±¡æ—¶ï¼Œåˆ™ä¸éœ€è¦è€ƒè™‘è¿™ä¸€ç»†èŠ‚ï¼Œåœ¨è¯­è¨€è¡¨è¾¾ä¸Šè¦ç®€æ´å¾—å¤šã€‚","link":"/2020/01/21/ADT%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"title":"Androidå¹³å°WebRTCå¼€å¯H264è½¯ç¼–è§£ç ","text":"ç”±äºŽç‰ˆæƒé—®é¢˜WebRTCä¸€ç›´ä¸æ”¯æŒH264ï¼Œç›´åˆ°Ciscoå®£å¸ƒæ——ä¸‹çš„H264 Codecå¼€æºä¸ºOpenH264ï¼Œå¹¶ä¸”æ›¿æ‰€æœ‰OpenH264çš„ä½¿ç”¨è€…æ”¯ä»˜äº†H264çš„ä¸“åˆ©è´¹,ä»¥æ­¤ä¸ºå¥‘æœºï¼Œåœ¨IETFçš„WebRTCä¼šè®®ä¸­ï¼ŒæŠŠH264å’ŒVP8éƒ½åˆ—å…¥äº†WebRTCæ‰€å¿…é¡»è¦æ”¯æŒçš„è§†é¢‘ç¼–ç å™¨ï¼ŒæŽ¥ä¸‹æ¥Googleç»ˆäºŽåœ¨WebRTCä¸­å¢žåŠ äº†å¯¹H264çš„æ”¯æŒï¼Œå¯¹äºŽAndroidå¹³å°, ç¼–ç å™¨æ˜¯ç”¨OpenH264, è§£ç å™¨æ˜¯ç”¨FFMPEG, ä¹Ÿå¯ä»¥ç”¨ MediaCodec. è¿™ä¸ªå¯¹äºŽå¹¿å¤§éœ€è¦H264çš„å…¬å¸æ¥è¯´æ˜¯ä¸€å¤§ç¦éŸ³. åœ¨ä¸‹è½½çš„WebRTCä»£ç ä¸­åšç¨è®¸é…ç½®ï¼Œ å°±å¯ä»¥ä½¿ç”¨H264äº†ï¼Œæœ¬æ–‡ä»‹ç»é’ˆå¯¹M86åˆ†æ”¯å¢žåŠ H264è½¯ç¼–çš„æ­¥éª¤ã€‚ å¼€å¯H264ç¼–è§£ç æ‰“å¼€å¼€å…³ ä¿®æ”¹third_party/ffmpeg/ffmpeg_generated.gniï¼š use_linux_config = is_linux || is_fuchsia-&gt; use_linux_config = is_linux || is_fuchsia || is_android ä¿®æ”¹third_party/ffmpeg/chromium/config/Chrome/android/arm64/config.h: #define CONFIG_H264_DECODER 0-&gt; #define CONFIG_H264_DECODER 1 ä¿®æ”¹third_party/ffmpeg/chromium/config/Chrome/android/arm64/libavcodec/parser_list.c static const AVCodecParser * const parser_list[] = { ... &amp;ff_vp9_parser,+ &amp;ff_h264_parser, NULL }; ä¿®æ”¹third_party/ffmpeg/chromium/config/Chrome/android/arm64/libavcodec/codec_list.c static const AVCodec * const codec_list[] = { ... &amp;ff_libopus_decoder,+ &amp;ff_h264_decoder, NULL }; å¢žåŠ H264ç¼–è§£ç æ”¯æŒ åœ¨sdk/android/api/org/webrtcä¸­å¢žåŠ LibH264Decoder.javaã€LibH264Encoder.javaï¼Œæ ¼å¼ä¸ŽåŽŸæœ‰Decoderã€Encoderä¸€è‡´ï¼š LibH264Decoder.javapackage org.webrtc;public class LibH264Decoder extends WrappedNativeVideoDecoder { @Override public long createNativeVideoDecoder() { return nativeCreateDecoder(); } static native long nativeCreateDecoder();} LibH264Encoder.javapackage org.webrtc;public class LibH264Encoder extends WrappedNativeVideoEncoder { @Override public long createNativeVideoEncoder() { return nativeCreateEncoder(); } static native long nativeCreateEncoder(); @Override public boolean isHardwareEncoder() { return false; }} åœ¨sdk/android/src/jniä¸­æ·»åŠ h264_codec.ccï¼Œæ ¼å¼ä¸ŽåŽŸæœ‰vp8_codec.cc/vp9_codec.ccä¸€è‡´ï¼š #include &lt;jni.h&gt;#include &quot;modules/video_coding/codecs/h264/include/h264.h&quot;#include &quot;sdk/android/generated_libH264_jni/LibH264Decoder_jni.h&quot;#include &quot;sdk/android/generated_libH264_jni/LibH264Encoder_jni.h&quot;#include &quot;sdk/android/src/jni/jni_helpers.h&quot;namespace webrtc {namespace jni {static jlong JNI_LibH264Encoder_CreateEncoder(JNIEnv* jni) { return jlongFromPointer(H264Encoder::Create().release());}static jlong JNI_LibH264Decoder_CreateDecoder(JNIEnv* jni) { return jlongFromPointer(H264Decoder::Create().release());}} // namespace jni} // namespace webrtc åœ¨modules/video_coding/codecs/h264/h264.ccä¸­å¢žåŠ ä¸ŠH264Encoderçš„æž„é€ å‡½æ•°ï¼š std::unique_ptr&lt;H264Encoder&gt; H264Encoder::Create() {#if defined(WEBRTC_USE_H264) RTC_LOG(LS_INFO) &lt;&lt; &quot;Creating H264EncoderImpl.&quot;; return std::make_unique&lt;H264EncoderImpl&gt;(cricket::VideoCodec(&quot;H264&quot;));#else RTC_NOTREACHED(); return nullptr;#endif} åœ¨modules/video_coding/codecs/h264/include/h264.hå¤´æ–‡ä»¶ä¸­å£°æ˜Žå‡½æ•°ï¼š class RTC_EXPORT H264Encoder : public VideoEncoder { public:+ static std::unique_ptr&lt;H264Encoder&gt; Create(); static std::unique_ptr&lt;H264Encoder&gt; Create(const cricket::VideoCodec&amp; codec); // If H.264 is supported (any implementation). static bool IsSupported(); ~H264Encoder() override {}}; åœ¨sdk/android/api/org/webrtc/ä¸­ä¿®æ”¹SoftwareVideoDecoderFactory.javaã€SoftwareVideoEncoderFactory.javaå¢žåŠ å¯¹H264çš„æ”¯æŒï¼š SoftwareVideoDecoderFactory.java public VideoDecoder createDecoder(VideoCodecInfo codecType) {+ if (codecType.getName().equalsIgnoreCase(&quot;H264&quot;)) {+ return new LibH264Decoder();+ } ... return null; } static VideoCodecInfo[] supportedCodecs() { List&lt;VideoCodecInfo&gt; codecs = new ArrayList&lt;VideoCodecInfo&gt;(); + codecs.add(new VideoCodecInfo(&quot;H264&quot;, new HashMap&lt;&gt;())); codecs.add(new VideoCodecInfo(&quot;VP8&quot;, new HashMap&lt;&gt;())); ... return codecs.toArray(new VideoCodecInfo[codecs.size()]); } SoftwareVideoEncoderFactory.java public VideoEncoder createEncoder(VideoCodecInfo info) {+ if(info.name.equalsIgnoreCase(&quot;H264&quot;)) {+ return new LibH264Encoder(); } ... return null; } static VideoCodecInfo[] supportedCodecs() { List&lt;VideoCodecInfo&gt; codecs = new ArrayList&lt;VideoCodecInfo&gt;();+ codecs.add(new VideoCodecInfo(&quot;H264&quot;, new HashMap&lt;&gt;())); codecs.add(new VideoCodecInfo(&quot;VP8&quot;, new HashMap&lt;&gt;())); ... return codecs.toArray(new VideoCodecInfo[codecs.size()]); } å¢žåŠ ç¼–è¯‘æ”¯æŒåœ¨sdk/android/BUILD.gnä¸­å…³è”ä¸Šè¿°æ–°åŠ é€»è¾‘ï¼š BUILD.gn+ rtc_android_library(&quot;libH264_java&quot;) {+ visibility = [ &quot;*&quot; ]+ sources = [+ &quot;api/org/webrtc/LibH264Decoder.java&quot;,+ &quot;api/org/webrtc/LibH264Encoder.java&quot;,+ ]+ deps = [+ &quot;:base_java&quot;,+ &quot;:video_api_java&quot;,+ &quot;:video_java&quot;,+ &quot;//rtc_base:base_java&quot;,+ ]+ } rtc_android_library(&quot;libvpx_vp9_java&quot;) { visibility = [ &quot;*&quot; ] sources = [ &quot;api/org/webrtc/LibvpxVp9Decoder.java&quot;, &quot;api/org/webrtc/LibvpxVp9Encoder.java&quot;, ] deps = [ &quot;:base_java&quot;, &quot;:video_api_java&quot;, &quot;:video_java&quot;, &quot;//rtc_base:base_java&quot;, ] }...+ rtc_library(&quot;libH264_jni&quot;) {+ visibility = [ &quot;*&quot; ]+ allow_poison = [ &quot;software_video_codecs&quot; ]+ sources = [ &quot;src/jni/h264_codec.cc&quot; ]+ deps = [+ &quot;:base_jni&quot;,+ &quot;:generated_libH264_jni&quot;,+ &quot;:video_jni&quot;,+ &quot;../../modules/video_coding:webrtc_h264&quot;,+ ]+ } rtc_library(&quot;libvpx_vp9_jni&quot;) { visibility = [ &quot;*&quot; ] allow_poison = [ &quot;software_video_codecs&quot; ] sources = [ &quot;src/jni/vp9_codec.cc&quot; ] deps = [ &quot;:base_jni&quot;, &quot;:generated_libvpx_vp9_jni&quot;, &quot;:video_jni&quot;, &quot;../../modules/video_coding:webrtc_vp9&quot;, ] } rtc_library(&quot;swcodecs_jni&quot;) { visibility = [ &quot;*&quot; ] allow_poison = [ &quot;software_video_codecs&quot; ] deps = [+ &quot;:libH264_jni&quot;, &quot;:libvpx_vp8_jni&quot;, &quot;:libvpx_vp9_jni&quot;, ] }...+ generate_jni(&quot;generated_libH264_jni&quot;) {+ sources = [+ &quot;api/org/webrtc/LibH264Decoder.java&quot;,+ &quot;api/org/webrtc/LibH264Encoder.java&quot;,+ ]+ namespace = &quot;webrtc::jni&quot;+ jni_generator_include = &quot;//sdk/android/src/jni/jni_generator_helper.h&quot;+ } generate_jni(&quot;generated_libvpx_vp9_jni&quot;) { sources = [ &quot;api/org/webrtc/LibvpxVp9Decoder.java&quot;, &quot;api/org/webrtc/LibvpxVp9Encoder.java&quot;, ] namespace = &quot;webrtc::jni&quot; jni_generator_include = &quot;//sdk/android/src/jni/jni_generator_helper.h&quot; } ç¼–è¯‘å‘½ä»¤./tools_webrtc/android/build_aar.py --build-dir Build --arch arm64-v8a --extra-gn-args 'rtc_use_h264=true ffmpeg_branding=&quot;Chrome&quot;' endWebRTCçš„éŸ³è§†é¢‘æ•°æ®ä¼ è¾“ä½¿ç”¨çš„æ˜¯RTPåè®®ï¼ŒRTPæŠ¥æ–‡åˆ†ä¸ºæŠ¥å¤´å’Œè½½è·ä¸¤éƒ¨åˆ†ï¼Œä¸åŒç±»åž‹çš„è½½è·æœ‰ä¸åŒçš„æ ¼å¼ï¼Œæ‰€ä»¥å°±éœ€è¦å•ç‹¬å®žçŽ°æŠŠç¼–ç æ•°æ®æ‰“åŒ…ä¸ºRTPæŠ¥æ–‡çš„é€»è¾‘ä»¥åŠä»ŽRTPæŠ¥æ–‡è§£æžå·²ç¼–ç æ•°æ®çš„é€»è¾‘ã€‚åº†å¹¸çš„æ˜¯WebRTCä»¥åŠå¸®æˆ‘ä»¬å¤„ç†å¥½äº†H264çš„å°åŒ…è§£åŒ…é€»è¾‘ï¼Œæˆ‘ä»¬åªéœ€è¦æ·»åŠ æ”¯æŒï¼Œå¹¶æŠŠé€»è¾‘æ‰“åŒ…è¿›aarå³å¯ï¼Œè€Œè‹¥è¦æ”¯æŒH265,åˆ™éœ€è¦è‡ªå·±å¤„ç†å°åŒ…è§£åŒ…é€»è¾‘ï¼Œå¥½æ¶ˆæ¯æ˜¯OWTä¸­åŒ…å«äº†H265çš„æ”¯æŒï¼Œæˆ‘ä»¬ä¸ç”¨ä»Ž0ï¸âƒ£å¼€å§‹ã€‚ å‚è€ƒï¼š å®‰å“ webrtc å¼€å¯h264 è½¯ç¼–è§£ç ","link":"/2022/09/28/Android%E5%B9%B3%E5%8F%B0WebRTC%E5%BC%80%E5%90%AFH264%E8%BD%AF%E7%BC%96%E8%A7%A3%E7%A0%81/"},{"title":"Android Unit Case","text":"Androidå•å…ƒæµ‹è¯•ç¼–å†™åŽŸåˆ™åŠç›¸å…³ä¸‰æ–¹åº“è¯¦è§£ æ¦‚å¿µå•å…ƒæµ‹è¯•åªæ˜¯æµ‹è¯•ä¸€ä¸ªæ–¹æ³•å•å…ƒï¼Œå®ƒä¸æ˜¯æµ‹è¯•ä¸€ä¸ªæ•´ä¸ªæµç¨‹ã€‚ä¸¾ä¸€ä¸ªðŸŒ° ä¸€ä¸ªLoginé¡µé¢ï¼Œä¸Šé¢æœ‰ä¸¤ä¸ªEditTextå’Œä¸€ä¸ªButtonã€‚ä¸¤ä¸ªEditTextåˆ†åˆ«ç”¨äºŽè¾“å…¥ç”¨æˆ·åå’Œå¯†ç ã€‚ç‚¹å‡»Buttonä»¥åŽï¼Œæœ‰ä¸€ä¸ªUserManagerä¼šåŽ»æ‰§è¡Œperformloginæ“ä½œï¼Œç„¶åŽå°†ç»“æžœè¿”å›žï¼Œæ›´æ–°é¡µé¢ã€‚é‚£ä¹ˆæˆ‘ä»¬ç»™è¿™ä¸ªä¸œè¥¿åšå•å…ƒæµ‹è¯•çš„æ—¶å€™ï¼Œä¸æ˜¯æµ‹è¿™ä¸ªloginæµç¨‹ã€‚è¿™ç§æ•´ä¸ªæµç¨‹çš„æµ‹è¯•ï¼šç»™ä¸¤ä¸ªè¾“å…¥æ¡†è®¾ç½®æ­£ç¡®çš„ç”¨æˆ·åå’Œå¯†ç ï¼Œç‚¹å‡»login buttonï¼Œæœ€åŽé¡µé¢å¾—åˆ°æ›´æ–°ï¼Œå«åš é›†æˆæµ‹è¯•ï¼Œè€Œä¸æ˜¯å•å…ƒæµ‹è¯•ã€‚å½“ç„¶ï¼Œé›†æˆæµ‹è¯•æ˜¯æœ‰å¿…è¦çš„ï¼Œä½†è¿™ä¸æ˜¯ç¨‹åºå‘˜åº”è¯¥èŠ±ç²¾åŠ›çš„åœ°æ–¹ã€‚ Test PyramidTest Pyramidç†è®ºåŸºæœ¬å¤§æ„æ˜¯ï¼Œå•å…ƒæµ‹è¯•æ˜¯åŸºç¡€ï¼Œæ˜¯æˆ‘ä»¬åº”è¯¥èŠ±ç»å¤§å¤šæ•°æ—¶é—´åŽ»å†™çš„éƒ¨åˆ†ï¼Œè€Œé›†æˆæµ‹è¯•ç­‰åº”è¯¥æ˜¯å†°å±±ä¸Šé¢èƒ½çœ‹è§çš„é‚£ä¸€å°éƒ¨åˆ†ã€‚ ä¸ºä»€ä¹ˆæ˜¯è¿™æ ·å‘¢ï¼Ÿå› ä¸ºé›†æˆæµ‹è¯•è®¾ç½®èµ·æ¥å¾ˆéº»çƒ¦ï¼Œè¿è¡Œèµ·æ¥å¾ˆæ…¢ï¼Œå‘çŽ°çš„bugå°‘ï¼Œåœ¨ä¿è¯ä»£ç è´¨é‡ã€æ”¹å–„ä»£ç è®¾è®¡æ–¹é¢æ›´èµ·ä¸åˆ°ä»»ä½•ä½œç”¨ï¼Œå› æ­¤å®ƒçš„é‡è¦ç¨‹åº¦å¹¶ä¸æ˜¯é‚£ä¹ˆé«˜ï¼Œä¹Ÿæ— æ³•å°†å®ƒçº³å…¥æˆ‘ä»¬æ­£å¸¸çš„å·¥ä½œæµç¨‹ä¸­ã€‚è€Œå•å…ƒæµ‹è¯•åˆ™åˆšå¥½ç›¸åï¼Œå®ƒè¿è¡Œé€Ÿåº¦è¶…å¿«ï¼Œèƒ½å‘çŽ°çš„bugæ›´å¤šï¼Œåœ¨å¼€å‘æ—¶èƒ½å¼•å¯¼æ›´å¥½çš„ä»£ç è®¾è®¡ï¼Œåœ¨é‡æž„æ—¶èƒ½ä¿è¯é‡æž„çš„æ­£ç¡®æ€§ï¼Œå› æ­¤å®ƒèƒ½ä¿è¯æˆ‘ä»¬çš„ä»£ç åœ¨ä¸€ä¸ªæ¯”è¾ƒé«˜çš„è´¨é‡æ°´å¹³ä¸Šã€‚åŒæ—¶å› ä¸ºè¿è¡Œé€Ÿåº¦å¿«ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“æŠŠå®ƒçº³å…¥åˆ°æˆ‘ä»¬æ­£å¸¸çš„å¼€å‘æµç¨‹ä¸­ã€‚è‡³äºŽä¸ºä»€ä¹ˆé›†æˆæµ‹è¯•å‘çŽ°çš„bugå°‘ï¼Œè€Œå•å…ƒæµ‹è¯•å‘çŽ°çš„bugå¤šï¼Œè¿™é‡Œä¹Ÿç¨ä½œè§£é‡Šï¼Œå› ä¸ºé›†æˆæµ‹è¯•ä¸èƒ½æµ‹è¯•åˆ°å…¶ä¸­æ¯ä¸ªçŽ¯èŠ‚çš„æ¯ä¸ªæ–¹é¢ï¼ŒæŸä¸€ä¸ªé›†æˆæµ‹è¯•è¿è¡Œæ­£ç¡®äº†ï¼Œä¸ä»£è¡¨å¦ä¸€ä¸ªé›†æˆæµ‹è¯•ä¹Ÿèƒ½è¿è¡Œæ­£ç¡®ã€‚è€Œå•å…ƒæµ‹è¯•ä¼šæ¯”è¾ƒå®Œæ•´çš„æµ‹è¯•æ¯ä¸ªå•å…ƒçš„å„ç§ä¸åŒçš„çŠ¶å†µã€ä¸´ç•Œæ¡ä»¶ç­‰ç­‰ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æžœæ¯ä¸€ä¸ªçŽ¯èŠ‚æ˜¯å¯¹çš„ï¼Œé‚£ä¹ˆåœ¨å¾ˆå¤§çš„æ¦‚çŽ‡ä¸Šï¼Œæ•´ä¸ªæµç¨‹å°±æ˜¯å¯¹çš„ã€‚è™½ç„¶ä¸èƒ½ä¿è¯æ•´ä¸ªæµç¨‹100%ä¸€å®šæ˜¯å¯¹çš„ã€‚æ‰€ä»¥ï¼Œé›†æˆæµ‹è¯•éœ€è¦æœ‰ï¼Œä½†åº”è¯¥æ˜¯å°‘é‡ï¼Œå•å…ƒæµ‹è¯•æ˜¯æˆ‘ä»¬åº”è¯¥èŠ±é‡ç‚¹åŽ»åšçš„äº‹æƒ…ã€‚ ä¸ºä»€ä¹ˆå¦‚ä½•ä½ åœ¨ç¼–å†™å•å…ƒæµ‹è¯•çš„æ—¶å€™å‘çŽ°å½“å‰ç±»ä¸å¥½æµ‹ï¼Œè¯´æ˜Žè¯¥ç±»è®¾è®¡æœ‰é—®é¢˜ æå‡è½¯ä»¶è´¨é‡ æ–¹ä¾¿é‡æž„ èŠ‚çº¦æ—¶é—´ æå‡ä»£ç è®¾è®¡ å¤šç§å·¥å…·JUnitJUnit4æ˜¯Javaç•Œç”¨çš„æœ€å¹¿æ³›çš„ä¸€ä¸ªåŸºç¡€æ¡†æž¶ã€‚ ä¸€ä¸ªæµ‹è¯•æ–¹æ³•åŒ…æ‹¬ä¸‰ä¸ªéƒ¨åˆ†ï¼š setup æ‰§è¡Œæ“ä½œ éªŒè¯ç»“æžœ ä¸¾ä¸€ä¸ªðŸŒ°: public class LoginTest { Calculator mCalculator; @Before public void setup(){ mCalculator = new Calculator(); } @Test public void addTest() throws Exception { int sum = mCalculator.add(1,2); assertEquals(3,sum); } @Test @Ignore(&quot;not implemented yet&quot;) public void multiplyTest() throws Exception { int product = mCalculator.multiply(2,4); assertEquals(8,product); }} @Before : æ¯ä¸ªæµ‹è¯•å‡½æ•°åœ¨è°ƒç”¨ä¹‹å‰éƒ½ä¼šå…ˆè°ƒç”¨@Beforeæ³¨è§£çš„å‡½æ•°ï¼Œæ¯”å¦‚ addTest è¿è¡Œå‰ä¼šæ‰§è¡Œ setup , multiplyTest è¿è¡Œå‰ä¼šæ‰§è¡Œ setup,ç±»ä¼¼é€»è¾‘çš„è¿˜æœ‰@Afterã€@BeforeClassã€@AfterClassã€‚å³åœ¨è·‘ä¸€ä¸ªæµ‹è¯•ç±»çš„æ‰€æœ‰æµ‹è¯•æ–¹æ³•ä¹‹å‰ï¼Œä¼šæ‰§è¡Œä¸€ä¸ªè¢«@BeforeClassä¿®é¥°çš„å‡½æ•°ã€‚ @Ignore : å¦‚æžœéœ€è¦å¿½ç•¥æŸäº›æ–¹æ³•å¯ä»¥ä½¿ç”¨è¯¥æ³¨è§£ï¼Œä¾‹å¦‚æ­£å¼ä»£ç è¿˜æ²¡æœ‰å®žçŽ° @Test(expected = IllegalArgumentException.class) : è¡¨ç¤ºéªŒè¯è¿™ä¸ªæµ‹è¯•æ–¹æ³•å°†æŠ›å‡ºå¼‚å¸¸ï¼Œå¦‚æžœæ²¡æœ‰æŠ›å‡ºçš„è¯ï¼Œåˆ™æµ‹è¯•å¤±è´¥ã€‚ public class Calculator { public double divide(double divident,double dividor) { if (dividor == 0) throw new IllegalArgumentException(&quot;Dividor can't be 0&quot;); return divident / dividor; }}@Test(expected = IllegalArgumentException.class) public void test () { mCalculator.dividor(4,0);} Mock/MockitoMockæ˜¯åˆ›å»ºä¸€ä¸ªç±»çš„è™šå‡å¯¹è±¡ï¼Œåœ¨æµ‹è¯•çŽ¯å¢ƒä¸­ï¼Œç”¨æ¥æ›¿æ¢çœŸå®žå¯¹è±¡ï¼Œä»¥è¾¾åˆ°ä¸¤ä¸ªç›®çš„ï¼š éªŒè¯è¿™ä¸ªå¯¹è±¡çš„æŸäº›æ–¹æ³•çš„è°ƒç”¨æƒ…å†µï¼Œè°ƒç”¨äº†å¤šå°‘æ¬¡ï¼Œå‚æ•°æ˜¯ä»€ä¹ˆ æŒ‡å®šè¿™ä¸ªå¯¹è±¡çš„æŸäº›æ–¹æ³•çš„è¡Œä¸ºï¼Œè¿”å›žç‰¹å®šçš„å€¼ï¼Œæˆ–è€…æ˜¯æ‰§è¡Œç‰¹å®šçš„åŠ¨ä½œ Mockitoæ˜¯æœ€Javaç•Œä½¿ç”¨æœ€å¹¿æ³›çš„Mockæ¡†æž¶ 1.éªŒè¯æ–¹æ³•è°ƒç”¨ @Testpublic void testLogin() throws Exception { UserManager mockUserManager = Mockito.mock(UserManager.class); LoginPresenter loginPresenter = new LoginPresenter(); loginPresenter.setUserManager(mockUserManager); //&lt;== loginPresenter.login(&quot;xiaochuang&quot;, &quot;xiaochuang password&quot;); Mockito.verify(mockUserManager).performLogin(&quot;xiaochuang&quot;, &quot;xiaochuang password&quot;);} å¦‚æžœéœ€è¦éªŒè¯mockUserManagerçš„performLogin()å¾—åˆ°äº†è°ƒç”¨ï¼ŒåŒæ—¶å‚æ•°æ˜¯â€usernameâ€,â€passwordâ€ Mockito.verify(mockUserManager).performLogin(&quot;username&quot;,&quot;password&quot;); å½“ç„¶ä¹Ÿå¯ä»¥éªŒè¯è¯¥å‡½æ•°è°ƒç”¨æ¬¡æ•° Mockito.verify(mockUserManager, Mockito.times(3)).performLogin(...); //éªŒè¯mockUserManagerçš„performLoginå¾—åˆ°äº†ä¸‰æ¬¡è°ƒç”¨ã€‚Mockito.verify(mockUserManager, Mockito.atLeast(3)).performLogin(...); //éªŒè¯mockUserManagerçš„performLoginæœ€å°‘å¾—åˆ°äº†ä¸‰æ¬¡è°ƒç”¨ã€‚Mockito.verify(mockUserManager).performLogin(Mockito.anyString(),Mockito.anyString()); //å¹¶ä¸å…³å¿ƒå‚æ•°ï¼Œä»»æ„å‚æ•°çš†å¯ 2.æŒ‡å®šmockå¯¹è±¡çš„æŸäº›æ–¹æ³•çš„è¡Œä¸ºä¸¾ä¸€ä¸ªðŸŒ°ï¼š public void login(String username, String password) { if (username == null || username.length() == 0) return; //å‡è®¾æˆ‘ä»¬å¯¹å¯†ç å¼ºåº¦æœ‰ä¸€å®šè¦æ±‚ï¼Œä½¿ç”¨ä¸€ä¸ªä¸“é—¨çš„validatoræ¥éªŒè¯å¯†ç çš„æœ‰æ•ˆæ€§ if (mPasswordValidator.verifyPassword(password)) return; //&lt;== mUserManager.performLogin(null, password);} è¿™é‡Œæˆ‘ä»¬éœ€è¦PasswordValidatoræ¥éªŒè¯å¯†ç çš„æœ‰æ•ˆæ€§ï¼Œä½†æ˜¯è¿™ä¸ªç±»çš„verifyPassword()æ–¹æ³•éœ€è¦è”ç½‘ï¼Œå…¶å®žæˆ‘ä»¬åªéœ€è¦ç»™ä¸€äº›é˜ˆå€¼åˆ¤æ–­å³å¯ï¼Œå› ä¸ºæˆ‘ä»¬è¦æµ‹çš„æ˜¯login()ï¼Œè·ŸPasswordValidatorå†…éƒ¨é€»è¾‘æ²¡æœ‰å…³ç³»ï¼Œè¿™æ‰æ˜¯å•å…ƒæµ‹è¯•çœŸæ­£è¯¥æœ‰çš„é¢—ç²’åº¦ï¼Œæ¯”å¦‚å¯ä»¥è¿™ä¹ˆå†™ï¼š //å…ˆåˆ›å»ºä¸€ä¸ªmockå¯¹è±¡PasswordValidator mockValidator = Mockito.mock(PasswordValidator.class);//å½“è°ƒç”¨mockValidatorçš„verifyPasswordæ–¹æ³•ï¼ŒåŒæ—¶ä¼ å…¥&quot;xiaochuang_is_handsome&quot;æ—¶ï¼Œè¿”å›žtrueMockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)).thenReturn(true);//å½“è°ƒç”¨mockValidatorçš„verifyPasswordæ–¹æ³•ï¼ŒåŒæ—¶ä¼ å…¥&quot;xiaochuang_is_not_handsome&quot;æ—¶ï¼Œè¿”å›žfalseMockito.when(validator.verifyPassword(&quot;xiaochuang_is_not_handsome&quot;)).thenReturn(false); åˆæ¯”å¦‚æœ‰å¦‚ä¸‹é€»è¾‘: public void loginCallbackVersion(String username, String password) { if (username == null || username.length() == 0) return; //å‡è®¾æˆ‘ä»¬å¯¹å¯†ç å¼ºåº¦æœ‰ä¸€å®šè¦æ±‚ï¼Œä½¿ç”¨ä¸€ä¸ªä¸“é—¨çš„validatoræ¥éªŒè¯å¯†ç çš„æœ‰æ•ˆæ€§ if (mPasswordValidator.verifyPassword(password)) return; //loginçš„ç»“æžœå°†é€šè¿‡callbackä¼ é€’å›žæ¥ã€‚ mUserManager.performLogin(username, password, new NetworkCallback() { //&lt;== @Override public void onSuccess(Object data) { //update view with data } @Override public void onFailure(int code, String msg) { //show error msg } });} æƒ³è¿›ä¸€æ­¥æµ‹è¯•ä¼ ç»™mUserManager.performLoginçš„NetworkCallbacké‡Œé¢çš„ä»£ç ï¼ŒéªŒè¯viewå¾—åˆ°äº†æ›´æ–°ï¼Œæµ‹è¯•çŽ¯å¢ƒé‡Œï¼Œæˆ‘ä»¬å¹¶ä¸æƒ³ä¾èµ–mUserManager.performLoginçš„çœŸå®žé€»è¾‘ï¼Œè€Œæ˜¯è®©mUserManagerç›´æŽ¥è°ƒç”¨ä¼ å…¥çš„NetworkCallbackçš„onSuccessæˆ–onFailureæ–¹æ³•ï¼Œè¿™ç§æŒ‡å®šmockå¯¹è±¡æ‰§è¡Œç‰¹å®šçš„åŠ¨ä½œçš„å†™æ³•å¦‚ä¸‹ï¼šMockito.doAnswer(desiredAnswer).when(mockObject).targetMethod(args);ä¸¾ä¸€ä¸ªðŸŒ°ï¼š Mockito.doAnswer(new Answer() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { //è¿™é‡Œå¯ä»¥èŽ·å¾—ä¼ ç»™performLoginçš„å‚æ•° Object[] arguments = invocation.getArguments(); //callbackæ˜¯ç¬¬ä¸‰ä¸ªå‚æ•° NetworkCallback callback = (NetworkCallback) arguments[2]; callback.onFailure(500, &quot;Server error&quot;); return 500; }}).when(mockUserManager).performLogin(anyString(), anyString(), any(NetworkCallback.class));","link":"/2019/08/06/Android-Unit-Case/"},{"title":"Dive Into Flutter","text":"é¦–å…ˆä»Žè¿‡åŽ»çš„CRTæ˜¾ç¤ºå™¨åŽŸç†è¯´èµ·ã€‚CRTçš„ç”µå­æžªæŒ‰ç…§ä¸Šé¢æ–¹å¼ï¼Œä»Žä¸Šåˆ°ä¸‹ä¸€è¡Œè¡Œæ‰«æï¼Œæ‰«æå®ŒæˆåŽæ˜¾ç¤ºå™¨å°±å‘ˆçŽ°ä¸€å¸§ç”»é¢ï¼ŒéšåŽç”µå­æžªå›žåˆ°åˆå§‹ä½ç½®ç»§ç»­ä¸‹ä¸€æ¬¡æ‰«æã€‚ä¸ºäº†æŠŠæ˜¾ç¤ºå™¨çš„æ˜¾ç¤ºè¿‡ç¨‹å’Œç³»ç»Ÿçš„è§†é¢‘æŽ§åˆ¶å™¨è¿›è¡ŒåŒæ­¥ï¼Œæ˜¾ç¤ºå™¨ï¼ˆæˆ–å…¶ä»–ç¡¬ä»¶ï¼‰ä¼šç”¨ç¡¬ä»¶æ—¶é’Ÿäº§ç”Ÿä¸€ç³»åˆ—çš„å®šæ—¶ä¿¡å·ã€‚å½“ç”µå­æžªæ¢åˆ°æ–°çš„ä¸€è¡Œï¼Œå‡†å¤‡è¿›è¡Œæ‰«ææ—¶ï¼Œæ˜¾ç¤ºå™¨ä¼šå‘å‡ºä¸€ä¸ªæ°´å¹³åŒæ­¥ä¿¡å·ï¼ˆhorizonal synchronizationï¼‰ï¼Œç®€ç§°HSyncï¼›è€Œå½“ä¸€å¸§ç”»é¢ç»˜åˆ¶å®ŒæˆåŽï¼Œç”µå­æžªå›žå¤åˆ°åŽŸä½ï¼Œå‡†å¤‡ç”»ä¸‹ä¸€å¸§å‰ï¼Œæ˜¾ç¤ºå™¨ä¼šå‘å‡ºä¸€ä¸ªåž‚ç›´åŒæ­¥ä¿¡å·ï¼ˆvertial synchronizationï¼‰ï¼Œç®€ç§°VSyncã€‚æ˜¾ç¤ºå™¨é€šå¸¸ä»¥å›ºå®šé¢‘çŽ‡è¿›è¡Œåˆ·æ–°ï¼Œè¿™ä¸ªåˆ·æ–°çŽ‡å°±æ˜¯VSyncä¿¡å·äº§ç”Ÿçš„é¢‘çŽ‡ã€‚å°½ç®¡çŽ°åœ¨çš„è®¾å¤‡å¤§éƒ½æ˜¯æ¶²æ™¶æ˜¾ç¤ºå±äº†ï¼Œä½†åŽŸç†ä»ç„¶æ²¡æœ‰å˜ã€‚ åŽŸç†å±å¹•æ˜¾ç¤ºå›¾ç‰‡çš„åŽŸç† é¦–å…ˆä»Žè¿‡åŽ»çš„CRTæ˜¾ç¤ºå™¨åŽŸç†è¯´èµ·ã€‚CRTçš„ç”µå­æžªæŒ‰ç…§ä¸Šé¢æ–¹å¼ï¼Œä»Žä¸Šåˆ°ä¸‹ä¸€è¡Œè¡Œæ‰«æï¼Œæ‰«æå®ŒæˆåŽæ˜¾ç¤ºå™¨å°±å‘ˆçŽ°ä¸€å¸§ç”»é¢ï¼ŒéšåŽç”µå­æžªå›žåˆ°åˆå§‹ä½ç½®ç»§ç»­ä¸‹ä¸€æ¬¡æ‰«æã€‚ä¸ºäº†æŠŠæ˜¾ç¤ºå™¨çš„æ˜¾ç¤ºè¿‡ç¨‹å’Œç³»ç»Ÿçš„è§†é¢‘æŽ§åˆ¶å™¨è¿›è¡ŒåŒæ­¥ï¼Œæ˜¾ç¤ºå™¨ï¼ˆæˆ–å…¶ä»–ç¡¬ä»¶ï¼‰ä¼šç”¨ç¡¬ä»¶æ—¶é’Ÿäº§ç”Ÿä¸€ç³»åˆ—çš„å®šæ—¶ä¿¡å·ã€‚å½“ç”µå­æžªæ¢åˆ°æ–°çš„ä¸€è¡Œï¼Œå‡†å¤‡è¿›è¡Œæ‰«ææ—¶ï¼Œæ˜¾ç¤ºå™¨ä¼šå‘å‡ºä¸€ä¸ªæ°´å¹³åŒæ­¥ä¿¡å·ï¼ˆhorizonal synchronizationï¼‰ï¼Œç®€ç§°HSyncï¼›è€Œå½“ä¸€å¸§ç”»é¢ç»˜åˆ¶å®ŒæˆåŽï¼Œç”µå­æžªå›žå¤åˆ°åŽŸä½ï¼Œå‡†å¤‡ç”»ä¸‹ä¸€å¸§å‰ï¼Œæ˜¾ç¤ºå™¨ä¼šå‘å‡ºä¸€ä¸ªåž‚ç›´åŒæ­¥ä¿¡å·ï¼ˆvertial synchronizationï¼‰ï¼Œç®€ç§°VSyncã€‚æ˜¾ç¤ºå™¨é€šå¸¸ä»¥å›ºå®šé¢‘çŽ‡è¿›è¡Œåˆ·æ–°ï¼Œè¿™ä¸ªåˆ·æ–°çŽ‡å°±æ˜¯VSyncä¿¡å·äº§ç”Ÿçš„é¢‘çŽ‡ã€‚å°½ç®¡çŽ°åœ¨çš„è®¾å¤‡å¤§éƒ½æ˜¯æ¶²æ™¶æ˜¾ç¤ºå±äº†ï¼Œä½†åŽŸç†ä»ç„¶æ²¡æœ‰å˜ã€‚ é€šå¸¸æ¥è¯´ï¼Œè®¡ç®—æœºç³»ç»Ÿä¸­CPU,GPU,æ˜¾ç¤ºå™¨æ˜¯ä»¥ä¸Šé¢è¿™ç§æ–¹å¼ååŒå·¥ä½œçš„ã€‚CPUè®¡ç®—å¥½æ˜¾ç¤ºå†…å®¹æäº¤åˆ°GPU,GPUæ¸²æŸ“å®ŒæˆåŽå°†æ¸²æŸ“ç»“æžœæ”¾å…¥å¸§ç¼“å†²åŒºï¼ŒéšåŽè§†é¢‘æŽ§åˆ¶å™¨ä¼šæŒ‰ç…§VSyncä¿¡å·é€è¡Œè¯»å–å¸§ç¼“å†²åŒºçš„æ•°æ®ï¼Œç»è¿‡å¯èƒ½çš„æ•°æ¨¡è½¬æ¢ä¼ é€’ç»™æ˜¾ç¤ºå™¨æ˜¾ç¤ºã€‚CPUå’ŒGPUçš„ä»»åŠ¡æ˜¯å„æœ‰åé‡çš„ï¼ŒCPUä¸»è¦ç”¨äºŽåŸºæœ¬æ•°å­¦å’Œé€»è¾‘è®¡ç®—ï¼Œè€ŒGPUä¸»è¦æ‰§è¡Œå’Œå›¾å½¢å¤„ç†ç›¸å…³çš„å¤æ‚çš„æ•°å­¦ï¼Œå¦‚çŸ©é˜µå˜åŒ–å’Œå‡ ä½•è®¡ç®—ï¼ŒGPUçš„ä¸»è¦ä½œç”¨å°±æ˜¯ç¡®å®šæœ€ç»ˆè¾“é€ç»™æ˜¾ç¤ºå™¨çš„å„ä¸ªåƒç´ ç‚¹çš„è‰²å€¼ã€‚ åœ¨æœ€ç®€å•çš„æƒ…å†µä¸‹ï¼Œå¸§ç¼“å­˜åŒºåªæœ‰ä¸€ä¸ªï¼Œè¿™æ—¶å¸§ç¼“å­˜åŒºçš„è¯»å–å’Œåˆ·æ–°éƒ½ä¼šæœ‰æ¯”è¾ƒå¤§çš„æ•ˆçŽ‡é—®é¢˜ã€‚ä¸ºäº†è§£å†³æ•ˆçŽ‡é—®é¢˜ï¼Œæ˜¾ç¤ºç³»ç»Ÿé€šå¸¸ä¼šå¼•å…¥ä¸¤ä¸ªç¼“å†²åŒºï¼Œè®©è§†é¢‘æŽ§åˆ¶å™¨è¯»å–ï¼Œå½“ä¸‹ä¸€å¸§æ¸²æŸ“å¥½åŽï¼ŒGPUä¼šç›´æŽ¥æŠŠè§†é¢‘æŽ§åˆ¶å™¨çš„æŒ‡é’ˆæŒ‡å‘ç¬¬äºŒä¸ªç¼“å†²å™¨ã€‚å¦‚æ­¤ä¸€æ¥æ•ˆçŽ‡ä¼šæœ‰å¾ˆå¤§çš„æé«˜ã€‚ åŒç¼“å†²è™½ç„¶èƒ½è§£å†³æ•ˆçŽ‡é—®é¢˜ï¼Œä½†ä¼šå¼•å…¥ä¸€ä¸ªæ–°çš„é—®é¢˜ã€‚å½“è§†é¢‘æŽ§åˆ¶å™¨è¿˜æœªè¯»å–å®Œæˆæ—¶ï¼Œå³å±å¹•å†…å®¹åˆšæ˜¾ç¤ºä¸€åŠæ—¶ï¼ŒGPUå°†æ–°çš„ä¸€å¸§å†…å®¹æäº¤åˆ°å¸§ç¼“å­˜åŒºå¹¶æŠŠä¸¤ä¸ªç¼“å†²åŒºè¿›è¡Œäº¤æ¢åŽï¼Œè§†é¢‘æŽ§åˆ¶å™¨å°±ä¼šæŠŠæ–°çš„ä¸€å¸§æ•°æ®çš„ä¸‹åŠæ®µæ˜¾ç¤ºåˆ°å±å¹•ä¸Šï¼Œé€ æˆç”»é¢æ’•è£‚çŽ°è±¡ï¼Œå¦‚ä¸‹å›¾ï¼š ![dive_into_flutter_vsync_off](/images/dive_into_flutter_vsync_off.jpg ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒGPUé€šå¸¸æœ‰ä¸€ä¸ªæœºåˆ¶å«åšåž‚ç›´åŒæ­¥ï¼ˆç®€å†™ä¹Ÿæ˜¯V-Syncï¼‰ï¼Œå½“å¼€å¯åž‚ç›´åŒæ­¥åŽï¼ŒGPUä¼šç­‰å¾…æ˜¾ç¤ºå™¨çš„VSyncä¿¡å·å‘å‡ºåŽï¼Œæ‰è¿›è¡Œæ–°çš„ä¸€å¸§æ¸²æŸ“å’Œç¼“å­˜åŒºæ›´æ–°ã€‚è¿™æ ·èƒ½è§£å†³ç”»é¢æ’•è£‚çŽ°è±¡ï¼Œä¹Ÿå¢žåŠ äº†ç”»é¢æµç•…åº¦ï¼Œä½†éœ€è¦æ¶ˆè´¹æ›´å¤šçš„è®¡ç®—èµ„æºï¼Œä¹Ÿä¼šå¸¦æ¥éƒ¨åˆ†å»¶è¿Ÿã€‚ é‚£ä¹ˆç›®å‰ä¸»æµçš„ç§»åŠ¨è®¾å¤‡æ˜¯ä»€ä¹ˆæƒ…å†µï¼Ÿä»Žç½‘ä¸ŠæŸ¥åˆ°çš„èµ„æ–™å¯ä»¥çŸ¥é“ï¼ŒiOSè®¾å¤‡ä¼šå§‹ç»ˆä½¿ç”¨åŒç¼“å­˜ï¼Œå¹¶å¼€å¯åž‚ç›´åŒæ­¥ã€‚è€Œå®‰å“è®¾å¤‡åˆ°4.1ç‰ˆæœ¬ï¼ŒGoogleæ‰å¼€å§‹å¼•å…¥è¿™ç§æœºåˆ¶ï¼Œç›®å‰å®‰å“ç³»ç»Ÿæ˜¯ä¸‰ç¼“å­˜+åž‚ç›´åŒæ­¥ã€‚ å½“VSyncä¿¡å·åˆ°æ¥åŽï¼Œç³»ç»Ÿå›¾å½¢æœåŠ¡ä¼šé€šè¿‡CADisplayLink(iOS),ViewTreeObserver(Android)ç­‰æœºåˆ¶é€šçŸ¥Appï¼ŒAppä¸»çº¿ç¨‹å¼€å§‹åœ¨CPUä¸­è®¡ç®—æ˜¾ç¤ºå†…å®¹ï¼Œæ¯”å¦‚è§†å›¾çš„åˆ›å»ºã€å¸ƒå±€è®¡ç®—ã€å›¾ç‰‡è§£ç ã€æ–‡æœ¬ç»˜åˆ¶ç­‰ã€‚éšåŽCPUä¼šå°†è®¡ç®—å¥½çš„å†…å®¹æäº¤åˆ°GPUåŽ»ï¼Œç”±GPUè¿›è¡Œå˜åŒ–ã€åˆæˆã€æ¸²æŸ“ã€‚éšåŽGPUä¼šæŠŠæ¸²æŸ“ç»“æžœæäº¤åˆ°å¸§ç¼“å†²åŒºåŽ»ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡VSyncä¿¡å·åˆ°æ¥æ—¶æ˜¾ç¤ºåˆ°å±å¹•ä¸Šã€‚ç”±äºŽåž‚ç›´åŒæ­¥çš„æœºåˆ¶ï¼Œå¦‚æžœåœ¨ä¸€ä¸ªVSyncæ—¶é—´å†…ï¼ŒCPUæˆ–è€…GPUæ²¡æœ‰å®Œæˆå†…å®¹æäº¤ï¼Œåˆ™é‚£ä¸€å¸§å°±ä¼šè¢«ä¸¢å¼ƒï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡æœºä¼šå†æ˜¾ç¤ºï¼Œè€Œè¿™æ—¶æ˜¾ç¤ºå±ä¼šä¿ç•™ä¹‹å‰çš„å†…å®¹ä¸å˜ã€‚è¿™å°±æ˜¯ç•Œé¢å¡é¡¿çš„åŽŸå› ã€‚ å¡é¡¿äº§ç”Ÿçš„åŽŸå› å’Œè§£å†³æ–¹æ¡ˆå‚è€ƒ:iOSä¿æŒç•Œé¢æµç•…çš„æŠ€å·§","link":"/2019/08/09/Dive-Into-Flutter/"},{"title":"Espresso","text":"Androidå•å…ƒæµ‹è¯•å®˜æ–¹supportåŒ…Espressoä½¿ç”¨ ä¸å‡†å¤‡åšç³»ç»ŸåŒ–çš„Apiæ¢³ç†å®˜æ–¹æ–‡æ¡£é‡Œé¢å·²ç»å¾ˆè¯¦ç»†è¯´æ˜Žäº†Espressoï¼Œè¿™é‡Œä¼šç´¯è®¡ä¸€äº›å‘æˆ–è€…ç»†èŠ‚ã€‚ intended/intendingintended Asserts that the given matcher matches one and only one intent sent by the application under test. This is an equivalent of verify(mock, times(1)) in Mockito. Verification does not have to occur in the same order as the intents were sent. Intents are recorded from the time that Intents.init is called. æ–­è¨€åªä¼šç»™matcheråŒ¹é…ä¸€ä¸ªä¸”åªæœ‰ä¸€ä¸ªç”±applicationå‘æ¥çš„intentã€‚ç±»ä¼¼äºŽMockitoä¸­çš„verify(mock,times(1))å‡½æ•°,éªŒè¯è¿‡ç¨‹ä¸éœ€è¦æŒ‰ç…§å‘é€intentçš„ç›¸åŒé¡ºåºè¿›è¡Œï¼Œä»ŽIntent.initå¼€å§‹è®°å½•ã€‚ intending Enables stubbing intent responses. This method is similar to Mockito.when and is particularly useful when the activity launching the intent expects data to be returned (and especially in the case when the destination activity is external). In this case, the test author can call intending(matcher).thenRespond(myResponse) and validate that the launching activity handles the result correctly. Note: the destination activity will not be launched. æ‰“å¼€stubbing Intentå“åº”,ç±»ä¼¼äºŽMockitoã€‚å½“æ‹‰èµ·Activityï¼Œå¹¶é¢„è®¡æœ‰Intentè¿”å›žæ—¶ï¼ˆç‰¹åˆ«æ˜¯å½“ç›®æ ‡Acticityæ˜¯å¤–éƒ¨Acticityæ—¶ï¼‰ï¼Œç‰¹åˆ«æœ‰ç”¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæµ‹è¯•è€…å¯ä»¥è°ƒç”¨intending(matcher).thenRespond(myResponse)å¹¶éªŒè¯æ‹‰èµ·Activityæ˜¯å¦æ­£ç¡®å¤„ç†ç»“æžœã€‚Note:ç›®æ ‡Activityå°†ä¸ä¼šå¯åŠ¨ã€‚","link":"/2019/08/07/Espresso/"},{"title":"MAC android studio3.1.2æ— æ¯”å¡ï¼Œè§£å†³æ–¹æ¡ˆ","text":"å‡çº§Android Studio3.1.2ä»¥åŽï¼ŒçœŸæ˜¯javaæ–‡ä»¶å†™ä¸€ä¸ªå­—å¡ä¸‰ä¸ªå­—ï¼Œxmlæ–‡ä»¶æ ¹æœ¬ä¸æ•¢æ‰“å¼€ã€‚åœ¨V2exæ‰¾åˆ°çš„è§£å†³åŠžæ³•æ˜¯å¼ºåˆ¶ä½¿ç”¨ç‹¬æ˜¾ã€‚ä¼šæœ‰ä¸€å®šçš„æ•ˆæžœï¼Œä¸è¿‡æ²»æ ‡ä¸æ²»æ ‡ï¼Œé•¿ä¹…çš„è·‘è¿˜æ˜¯ä¼šå¡ï¼Œå¹¶ä¸”ç”µé‡æ¶ˆè€—å¥‡å¿«ã€‚åˆ†äº«ä¸€ä¸ªä¸‹command line å‡çº§Android Studio3.1.2ä»¥åŽï¼ŒçœŸæ˜¯javaæ–‡ä»¶å†™ä¸€ä¸ªå­—å¡ä¸‰ä¸ªå­—ï¼Œxmlæ–‡ä»¶æ ¹æœ¬ä¸æ•¢æ‰“å¼€ã€‚åœ¨V2exæ‰¾åˆ°çš„è§£å†³åŠžæ³•æ˜¯å¼ºåˆ¶ä½¿ç”¨ç‹¬æ˜¾ã€‚ä¼šæœ‰ä¸€å®šçš„æ•ˆæžœï¼Œä¸è¿‡æ²»æ ‡ä¸æ²»æ ‡ï¼Œé•¿ä¹…çš„è·‘è¿˜æ˜¯ä¼šå¡ï¼Œå¹¶ä¸”ç”µé‡æ¶ˆè€—å¥‡å¿«ã€‚åˆ†äº«ä¸€ä¸ªä¸‹command line sudo pmset -a GPUSwitch 1 0 - å¼ºåˆ¶ä½¿ç”¨æ ¸æ˜¾ 1 - å¼ºåˆ¶ä½¿ç”¨ç‹¬æ˜¾ï¼ˆç›¸å½“äºŽåœ¨åå¥½è®¾ç½®-èŠ‚èƒ½ é‡ŒåŽ»æŽ‰è‡ªåŠ¨åˆ‡æ¢æ˜¾å¡è¿™ä¸ªé€‰é¡¹ï¼‰ 2 - è‡ªåŠ¨åˆ‡æ¢æ˜¾å¡ å…¶å®žæ—¶é—´æ˜¯æœ€å¥½çš„è€å¸ˆï¼Œå…¬å¸èµ¶é¡¹ç›®ï¼Œåªèƒ½å¿ï¼Œä»Šå¤©å¿™å®Œæ‰¾äº†ä¸€ä¸‹ï¼Œå¦‚ä¸‹è§£å†³æ–¹æ¡ˆæ­£åˆé€‚ Help -&gt; Edit Custom VM Optionsâ€¦ ä¿®æ”¹å¦‚ä¸‹éƒ¨åˆ† -Xms956m -Xmx3280m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -Djna.nosys=true -Djna.boot.library.path= -da Settings -&gt; Appearance -&gt; Show memory indicatorç„¶åŽä½ å°±å¯ä»¥åœ¨ideaå³ä¸‹è§’çœ‹åˆ°å†…å­˜ä½¿ç”¨æƒ…å†µäº† å‚è€ƒ:å®˜æ–¹æä¾›çš„å¼€å‘å·¥å…·è°ƒä¼˜ç­–ç•¥","link":"/2018/06/01/MAC-android-studio3-1-2%E6%97%A0%E6%AF%94%E5%8D%A1%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"MediaPipeåœ¨Androidå¹³å°ä¸Šæž„å»ºAAR","text":"éœ€è¦åœ¨å®žæ—¶éŸ³è§†é¢‘ä¸­å®žçŽ°è™šæ‹ŸèƒŒæ™¯ï¼Œæˆ–è€…åœ¨äººåƒä¸Šè¿›è¡Œè´´çº¸ã€‚å¸Œæœ›åœ¨Googleå¼€æºçš„MediaPipeä¸­æ‰¾åˆ°è§£å†³æ–¹æ¡ˆï¼Œæœ¬æ–‡ç« ä»‹ç»MediaPipeåœ¨MacOSä¸­çš„çŽ¯å¢ƒæ­å»ºï¼Œä»¥åŠç¼–è¯‘AARã€‚åŽç»­ä¼šè¡¥å……æœºæ¢°å­¦ä¹ ç›¸å…³åœ¨Androidå¹³å°ä¸Šçš„ä½¿ç”¨ çŽ¯å¢ƒæ­å»º èŽ·å–æºç https://github.com/google/mediapipe.git å®‰è£…bazel brew install bazel ç§‘å­¦ä¸Šç½‘ ç¼–è¯‘è„šæœ¬ åˆ›å»ºç›¸å…³æ–‡ä»¶å¤¹ã€BUILDæ–‡ä»¶ cd mediapipe/examples/android/src/java/com/google/mediapipe/apps/mkdir buid_aar &amp;&amp; cd buid_aartouch BUILD ç¼–å†™ç¼–è¯‘è„šæœ¬ï¼ŒæŒ‡å®šéœ€è¦ç¼–è¯‘çš„æ¨¡åž‹å’Œè®¡ç®—å•å…ƒï¼Œè¾“å‡ºçš„æ–‡ä»¶å load(&quot;//mediapipe/java/com/google/mediapipe:mediapipe_aar.bzl&quot;, &quot;mediapipe_aar&quot;)mediapipe_aar( name = &quot;mediapipe_portrait_segmentation&quot;, calculators = [&quot;//mediapipe/graphs/portrait_segmentation:mobile_calculators&quot;],) æŒ‡å®šéœ€è¦çš„cpuæž¶æž„ï¼Œæ‰§è¡Œç¼–è¯‘ bazel build --cxxopt='--std=c++14' -c opt --fat_apk_cpu=arm64-v8a,armeabi-v7a examples/android/src/java/com/google/mediapipe/apps/buid_aar:mediapipe_portrait_segmentation --host_crosstool_top=@bazel_tools//tools/cpp:toolchain --verbose_failures ç”Ÿæˆçš„aarè·¯å¾„ï¼š bazel-bin/mediapipe/examples/android/src/java/com/google/mediapipe/apps/buid_aar/mediapipe_portrait_segmentation.aar ç”ŸæˆMediapipeäºŒè¿›åˆ¶å›¾ï¼Œ bazel build -c opt mediapipe/graphs/portrait_segmentation:portrait_segmentation_mobile_gpu_binary_graph","link":"/2021/04/28/MediaPipe%E5%9C%A8Android%E5%B9%B3%E5%8F%B0%E4%B8%8A%E6%9E%84%E5%BB%BAAAR/"},{"title":"Androidå¹³å°WebRTCå¼€å¯H265ç¼–è§£ç ","text":"ä¸åƒH264ï¼ŒWebRTCå·²ç»åœ¨å†…éƒ¨å¤„ç†å¥½äº†ç›¸å…³é€»è¾‘ï¼Œæˆ‘ä»¬åªéœ€è¦ç¨ä½œä¿®æ”¹å³å¯å®žçŽ°H264ç¼–è§£ç ï¼ˆç¡¬ç¼–åªéœ€æŒ‡å®šsdpï¼Œè½¯ç¼–åªéœ€æ‰“å¼€å¼€å…³@see ã€ŠAndroidå¹³å°WebRTCå¼€å¯H264è½¯ç¼–è§£ç ã€‹ï¼‰ã€‚å¦‚è¦å®žçŽ°H265ï¼Œä¸ä»…è¦å¢žåŠ æŽ¥å£ï¼Œè¿˜éœ€è¦æ·»åŠ å°è§£RTPåŒ…çš„é€»è¾‘ï¼Œæœ¬æ–‡åŸºäºŽM86ã€‚ å¼€å¯H265ç¼–è§£ç æ‰“å¼€æ”¯æŒ å¢žåŠ sdpæ”¯æŒï¼š sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java @Overridepublic VideoCodecInfo[] getSupportedCodecs() {... for (VideoCodecMimeType type : new VideoCodecMimeType[] { VideoCodecMimeType.VP8, VideoCodecMimeType.VP9, VideoCodecMimeType.H264, VideoCodecMimeType.H265})... return supportedCodecInfos.toArray(new VideoCodecInfo[supportedCodecInfos.size()]);} å¢žåŠ sps/pps/vpsæ”¯æŒï¼š sdk/android/src/java/org/webrtc/HardwareVideoEncoder.javaprotected void deliverEncodedImage() {... final ByteBuffer frameBuffer; if (isKeyFrame &amp;&amp; (codecType == VideoCodecMimeType.H264 || codecType == VideoCodecMimeType.H265)) } å°åŒ…æ”¯æŒ å¢žåŠ è§£åŒ…å™¨åˆå§‹åŒ–å…¥å£ modules/rtp_rtcp/source/create_video_rtp_depacketizer.cc... #ifndef DISABLE_H265 #include &quot;modules/rtp_rtcp/source/video_rtp_depacketizer_h265.h&quot; #endif... #ifndef DISABLE_H265 case kVideoCodecH265: return std::make_unique&lt;VideoRtpDepacketizerH265&gt;(); #endif... foramtåŸºç±»å¢žåŠ H265æ”¯æŒ modules/rtp_rtcp/source/rtp_format.cc... #ifndef DISABLE_H265 #include &quot;modules/rtp_rtcp/source/rtp_format_h265.h&quot; #endif... #ifndef DISABLE_H265 #include &quot;modules/video_coding/codecs/h265/include/h265_globals.h&quot; #endif...std::unique_ptr&lt;RtpPacketizer&gt; RtpPacketizer::Create( absl::optional&lt;VideoCodecType&gt; type, rtc::ArrayView&lt;const uint8_t&gt; payload, PayloadSizeLimits limits, // Codec-specific details. const RTPVideoHeader&amp; rtp_video_header) { if (!type) { // Use raw packetizer. return std::make_unique&lt;RtpPacketizerGeneric&gt;(payload, limits); } switch (*type) { case kVideoCodecH264: { const auto&amp; h264 = absl::get&lt;RTPVideoHeaderH264&gt;(rtp_video_header.video_type_header); return std::make_unique&lt;RtpPacketizerH264&gt;(payload, limits, h264.packetization_mode); } #ifndef DISABLE_H265 case kVideoCodecH265: { const auto&amp; h265 = absl::get&lt;RTPVideoHeaderH265&gt;(rtp_video_header.video_type_header); return absl::make_unique&lt;RtpPacketizerH265&gt;( payload, limits, h265.packetization_mode); }#endif... }} æ–°å¢žH265 formatå®žçŽ°ç±»rtp_format_h265ï¼š modules/rtp_rtcp/source/rtp_format_h265.cc >folded#include &lt;string.h&gt;#include &quot;absl/types/optional.h&quot;#include &quot;absl/types/variant.h&quot;#include &quot;common_video/h264/h264_common.h&quot;#include &quot;common_video/h265/h265_common.h&quot;#include &quot;common_video/h265/h265_pps_parser.h&quot;#include &quot;common_video/h265/h265_sps_parser.h&quot;#include &quot;common_video/h265/h265_vps_parser.h&quot;#include &quot;modules/include/module_common_types.h&quot;#include &quot;modules/rtp_rtcp/source/byte_io.h&quot;#include &quot;modules/rtp_rtcp/source/rtp_format_h265.h&quot;#include &quot;modules/rtp_rtcp/source/rtp_packet_to_send.h&quot;#include &quot;rtc_base/logging.h&quot;using namespace rtc;namespace webrtc {namespace {enum NaluType { kTrailN = 0, kTrailR = 1, kTsaN = 2, kTsaR = 3, kStsaN = 4, kStsaR = 5, kRadlN = 6, kRadlR = 7, kBlaWLp = 16, kBlaWRadl = 17, kBlaNLp = 18, kIdrWRadl = 19, kIdrNLp = 20, kCra = 21, kVps = 32, kHevcSps = 33, kHevcPps = 34, kHevcAud = 35, kPrefixSei = 39, kSuffixSei = 40, kHevcAp = 48, kHevcFu = 49};/* 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | PayloadHdr (Type=49) | FU header | DONL (cond) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|*/// Unlike H.264, HEVC NAL header is 2-bytes.static const size_t kHevcNalHeaderSize = 2;// H.265's FU is constructed of 2-byte payload header, and 1-byte FU headerstatic const size_t kHevcFuHeaderSize = 1;static const size_t kHevcLengthFieldSize = 2;enum HevcNalHdrMasks { kHevcFBit = 0x80, kHevcTypeMask = 0x7E, kHevcLayerIDHMask = 0x1, kHevcLayerIDLMask = 0xF8, kHevcTIDMask = 0x7, kHevcTypeMaskN = 0x81, kHevcTypeMaskInFuHeader = 0x3F};// Bit masks for FU headers.enum HevcFuDefs { kHevcSBit = 0x80, kHevcEBit = 0x40, kHevcFuTypeBit = 0x3F };} // namespaceRtpPacketizerH265::RtpPacketizerH265( rtc::ArrayView&lt;const uint8_t&gt; payload, PayloadSizeLimits limits, H265PacketizationMode packetization_mode) : limits_(limits), num_packets_left_(0) { // Guard against uninitialized memory in packetization_mode. RTC_CHECK(packetization_mode == H265PacketizationMode::NonInterleaved || packetization_mode == H265PacketizationMode::SingleNalUnit); for (const auto&amp; nalu : H264::FindNaluIndices(payload.data(), payload.size())) { input_fragments_.push_back( payload.subview(nalu.payload_start_offset, nalu.payload_size)); } if (!GeneratePackets(packetization_mode)) { // If failed to generate all the packets, discard already generated // packets in case the caller would ignore return value and still try to // call NextPacket(). num_packets_left_ = 0; while (!packets_.empty()) { packets_.pop(); } }}RtpPacketizerH265::~RtpPacketizerH265() {}size_t RtpPacketizerH265::NumPackets() const { return num_packets_left_;}bool RtpPacketizerH265::GeneratePackets( H265PacketizationMode packetization_mode) { // For HEVC we follow non-interleaved mode for the packetization, // and don't support single-nalu mode at present. for (size_t i = 0; i &lt; input_fragments_.size();) { int fragment_len = input_fragments_[i].size(); int single_packet_capacity = limits_.max_payload_len; if (input_fragments_.size() == 1) single_packet_capacity -= limits_.single_packet_reduction_len; else if (i == 0) single_packet_capacity -= limits_.first_packet_reduction_len; else if (i + 1 == input_fragments_.size()) { // Pretend that last fragment is larger instead of making last packet // smaller. single_packet_capacity -= limits_.last_packet_reduction_len; } if (fragment_len &gt; single_packet_capacity) { PacketizeFu(i); ++i; } else { PacketizeSingleNalu(i); ++i; } } return true;}bool RtpPacketizerH265::PacketizeFu(size_t fragment_index) { // Fragment payload into packets (FU). // Strip out the original header and leave room for the FU header. rtc::ArrayView&lt;const uint8_t&gt; fragment = input_fragments_[fragment_index]; PayloadSizeLimits limits = limits_; limits.max_payload_len -= kHevcFuHeaderSize + kHevcNalHeaderSize; // Update single/first/last packet reductions unless it is single/first/last // fragment. if (input_fragments_.size() != 1) { // if this fragment is put into a single packet, it might still be the // first or the last packet in the whole sequence of packets. if (fragment_index == input_fragments_.size() - 1) { limits.single_packet_reduction_len = limits_.last_packet_reduction_len; } else if (fragment_index == 0) { limits.single_packet_reduction_len = limits_.first_packet_reduction_len; } else { limits.single_packet_reduction_len = 0; } } if (fragment_index != 0) limits.first_packet_reduction_len = 0; if (fragment_index != input_fragments_.size() - 1) limits.last_packet_reduction_len = 0; // Strip out the original header. size_t payload_left = fragment.size() - kHevcNalHeaderSize; int offset = kHevcNalHeaderSize; std::vector&lt;int&gt; payload_sizes = SplitAboutEqually(payload_left, limits); if (payload_sizes.empty()) return false; for (size_t i = 0; i &lt; payload_sizes.size(); ++i) { int packet_length = payload_sizes[i]; RTC_CHECK_GT(packet_length, 0); uint16_t header = (fragment[0] &lt;&lt; 8) | fragment[1]; packets_.push(PacketUnit(fragment.subview(offset, packet_length), /*first_fragment=*/i == 0, /*last_fragment=*/i == payload_sizes.size() - 1, false, header)); offset += packet_length; payload_left -= packet_length; } num_packets_left_ += payload_sizes.size(); RTC_CHECK_EQ(0, payload_left); return true;}bool RtpPacketizerH265::PacketizeSingleNalu(size_t fragment_index) { // Add a single NALU to the queue, no aggregation. size_t payload_size_left = limits_.max_payload_len; if (input_fragments_.size() == 1) payload_size_left -= limits_.single_packet_reduction_len; else if (fragment_index == 0) payload_size_left -= limits_.first_packet_reduction_len; else if (fragment_index + 1 == input_fragments_.size()) payload_size_left -= limits_.last_packet_reduction_len; rtc::ArrayView&lt;const uint8_t&gt; fragment = input_fragments_[fragment_index]; if (payload_size_left &lt; fragment.size()) { RTC_LOG(LS_ERROR) &lt;&lt; &quot;Failed to fit a fragment to packet in SingleNalu &quot; &quot;packetization mode. Payload size left &quot; &lt;&lt; payload_size_left &lt;&lt; &quot;, fragment length &quot; &lt;&lt; fragment.size() &lt;&lt; &quot;, packet capacity &quot; &lt;&lt; limits_.max_payload_len; return false; } RTC_CHECK_GT(fragment.size(), 0u); packets_.push(PacketUnit(fragment, true /* first */, true /* last */, false /* aggregated */, fragment[0])); ++num_packets_left_; return true;}int RtpPacketizerH265::PacketizeAp(size_t fragment_index) { // Aggregate fragments into one packet (STAP-A). size_t payload_size_left = limits_.max_payload_len; if (input_fragments_.size() == 1) payload_size_left -= limits_.single_packet_reduction_len; else if (fragment_index == 0) payload_size_left -= limits_.first_packet_reduction_len; int aggregated_fragments = 0; size_t fragment_headers_length = 0; rtc::ArrayView&lt;const uint8_t&gt; fragment = input_fragments_[fragment_index]; RTC_CHECK_GE(payload_size_left, fragment.size()); ++num_packets_left_; auto payload_size_needed = [&amp;] { size_t fragment_size = fragment.size() + fragment_headers_length; if (input_fragments_.size() == 1) { // Single fragment, single packet, payload_size_left already adjusted // with limits_.single_packet_reduction_len. return fragment_size; } if (fragment_index == input_fragments_.size() - 1) { // Last fragment, so StrapA might be the last packet. return fragment_size + limits_.last_packet_reduction_len; } return fragment_size; }; while (payload_size_left &gt;= payload_size_needed()) { RTC_CHECK_GT(fragment.size(), 0); packets_.push(PacketUnit(fragment, aggregated_fragments == 0, false, true, fragment[0])); payload_size_left -= fragment.size(); payload_size_left -= fragment_headers_length; fragment_headers_length = kHevcLengthFieldSize; // If we are going to try to aggregate more fragments into this packet // we need to add the STAP-A NALU header and a length field for the first // NALU of this packet. if (aggregated_fragments == 0) fragment_headers_length += kHevcNalHeaderSize + kHevcLengthFieldSize; ++aggregated_fragments; // Next fragment. ++fragment_index; if (fragment_index == input_fragments_.size()) break; fragment = input_fragments_[fragment_index]; } RTC_CHECK_GT(aggregated_fragments, 0); packets_.back().last_fragment = true; return fragment_index;}bool RtpPacketizerH265::NextPacket(RtpPacketToSend* rtp_packet) { RTC_DCHECK(rtp_packet); if (packets_.empty()) { return false; } PacketUnit packet = packets_.front(); if (packet.first_fragment &amp;&amp; packet.last_fragment) { // Single NAL unit packet. size_t bytes_to_send = packet.source_fragment.size(); uint8_t* buffer = rtp_packet-&gt;AllocatePayload(bytes_to_send); memcpy(buffer, packet.source_fragment.data(), bytes_to_send); packets_.pop(); input_fragments_.pop_front(); } else if (packet.aggregated) { bool is_last_packet = num_packets_left_ == 1; NextAggregatePacket(rtp_packet, is_last_packet); } else { NextFragmentPacket(rtp_packet); } rtp_packet-&gt;SetMarker(packets_.empty()); --num_packets_left_; return true;}void RtpPacketizerH265::NextAggregatePacket(RtpPacketToSend* rtp_packet, bool last) { size_t payload_capacity = rtp_packet-&gt;FreeCapacity(); RTC_CHECK_GE(payload_capacity, kHevcNalHeaderSize); uint8_t* buffer = rtp_packet-&gt;AllocatePayload(payload_capacity); RTC_CHECK(buffer); PacketUnit* packet = &amp;packets_.front(); RTC_CHECK(packet-&gt;first_fragment); uint8_t payload_hdr_h = packet-&gt;header &gt;&gt; 8; uint8_t payload_hdr_l = packet-&gt;header &amp; 0xFF; uint8_t layer_id_h = payload_hdr_h &amp; kHevcLayerIDHMask; payload_hdr_h = (payload_hdr_h &amp; kHevcTypeMaskN) | (kHevcAp &lt;&lt; 1) | layer_id_h; buffer[0] = payload_hdr_h; buffer[1] = payload_hdr_l; int index = kHevcNalHeaderSize; bool is_last_fragment = packet-&gt;last_fragment; while (packet-&gt;aggregated) { // Add NAL unit length field. rtc::ArrayView&lt;const uint8_t&gt; fragment = packet-&gt;source_fragment; ByteWriter&lt;uint16_t&gt;::WriteBigEndian(&amp;buffer[index], fragment.size()); index += kHevcLengthFieldSize; // Add NAL unit. memcpy(&amp;buffer[index], fragment.data(), fragment.size()); index += fragment.size(); packets_.pop(); input_fragments_.pop_front(); if (is_last_fragment) break; packet = &amp;packets_.front(); is_last_fragment = packet-&gt;last_fragment; } RTC_CHECK(is_last_fragment); rtp_packet-&gt;SetPayloadSize(index);}void RtpPacketizerH265::NextFragmentPacket(RtpPacketToSend* rtp_packet) { PacketUnit* packet = &amp;packets_.front(); // NAL unit fragmented over multiple packets (FU). // We do not send original NALU header, so it will be replaced by the // PayloadHdr of the first packet. uint8_t payload_hdr_h = packet-&gt;header &gt;&gt; 8; // 1-bit F, 6-bit type, 1-bit layerID highest-bit uint8_t payload_hdr_l = packet-&gt;header &amp; 0xFF; uint8_t layer_id_h = payload_hdr_h &amp; kHevcLayerIDHMask; uint8_t fu_header = 0; // S | E |6 bit type. fu_header |= (packet-&gt;first_fragment ? kHevcSBit : 0); fu_header |= (packet-&gt;last_fragment ? kHevcEBit : 0); uint8_t type = (payload_hdr_h &amp; kHevcTypeMask) &gt;&gt; 1; fu_header |= type; // Now update payload_hdr_h with FU type. payload_hdr_h = (payload_hdr_h &amp; kHevcTypeMaskN) | (kHevcFu &lt;&lt; 1) | layer_id_h; rtc::ArrayView&lt;const uint8_t&gt; fragment = packet-&gt;source_fragment; uint8_t* buffer = rtp_packet-&gt;AllocatePayload( kHevcFuHeaderSize + kHevcNalHeaderSize + fragment.size()); RTC_CHECK(buffer); buffer[0] = payload_hdr_h; buffer[1] = payload_hdr_l; buffer[2] = fu_header; if (packet-&gt;last_fragment) { memcpy(buffer + kHevcFuHeaderSize + kHevcNalHeaderSize, fragment.data(), fragment.size()); } else { memcpy(buffer + kHevcFuHeaderSize + kHevcNalHeaderSize, fragment.data(), fragment.size()); } packets_.pop();}} // namespace webrtc modules/rtp_rtcp/source/rtp_format_h265.h >folded#ifndef WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H265_H_#define WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H265_H_#include &lt;memory&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &quot;api/array_view.h&quot;#include &quot;modules/include/module_common_types.h&quot;#include &quot;modules/rtp_rtcp/source/rtp_format.h&quot;#include &quot;modules/rtp_rtcp/source/rtp_packet_to_send.h&quot;#include &quot;modules/rtp_rtcp/source/rtp_format.h&quot;#include &quot;modules/video_coding/codecs/h265/include/h265_globals.h&quot;#include &quot;rtc_base/buffer.h&quot;#include &quot;rtc_base/constructor_magic.h&quot;namespace webrtc {class RtpPacketizerH265 : public RtpPacketizer { public: // Initialize with payload from encoder. // The payload_data must be exactly one encoded H.265 frame. RtpPacketizerH265(rtc::ArrayView&lt;const uint8_t&gt; payload, PayloadSizeLimits limits, H265PacketizationMode packetization_mode); ~RtpPacketizerH265() override; size_t NumPackets() const override; // Get the next payload with H.265 payload header. // buffer is a pointer to where the output will be written. // bytes_to_send is an output variable that will contain number of bytes // written to buffer. The parameter last_packet is true for the last packet of // the frame, false otherwise (i.e., call the function again to get the // next packet). // Returns true on success or false if there was no payload to packetize. bool NextPacket(RtpPacketToSend* rtp_packet) override; private: struct Packet { Packet(size_t offset, size_t size, bool first_fragment, bool last_fragment, bool aggregated, uint16_t header) : offset(offset), size(size), first_fragment(first_fragment), last_fragment(last_fragment), aggregated(aggregated), header(header) {} size_t offset; size_t size; bool first_fragment; bool last_fragment; bool aggregated; uint16_t header; // Different from H264 }; struct PacketUnit { PacketUnit(rtc::ArrayView&lt;const uint8_t&gt; source_fragment, bool first_fragment, bool last_fragment, bool aggregated, uint16_t header) : source_fragment(source_fragment), first_fragment(first_fragment), last_fragment(last_fragment), aggregated(aggregated), header(header) {} rtc::ArrayView&lt;const uint8_t&gt; source_fragment; bool first_fragment; bool last_fragment; bool aggregated; uint16_t header; }; typedef std::queue&lt;Packet&gt; PacketQueue; std::deque&lt;rtc::ArrayView&lt;const uint8_t&gt;&gt; input_fragments_; std::queue&lt;PacketUnit&gt; packets_; bool GeneratePackets(H265PacketizationMode packetization_mode); bool PacketizeFu(size_t fragment_index); int PacketizeAp(size_t fragment_index); bool PacketizeSingleNalu(size_t fragment_index); void NextAggregatePacket(RtpPacketToSend* rtp_packet, bool last); void NextFragmentPacket(RtpPacketToSend* rtp_packet); const PayloadSizeLimits limits_; size_t num_packets_left_; RTC_DISALLOW_COPY_AND_ASSIGN(RtpPacketizerH265);};} // namespace webrtc#endif // WEBRTC_MODULES_RTP_RTCP_SOURCE_RTP_FORMAT_H265_H_ è§†é¢‘æ¸²æŸ“æ”¯æŒ,vpxé€šè¿‡picture_id,temporal_id,tl0_pic_idæ ‡è¯†Nalué—´çš„å…³ç³»åŠæ˜¯å¦å¯è¿žç»­è§£ç ï¼ŒH26xé€šè¿‡seqnumï¼Œæ˜¯å¦æœ‰spsï¼Œppsæ¥åˆ¤æ–­å¸§é—´çš„è§£ç è¿žç»­æ€§ã€‚æ•…ï¼Œæˆ‘ä»¬æŠŠH265çš„temporalIdç½®ä¸ºkNoTemporalIdxå³å¯ï¼š modules/rtp_rtcp/source/rtp_sender_video.ccuint8_t RTPSenderVideo::GetTemporalId(const RTPVideoHeader&amp; header) { struct TemporalIdGetter { uint8_t operator()(const RTPVideoHeaderVP8&amp; vp8) { return vp8.temporalIdx; } uint8_t operator()(const RTPVideoHeaderVP9&amp; vp9) { return vp9.temporal_idx; } uint8_t operator()(const RTPVideoHeaderH264&amp;) { return kNoTemporalIdx; } #ifndef DISABLE_H265 uint8_t operator()(const RTPVideoHeaderH265&amp;) { return kNoTemporalIdx; } #endif... return absl::visit(TemporalIdGetter(), header.video_type_header);} RTPå¤´å¢žåŠ H265æ”¯æŒæž„é€ å‡½æ•°,æ³¨æ„#ifndefä¸Ž#ifdefçš„åŒºåˆ«ï¼š modules/rtp_rtcp/source/rtp_video_header.h#include &quot;modules/video_coding/codecs/h264/include/h264_globals.h&quot; #ifndef DISABLE_H265 #include &quot;modules/video_coding/codecs/h265/include/h265_globals.h&quot; #endif#include &quot;modules/video_coding/codecs/vp8/include/vp8_globals.h&quot;... #ifdef DISABLE_H265using RTPVideoTypeHeader = absl::variant&lt;absl::monostate, RTPVideoHeaderVP8, RTPVideoHeaderVP9, RTPVideoHeaderH264, RTPVideoHeaderLegacyGeneric&gt;; #else using RTPVideoTypeHeader = absl::variant&lt;absl::monostate, RTPVideoHeaderVP8, RTPVideoHeaderVP9, RTPVideoHeaderH264, RTPVideoHeaderH265, RTPVideoHeaderLegacyGeneric&gt;; #endif æ–°å¢žH265è§£åŒ…é€»è¾‘video_rtp_depacketizer_h265ï¼š modules/rtp_rtcp/source/video_rtp_depacketizer_h265.h >folded#ifndef MODULES_RTP_RTCP_SOURCE_VIDEO_RTP_DEPACKETIZER_H265_H_#define MODULES_RTP_RTCP_SOURCE_VIDEO_RTP_DEPACKETIZER_H265_H_#include &quot;absl/types/optional.h&quot;#include &quot;modules/rtp_rtcp/source/video_rtp_depacketizer.h&quot;#include &quot;rtc_base/copy_on_write_buffer.h&quot;namespace webrtc {class VideoRtpDepacketizerH265 : public VideoRtpDepacketizer { public: ~VideoRtpDepacketizerH265() override = default; absl::optional&lt;ParsedRtpPayload&gt; Parse( rtc::CopyOnWriteBuffer rtp_payload) override;private: struct ParsedPayload { RTPVideoHeader&amp; video_header() { return video; } const RTPVideoHeader&amp; video_header() const { return video; } RTPVideoHeader video; const uint8_t* payload; size_t payload_length; }; bool Parse(ParsedPayload* parsed_payload, const uint8_t* payload_data, size_t payload_data_length); bool ParseFuNalu(ParsedPayload* parsed_payload, const uint8_t* payload_data); bool ProcessApOrSingleNalu(ParsedPayload* parsed_payload, const uint8_t* payload_data); size_t offset_; size_t length_; std::unique_ptr&lt;rtc::Buffer&gt; modified_buffer_;};} // namespace webrtc#endif // MODULES_RTP_RTCP_SOURCE_VIDEO_RTP_DEPACKETIZER_H265_H_ modules/rtp_rtcp/source/video_rtp_depacketizer_h265.cc >folded#include &quot;modules/rtp_rtcp/source/video_rtp_depacketizer_h265.h&quot;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &quot;absl/base/macros.h&quot;#include &quot;absl/types/optional.h&quot;#include &quot;absl/types/variant.h&quot;#include &quot;common_video/h264/h264_common.h&quot;#include &quot;common_video/h265/h265_common.h&quot;#include &quot;common_video/h265/h265_pps_parser.h&quot;#include &quot;common_video/h265/h265_sps_parser.h&quot;#include &quot;common_video/h265/h265_vps_parser.h&quot;#include &quot;modules/rtp_rtcp/source/byte_io.h&quot;#include &quot;modules/rtp_rtcp/source/video_rtp_depacketizer.h&quot;#include &quot;rtc_base/checks.h&quot;#include &quot;rtc_base/copy_on_write_buffer.h&quot;#include &quot;rtc_base/logging.h&quot;namespace webrtc {namespace {/* 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | PayloadHdr (Type=49) | FU header | DONL (cond) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|*/// Unlike H.264, HEVC NAL header is 2-bytes.static const size_t kHevcNalHeaderSize = 2;// H.265's FU is constructed of 2-byte payload header, and 1-byte FU headerstatic const size_t kHevcFuHeaderSize = 1;static const size_t kHevcLengthFieldSize = 2;static const size_t kHevcApHeaderSize = kHevcNalHeaderSize + kHevcLengthFieldSize;enum HevcNalHdrMasks { kHevcFBit = 0x80, kHevcTypeMask = 0x7E, kHevcLayerIDHMask = 0x1, kHevcLayerIDLMask = 0xF8, kHevcTIDMask = 0x7, kHevcTypeMaskN = 0x81, kHevcTypeMaskInFuHeader = 0x3F};// Bit masks for FU headers.enum HevcFuDefs { kHevcSBit = 0x80, kHevcEBit = 0x40, kHevcFuTypeBit = 0x3F };// TODO(pbos): Avoid parsing this here as well as inside the jitter buffer.bool ParseApStartOffsets(const uint8_t* nalu_ptr, size_t length_remaining, std::vector&lt;size_t&gt;* offsets) { size_t offset = 0; while (length_remaining &gt; 0) { // Buffer doesn't contain room for additional nalu length. if (length_remaining &lt; sizeof(uint16_t)) return false; uint16_t nalu_size = ByteReader&lt;uint16_t&gt;::ReadBigEndian(nalu_ptr); nalu_ptr += sizeof(uint16_t); length_remaining -= sizeof(uint16_t); if (nalu_size &gt; length_remaining) return false; nalu_ptr += nalu_size; length_remaining -= nalu_size; offsets-&gt;push_back(offset + kHevcApHeaderSize); offset += kHevcLengthFieldSize + nalu_size; } return true;}} // namespacebool VideoRtpDepacketizerH265::Parse(ParsedPayload* parsed_payload, const uint8_t* payload_data, size_t payload_data_length) { RTC_CHECK(parsed_payload != nullptr); if (payload_data_length == 0) { RTC_LOG(LS_ERROR) &lt;&lt; &quot;Empty payload.&quot;; return false; } offset_ = 0; length_ = payload_data_length; modified_buffer_.reset(); uint8_t nal_type = (payload_data[0] &amp; kHevcTypeMask) &gt;&gt; 1; parsed_payload-&gt;video_header() .video_type_header.emplace&lt;RTPVideoHeaderH265&gt;(); if (nal_type == H265::NaluType::kFU) { // Fragmented NAL units (FU-A). if (!ParseFuNalu(parsed_payload, payload_data)) return false; } else { // We handle STAP-A and single NALU's the same way here. The jitter buffer // will depacketize the STAP-A into NAL units later. // TODO(sprang): Parse STAP-A offsets here and store in fragmentation vec. if (!ProcessApOrSingleNalu(parsed_payload, payload_data)) return false; } const uint8_t* payload = modified_buffer_ ? modified_buffer_-&gt;data() : payload_data; parsed_payload-&gt;payload = payload + offset_; parsed_payload-&gt;payload_length = length_; return true;}bool VideoRtpDepacketizerH265::ProcessApOrSingleNalu( ParsedPayload* parsed_payload, const uint8_t* payload_data) { parsed_payload-&gt;video_header().width = 0; parsed_payload-&gt;video_header().height = 0; parsed_payload-&gt;video_header().codec = kVideoCodecH265; parsed_payload-&gt;video_header().is_first_packet_in_frame = true; auto&amp; h265_header = absl::get&lt;RTPVideoHeaderH265&gt;( parsed_payload-&gt;video_header().video_type_header); const uint8_t* nalu_start = payload_data + kHevcNalHeaderSize; const size_t nalu_length = length_ - kHevcNalHeaderSize; uint8_t nal_type = (payload_data[0] &amp; kHevcTypeMask) &gt;&gt; 1; std::vector&lt;size_t&gt; nalu_start_offsets; if (nal_type == H265::NaluType::kAP) { // Skip the StapA header (StapA NAL type + length). if (length_ &lt;= kHevcApHeaderSize) { RTC_LOG(LS_ERROR) &lt;&lt; &quot;AP header truncated.&quot;; return false; } if (!ParseApStartOffsets(nalu_start, nalu_length, &amp;nalu_start_offsets)) { RTC_LOG(LS_ERROR) &lt;&lt; &quot;AP packet with incorrect NALU packet lengths.&quot;; return false; } h265_header.packetization_type = kH265AP; // nal_type = (payload_data[kHevcApHeaderSize] &amp; kHevcTypeMask) &gt;&gt; 1; } else { h265_header.packetization_type = kH265SingleNalu; nalu_start_offsets.push_back(0); } h265_header.nalu_type = nal_type; parsed_payload-&gt;video_header().frame_type = VideoFrameType::kVideoFrameDelta; nalu_start_offsets.push_back(length_ + kHevcLengthFieldSize); // End offset. for (size_t i = 0; i &lt; nalu_start_offsets.size() - 1; ++i) { size_t start_offset = nalu_start_offsets[i]; // End offset is actually start offset for next unit, excluding length field // so remove that from this units length. size_t end_offset = nalu_start_offsets[i + 1] - kHevcLengthFieldSize; if (end_offset - start_offset &lt; kHevcNalHeaderSize) { // Same as H.264. RTC_LOG(LS_ERROR) &lt;&lt; &quot;AP packet too short&quot;; return false; } H265NaluInfo nalu; nalu.type = (payload_data[start_offset] &amp; kHevcTypeMask) &gt;&gt; 1; nalu.vps_id = -1; nalu.sps_id = -1; nalu.pps_id = -1; start_offset += kHevcNalHeaderSize; switch (nalu.type) { case H265::NaluType::kVps: { absl::optional&lt;H265VpsParser::VpsState&gt; vps = H265VpsParser::ParseVps( &amp;payload_data[start_offset], end_offset - start_offset); if (vps) { nalu.vps_id = vps-&gt;id; } else { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Failed to parse VPS id from VPS slice.&quot;; } break; } case H265::NaluType::kSps: { // Check if VUI is present in SPS and if it needs to be modified to // avoid excessive decoder latency. // Copy any previous data first (likely just the first header). std::unique_ptr&lt;rtc::Buffer&gt; output_buffer(new rtc::Buffer()); if (start_offset) output_buffer-&gt;AppendData(payload_data, start_offset); absl::optional&lt;H265SpsParser::SpsState&gt; sps = H265SpsParser::ParseSps( &amp;payload_data[start_offset], end_offset - start_offset); if (sps) { parsed_payload-&gt;video_header().width = sps-&gt;width; parsed_payload-&gt;video_header().height = sps-&gt;height; nalu.sps_id = sps-&gt;id; nalu.vps_id = sps-&gt;vps_id; } else { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Failed to parse SPS and VPS id from SPS slice.&quot;; } parsed_payload-&gt;video_header().frame_type = VideoFrameType::kVideoFrameKey; break; } case H265::NaluType::kPps: { uint32_t pps_id; uint32_t sps_id; if (H265PpsParser::ParsePpsIds(&amp;payload_data[start_offset], end_offset - start_offset, &amp;pps_id, &amp;sps_id)) { nalu.pps_id = pps_id; nalu.sps_id = sps_id; } else { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Failed to parse PPS id and SPS id from PPS slice.&quot;; } break; } case H265::NaluType::kIdrWRadl: case H265::NaluType::kIdrNLp: case H265::NaluType::kCra: parsed_payload-&gt;video_header().frame_type = VideoFrameType::kVideoFrameKey; ABSL_FALLTHROUGH_INTENDED; case H265::NaluType::kTrailN: case H265::NaluType::kTrailR: { absl::optional&lt;uint32_t&gt; pps_id = H265PpsParser::ParsePpsIdFromSliceSegmentLayerRbsp( &amp;payload_data[start_offset], end_offset - start_offset, nalu.type); if (pps_id) { nalu.pps_id = *pps_id; } else { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Failed to parse PPS id from slice of type: &quot; &lt;&lt; static_cast&lt;int&gt;(nalu.type); } break; } // Slices below don't contain SPS or PPS ids. case H265::NaluType::kAud: case H265::NaluType::kTsaN: case H265::NaluType::kTsaR: case H265::NaluType::kStsaN: case H265::NaluType::kStsaR: case H265::NaluType::kRadlN: case H265::NaluType::kRadlR: case H265::NaluType::kBlaWLp: case H265::NaluType::kBlaWRadl: case H265::NaluType::kPrefixSei: case H265::NaluType::kSuffixSei: break; case H265::NaluType::kAP: case H265::NaluType::kFU: RTC_LOG(LS_WARNING) &lt;&lt; &quot;Unexpected AP or FU received.&quot;; return false; } if (h265_header.nalus_length == kMaxNalusPerPacket) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Received packet containing more than &quot; &lt;&lt; kMaxNalusPerPacket &lt;&lt; &quot; NAL units. Will not keep track sps and pps ids for all of them.&quot;; } else { h265_header.nalus[h265_header.nalus_length++] = nalu; } } return true;}bool VideoRtpDepacketizerH265::ParseFuNalu( ParsedPayload* parsed_payload, const uint8_t* payload_data) { if (length_ &lt; kHevcFuHeaderSize + kHevcNalHeaderSize) { RTC_LOG(LS_ERROR) &lt;&lt; &quot;FU NAL units truncated.&quot;; return false; } uint8_t f = payload_data[0] &amp; kHevcFBit; uint8_t layer_id_h = payload_data[0] &amp; kHevcLayerIDHMask; uint8_t layer_id_l_unshifted = payload_data[1] &amp; kHevcLayerIDLMask; uint8_t tid = payload_data[1] &amp; kHevcTIDMask; uint8_t original_nal_type = payload_data[2] &amp; kHevcTypeMaskInFuHeader; bool first_fragment = payload_data[2] &amp; kHevcSBit; H265NaluInfo nalu; nalu.type = original_nal_type; nalu.vps_id = -1; nalu.sps_id = -1; nalu.pps_id = -1; if (first_fragment) { offset_ = 1; length_ -= 1; absl::optional&lt;uint32_t&gt; pps_id = H265PpsParser::ParsePpsIdFromSliceSegmentLayerRbsp( payload_data + kHevcNalHeaderSize + kHevcFuHeaderSize, length_ - kHevcFuHeaderSize, nalu.type); if (pps_id) { nalu.pps_id = *pps_id; } else { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Failed to parse PPS from first fragment of FU NAL &quot; &quot;unit with original type: &quot; &lt;&lt; static_cast&lt;int&gt;(nalu.type); } uint8_t* payload = const_cast&lt;uint8_t*&gt;(payload_data + offset_); payload[0] = f | original_nal_type &lt;&lt; 1 | layer_id_h; payload[1] = layer_id_l_unshifted | tid; } else { offset_ = kHevcNalHeaderSize + kHevcFuHeaderSize; length_ -= (kHevcNalHeaderSize + kHevcFuHeaderSize); } if (original_nal_type == H265::NaluType::kIdrWRadl || original_nal_type == H265::NaluType::kIdrNLp || original_nal_type == H265::NaluType::kCra) { parsed_payload-&gt;video_header().frame_type = VideoFrameType::kVideoFrameKey; } else { parsed_payload-&gt;video_header().frame_type = VideoFrameType::kVideoFrameDelta; } parsed_payload-&gt;video_header().width = 0; parsed_payload-&gt;video_header().height = 0; parsed_payload-&gt;video_header().codec = kVideoCodecH265; parsed_payload-&gt;video_header().is_first_packet_in_frame = first_fragment; auto&amp; h265_header = absl::get&lt;RTPVideoHeaderH265&gt;( parsed_payload-&gt;video_header().video_type_header); h265_header.packetization_type = kH265FU; h265_header.nalu_type = original_nal_type; if (first_fragment) { h265_header.nalus[h265_header.nalus_length] = nalu; h265_header.nalus_length = 1; } return true;}absl::optional&lt;VideoRtpDepacketizer::ParsedRtpPayload&gt;VideoRtpDepacketizerH265::Parse(rtc::CopyOnWriteBuffer rtp_payload) { // borrowed from https://webrtc.googlesource.com/src/+/ // 07b17df771af20a6dd98b795592acc62a623c56f // /modules/rtp_rtcp/source/create_video_rtp_depacketizer.cc ParsedPayload parsed_payload; if (!Parse(&amp;parsed_payload, rtp_payload.cdata(), rtp_payload.size())) { return absl::nullopt; } absl::optional&lt;ParsedRtpPayload&gt; result(absl::in_place); result-&gt;video_header = parsed_payload.video; result-&gt;video_payload.SetData(parsed_payload.payload, parsed_payload.payload_length); return result;}} // namespace webrtc å°†æ–°å¢ž4ä¸ªæ–‡ä»¶æ·»åŠ åˆ°ninjaä¸­å‚ä¸Žæž„å»ºï¼Œå¹¶é€šè¿‡rtc_use_h265æ‰“å¼€H265å¼€å…³ï¼š modules/rtp_rtcp/BUILD.gnif (rtc_enable_bwe_test_logging) { defines = [ &quot;BWE_TEST_LOGGING_COMPILE_TIME_ENABLE=1&quot; ] } else { defines = [ &quot;BWE_TEST_LOGGING_COMPILE_TIME_ENABLE=0&quot; ] }if (rtc_use_h265) { sources += [ &quot;source/rtp_format_h265.cc&quot;, &quot;source/rtp_format_h265.h&quot;, &quot;source/video_rtp_depacketizer_h265.cc&quot;, &quot;source/video_rtp_depacketizer_h265.h&quot;, ] } if (!rtc_use_h265) { defines += [&quot;DISABLE_H265&quot;] } è§£åŒ…æ”¯æŒ å¢žåŠ H265è§£åŒ…æ”¯æŒ modules/video_coding/include/video_codec_interface.h#include &quot;modules/video_coding/codecs/h264/include/h264_globals.h&quot; #ifndef DISABLE_H265 #include &quot;modules/video_coding/codecs/h265/include/h265_globals.h&quot; #endif... #ifndef DISABLE_H265 struct CodecSpecificInfoH265 { H265PacketizationMode packetization_mode; bool idr_frame; }; #endifunion CodecSpecificInfoUnion { CodecSpecificInfoVP8 VP8; CodecSpecificInfoVP9 VP9; CodecSpecificInfoH264 H264; #ifndef DISABLE_H265 CodecSpecificInfoH265 H265; #endif};static_assert(std::is_pod&lt;CodecSpecificInfoUnion&gt;::value, &quot;&quot;); è®¾ç½®codecç±»åž‹ modules/video_coding/encoded_frame.ccvoid VCMEncodedFrame::CopyCodecSpecific(const RTPVideoHeader* header) {... #ifndef DISABLE_H265 case kVideoCodecH265: { _codecSpecificInfo.codecType = kVideoCodecH265; break; } #endif default: { _codecSpecificInfo.codecType = kVideoCodecGeneric; break; }} æ–°å¢žtracker è§£æžvps/sps/ppsä¿¡æ¯ï¼Œå‚è€ƒh264_sps_pps_tracker modules/video_coding/h265_vps_sps_pps_tracker.cc >folded#include &quot;modules/video_coding/h265_vps_sps_pps_tracker.h&quot;#include &lt;string&gt;#include &lt;utility&gt;#include &quot;common_video/h264/h264_common.h&quot;#include &quot;common_video/h265/h265_common.h&quot;#include &quot;common_video/h265/h265_pps_parser.h&quot;#include &quot;common_video/h265/h265_sps_parser.h&quot;#include &quot;common_video/h265/h265_vps_parser.h&quot;#include &quot;modules/video_coding/codecs/h264/include/h264_globals.h&quot;#include &quot;modules/video_coding/codecs/h265/include/h265_globals.h&quot;#include &quot;modules/video_coding/frame_object.h&quot;#include &quot;modules/video_coding/packet_buffer.h&quot;#include &quot;rtc_base/checks.h&quot;#include &quot;rtc_base/logging.h&quot;namespace webrtc {namespace video_coding {namespace {const uint8_t start_code_h265[] = {0, 0, 0, 1};} // namespaceH265VpsSpsPpsTracker::FixedBitstream H265VpsSpsPpsTracker::CopyAndFixBitstream( rtc::ArrayView&lt;const uint8_t&gt; bitstream, RTPVideoHeader* video_header) { RTC_DCHECK(video_header); RTC_DCHECK(video_header-&gt;codec == kVideoCodecH265); auto&amp; h265_header = absl::get&lt;RTPVideoHeaderH265&gt;(video_header-&gt;video_type_header); bool append_vps_sps_pps = false; auto vps = vps_data_.end(); auto sps = sps_data_.end(); auto pps = pps_data_.end(); for (size_t i = 0; i &lt; h265_header.nalus_length; ++i) { const H265NaluInfo&amp; nalu = h265_header.nalus[i]; switch (nalu.type) { case H265::NaluType::kVps: { vps_data_[nalu.vps_id].size = 0; break; } case H265::NaluType::kSps: { sps_data_[nalu.sps_id].vps_id = nalu.vps_id; sps_data_[nalu.sps_id].width = video_header-&gt;width; sps_data_[nalu.sps_id].height = video_header-&gt;height; break; } case H265::NaluType::kPps: { pps_data_[nalu.pps_id].sps_id = nalu.sps_id; break; } case H265::NaluType::kIdrWRadl: case H265::NaluType::kIdrNLp: case H265::NaluType::kCra: { // If this is the first packet of an IDR, make sure we have the required // SPS/PPS and also calculate how much extra space we need in the buffer // to prepend the SPS/PPS to the bitstream with start codes. if (video_header-&gt;is_first_packet_in_frame) { if (nalu.pps_id == -1) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;No PPS id in IDR nalu.&quot;; return {kRequestKeyframe}; } pps = pps_data_.find(nalu.pps_id); if (pps == pps_data_.end()) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;No PPS with id &lt;&lt; &quot; &lt;&lt; nalu.pps_id &lt;&lt; &quot; received&quot;; return {kRequestKeyframe}; } sps = sps_data_.find(pps-&gt;second.sps_id); if (sps == sps_data_.end()) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;No SPS with id &lt;&lt; &quot; &lt;&lt; pps-&gt;second.sps_id &lt;&lt; &quot; received&quot;; return {kRequestKeyframe}; } vps = vps_data_.find(sps-&gt;second.vps_id); if (vps == vps_data_.end()) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;No VPS with id &lt;&lt; &quot; &lt;&lt; sps-&gt;second.vps_id &lt;&lt; &quot; received&quot;; return {kRequestKeyframe}; } // Since the first packet of every keyframe should have its width and // height set we set it here in the case of it being supplied out of // band. video_header-&gt;width = sps-&gt;second.width; video_header-&gt;height = sps-&gt;second.height; // If the VPS/SPS/PPS was supplied out of band then we will have saved // the actual bitstream in |data|. // This branch is not verified. if (vps-&gt;second.data &amp;&amp; sps-&gt;second.data &amp;&amp; pps-&gt;second.data) { RTC_DCHECK_GT(vps-&gt;second.size, 0); RTC_DCHECK_GT(sps-&gt;second.size, 0); RTC_DCHECK_GT(pps-&gt;second.size, 0); append_vps_sps_pps = true; } } break; } default: break; } } RTC_CHECK(!append_vps_sps_pps || (sps != sps_data_.end() &amp;&amp; pps != pps_data_.end())); // Calculate how much space we need for the rest of the bitstream. size_t required_size = 0; if (append_vps_sps_pps) { required_size += vps-&gt;second.size + sizeof(start_code_h265); required_size += sps-&gt;second.size + sizeof(start_code_h265); required_size += pps-&gt;second.size + sizeof(start_code_h265); } if (h265_header.packetization_type == kH265AP) { const uint8_t* nalu_ptr = bitstream.data() + 1; while (nalu_ptr &lt; bitstream.data() + bitstream.size()) { RTC_DCHECK(video_header-&gt;is_first_packet_in_frame); required_size += sizeof(start_code_h265); // The first two bytes describe the length of a segment. uint16_t segment_length = nalu_ptr[0] &lt;&lt; 8 | nalu_ptr[1]; nalu_ptr += 2; required_size += segment_length; nalu_ptr += segment_length; } } else { if (video_header-&gt;is_first_packet_in_frame) required_size += sizeof(start_code_h265); required_size += bitstream.size(); } // Then we copy to the new buffer. H265VpsSpsPpsTracker::FixedBitstream fixed; fixed.bitstream.EnsureCapacity(required_size); if (append_vps_sps_pps) { // Insert VPS. fixed.bitstream.AppendData(start_code_h265); fixed.bitstream.AppendData(vps-&gt;second.data.get(), vps-&gt;second.size); // Insert SPS. fixed.bitstream.AppendData(start_code_h265); fixed.bitstream.AppendData(sps-&gt;second.data.get(), sps-&gt;second.size); // Insert PPS. fixed.bitstream.AppendData(start_code_h265); fixed.bitstream.AppendData(pps-&gt;second.data.get(), pps-&gt;second.size); // Update codec header to reflect the newly added SPS and PPS. H265NaluInfo vps_info; vps_info.type = H265::NaluType::kVps; vps_info.vps_id = vps-&gt;first; vps_info.sps_id = -1; vps_info.pps_id = -1; H265NaluInfo sps_info; sps_info.type = H265::NaluType::kSps; sps_info.vps_id = vps-&gt;first; sps_info.sps_id = sps-&gt;first; sps_info.pps_id = -1; H265NaluInfo pps_info; pps_info.type = H265::NaluType::kPps; pps_info.vps_id = vps-&gt;first; pps_info.sps_id = sps-&gt;first; pps_info.pps_id = pps-&gt;first; if (h265_header.nalus_length + 3 &lt;= kMaxNalusPerPacket) { h265_header.nalus[h265_header.nalus_length++] = vps_info; h265_header.nalus[h265_header.nalus_length++] = sps_info; h265_header.nalus[h265_header.nalus_length++] = pps_info; } else { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Not enough space in H.265 codec header to insert &quot; &quot;SPS/PPS provided out-of-band.&quot;; } } // Copy the rest of the bitstream and insert start codes. if (h265_header.packetization_type == kH265AP) { const uint8_t* nalu_ptr = bitstream.data() + 1; while (nalu_ptr &lt; bitstream.data() + bitstream.size()) { fixed.bitstream.AppendData(start_code_h265); // The first two bytes describe the length of a segment. uint16_t segment_length = nalu_ptr[0] &lt;&lt; 8 | nalu_ptr[1]; nalu_ptr += 2; size_t copy_end = nalu_ptr - bitstream.data() + segment_length; if (copy_end &gt; bitstream.size()) { return {kDrop}; } fixed.bitstream.AppendData(nalu_ptr, segment_length); nalu_ptr += segment_length; } } else { if (video_header-&gt;is_first_packet_in_frame) { fixed.bitstream.AppendData(start_code_h265); } fixed.bitstream.AppendData(bitstream.data(), bitstream.size()); } fixed.action = kInsert; return fixed;}void H265VpsSpsPpsTracker::InsertVpsSpsPpsNalus( const std::vector&lt;uint8_t&gt;&amp; vps, const std::vector&lt;uint8_t&gt;&amp; sps, const std::vector&lt;uint8_t&gt;&amp; pps) { constexpr size_t kNaluHeaderOffset = 1; if (vps.size() &lt; kNaluHeaderOffset) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;VPS size &quot; &lt;&lt; vps.size() &lt;&lt; &quot; is smaller than &quot; &lt;&lt; kNaluHeaderOffset; return; } if ((vps[0] &amp; 0x7e) &gt;&gt; 1 != H265::NaluType::kSps) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;SPS Nalu header missing&quot;; return; } if (sps.size() &lt; kNaluHeaderOffset) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;SPS size &quot; &lt;&lt; sps.size() &lt;&lt; &quot; is smaller than &quot; &lt;&lt; kNaluHeaderOffset; return; } if ((sps[0] &amp; 0x7e) &gt;&gt; 1 != H265::NaluType::kSps) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;SPS Nalu header missing&quot;; return; } if (pps.size() &lt; kNaluHeaderOffset) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;PPS size &quot; &lt;&lt; pps.size() &lt;&lt; &quot; is smaller than &quot; &lt;&lt; kNaluHeaderOffset; return; } if ((pps[0] &amp; 0x7e) &gt;&gt; 1 != H265::NaluType::kPps) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;SPS Nalu header missing&quot;; return; } absl::optional&lt;H265VpsParser::VpsState&gt; parsed_vps = H265VpsParser::ParseVps( vps.data() + kNaluHeaderOffset, vps.size() - kNaluHeaderOffset); absl::optional&lt;H265SpsParser::SpsState&gt; parsed_sps = H265SpsParser::ParseSps( sps.data() + kNaluHeaderOffset, sps.size() - kNaluHeaderOffset); absl::optional&lt;H265PpsParser::PpsState&gt; parsed_pps = H265PpsParser::ParsePps( pps.data() + kNaluHeaderOffset, pps.size() - kNaluHeaderOffset); if (!parsed_vps) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Failed to parse VPS.&quot;; } if (!parsed_sps) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Failed to parse SPS.&quot;; } if (!parsed_pps) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Failed to parse PPS.&quot;; } if (!parsed_vps || !parsed_pps || !parsed_sps) { return; } VpsInfo vps_info; vps_info.size = vps.size(); uint8_t* vps_data = new uint8_t[vps_info.size]; memcpy(vps_data, vps.data(), vps_info.size); vps_info.data.reset(vps_data); vps_data_[parsed_vps-&gt;id] = std::move(vps_info); SpsInfo sps_info; sps_info.size = sps.size(); sps_info.width = parsed_sps-&gt;width; sps_info.height = parsed_sps-&gt;height; sps_info.vps_id = parsed_sps-&gt;vps_id; uint8_t* sps_data = new uint8_t[sps_info.size]; memcpy(sps_data, sps.data(), sps_info.size); sps_info.data.reset(sps_data); sps_data_[parsed_sps-&gt;id] = std::move(sps_info); PpsInfo pps_info; pps_info.size = pps.size(); pps_info.sps_id = parsed_pps-&gt;sps_id; uint8_t* pps_data = new uint8_t[pps_info.size]; memcpy(pps_data, pps.data(), pps_info.size); pps_info.data.reset(pps_data); pps_data_[parsed_pps-&gt;id] = std::move(pps_info); RTC_LOG(LS_INFO) &lt;&lt; &quot;Inserted SPS id &quot; &lt;&lt; parsed_sps-&gt;id &lt;&lt; &quot; and PPS id &quot; &lt;&lt; parsed_pps-&gt;id &lt;&lt; &quot; (referencing SPS &quot; &lt;&lt; parsed_pps-&gt;sps_id &lt;&lt; &quot;)&quot;;}} // namespace video_coding} // namespace webrtc modules/video_coding/h265_vps_sps_pps_tracker.h >folded#ifndef MODULES_VIDEO_CODING_H265_VPS_SPS_PPS_TRACKER_H_#define MODULES_VIDEO_CODING_H265_VPS_SPS_PPS_TRACKER_H_#include &lt;cstdint&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &quot;api/array_view.h&quot;#include &quot;modules/rtp_rtcp/source/rtp_video_header.h&quot;#include &quot;rtc_base/copy_on_write_buffer.h&quot;namespace webrtc {namespace video_coding {class H265VpsSpsPpsTracker { public: enum PacketAction { kInsert, kDrop, kRequestKeyframe }; struct FixedBitstream { PacketAction action; rtc::CopyOnWriteBuffer bitstream; }; // Returns fixed bitstream and modifies |video_header|. FixedBitstream CopyAndFixBitstream(rtc::ArrayView&lt;const uint8_t&gt; bitstream, RTPVideoHeader* video_header); void InsertVpsSpsPpsNalus(const std::vector&lt;uint8_t&gt;&amp; vps, const std::vector&lt;uint8_t&gt;&amp; sps, const std::vector&lt;uint8_t&gt;&amp; pps); private: struct VpsInfo { size_t size = 0; std::unique_ptr&lt;uint8_t[]&gt; data; }; struct PpsInfo { int sps_id = -1; size_t size = 0; std::unique_ptr&lt;uint8_t[]&gt; data; }; struct SpsInfo { int vps_id = -1; size_t size = 0; int width = -1; int height = -1; std::unique_ptr&lt;uint8_t[]&gt; data; }; std::map&lt;uint32_t, VpsInfo&gt; vps_data_; std::map&lt;uint32_t, PpsInfo&gt; pps_data_; std::map&lt;uint32_t, SpsInfo&gt; sps_data_;};} // namespace video_coding} // namespace webrtc#endif // MODULES_VIDEO_CODING_H264_SPS_PPS_TRACKER_H_ åœ¨ç½‘ç»œæŠ–åŠ¨ç¼“å­˜ä¿¡æ¯ä¸­æ–°å¢žæžšä¸¾ï¼š modules/video_coding/jitter_buffer_common.henum { kH264StartCodeLengthBytes = 4 }; #ifndef DISABLE_H265 enum { kH265StartCodeLengthBytes = 4 }; #endif PacketBufferRTPåŒ…ç¼“å†²åŒºå¢žåŠ H265æ”¯æŒï¼š modules/video_coding/packet_buffer.cc#include &quot;common_video/h264/h264_common.h&quot;#ifndef DISABLE_H265#include &quot;common_video/h265/h265_common.h&quot;#endif#include &quot;modules/rtp_rtcp/source/rtp_header_extensions.h&quot;#include &quot;modules/rtp_rtcp/source/rtp_packet_received.h&quot;#include &quot;modules/rtp_rtcp/source/rtp_video_header.h&quot;#include &quot;modules/video_coding/codecs/h264/include/h264_globals.h&quot;#ifndef DISABLE_H265#include &quot;modules/video_coding/codecs/h265/include/h265_globals.h&quot;#endif#include &quot;rtc_base/checks.h&quot;...std::vector&lt;std::unique_ptr&lt;PacketBuffer::Packet&gt;&gt; PacketBuffer::FindFrames( uint16_t seq_num) { std::vector&lt;std::unique_ptr&lt;PacketBuffer::Packet&gt;&gt; found_frames; for (size_t i = 0; i &lt; buffer_.size() &amp;&amp; PotentialNewFrame(seq_num); ++i) {... bool is_h264_keyframe = false; bool is_h265 = false;#ifndef DISABLE_H265 is_h265 = buffer_[start_index]-&gt;codec() == kVideoCodecH265; bool has_h265_sps = false; bool has_h265_pps = false; bool has_h265_idr = false; bool is_h265_keyframe = false;#endif int idr_width = -1; int idr_height = -1; while (true) { ++tested_packets; if (!is_h264 &amp;&amp; !is_h265 &amp;&amp; buffer_[start_index]-&gt;is_first_packet_in_frame()) break; if (is_h264) { ... }#ifndef DISABLE_H265 if (is_h265 &amp;&amp; !is_h265_keyframe) { const auto* h265_header = absl::get_if&lt;RTPVideoHeaderH265&gt;( &amp;buffer_[start_index]-&gt;video_header.video_type_header); if (!h265_header || h265_header-&gt;nalus_length &gt;= kMaxNalusPerPacket) return found_frames; for (size_t j = 0; j &lt; h265_header-&gt;nalus_length; ++j) { if (h265_header-&gt;nalus[j].type == H265::NaluType::kSps) { has_h265_sps = true; } else if (h265_header-&gt;nalus[j].type == H265::NaluType::kPps) { has_h265_pps = true; } else if (h265_header-&gt;nalus[j].type == H265::NaluType::kIdrWRadl || h265_header-&gt;nalus[j].type == H265::NaluType::kIdrNLp || h265_header-&gt;nalus[j].type == H265::NaluType::kCra) { has_h265_idr = true; } } if ((has_h265_sps &amp;&amp; has_h265_pps) || has_h265_idr) { is_h265_keyframe = true; // Store the resolution of key frame which is the packet with // smallest index and valid resolution; typically its IDR or SPS // packet; there may be packet preceeding this packet, IDR's // resolution will be applied to them. if (buffer_[start_index]-&gt;width() &gt; 0 &amp;&amp; buffer_[start_index]-&gt;height() &gt; 0) { idr_width = buffer_[start_index]-&gt;width(); idr_height = buffer_[start_index]-&gt;height(); } } }#endif... if (is_h264) { ... }#ifndef DISABLE_H265 if (is_h265) { // Warn if this is an unsafe frame. if (has_h265_idr &amp;&amp; (!has_h265_sps || !has_h265_pps)) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Received H.265-IDR frame &quot; &lt;&lt; &quot;(SPS: &quot; &lt;&lt; has_h265_sps &lt;&lt; &quot;, PPS: &quot; &lt;&lt; has_h265_pps &lt;&lt; &quot;). Treating as delta frame since &quot; &lt;&lt; &quot;WebRTC-SpsPpsIdrIsH265Keyframe is always enabled.&quot;; } // Now that we have decided whether to treat this frame as a key frame // or delta frame in the frame buffer, we update the field that // determines if the RtpFrameObject is a key frame or delta frame. const size_t first_packet_index = start_seq_num % buffer_.size(); if (is_h265_keyframe) { buffer_[first_packet_index]-&gt;video_header.frame_type = VideoFrameType::kVideoFrameKey; if (idr_width &gt; 0 &amp;&amp; idr_height &gt; 0) { // IDR frame was finalized and we have the correct resolution for // IDR; update first packet to have same resolution as IDR. buffer_[first_packet_index]-&gt;video_header.width = idr_width; buffer_[first_packet_index]-&gt;video_header.height = idr_height; } } else { buffer_[first_packet_index]-&gt;video_header.frame_type = VideoFrameType::kVideoFrameDelta; } // If this is not a key frame, make sure there are no gaps in the // packet sequence numbers up until this point. if (!is_h265_keyframe &amp;&amp; missing_packets_.upper_bound(start_seq_num) != missing_packets_.begin()) { return found_frames; } }#endif... } return found_frames;} packet insetStartCodeå¢žåŠ H265æ”¯æŒï¼š modules/video_coding/packet.cc completeNALU(kNaluIncomplete),#ifndef DISABLE_H265 insertStartCode((videoHeader.codec == kVideoCodecH264 || videoHeader.codec == kVideoCodecH265) &amp;&amp; videoHeader.is_first_packet_in_frame),#else insertStartCode(videoHeader.codec == kVideoCodecH264 &amp;&amp; videoHeader.is_first_packet_in_frame),#endif video_header(videoHeader), æ”¯æŒH265åŒ…æ‹¼æŽ¥,æ–°å¢žå‡½æ•°GetH265NaluInfosï¼š modules/video_coding/session_info.cc+ #ifndef DISABLE_H265+ std::vector&lt;H265NaluInfo&gt; VCMSessionInfo::GetH265NaluInfos() const {+ if (packets_.empty() || packets_.front().video_header.codec != kVideoCodecH265)+ return std::vector&lt;H265NaluInfo&gt;();+ std::vector&lt;H265NaluInfo&gt; nalu_infos;+ for (const VCMPacket&amp; packet : packets_) {+ const auto&amp; h265 =+ absl::get&lt;RTPVideoHeaderH265&gt;(packet.video_header.video_type_header);+ for (size_t i = 0; i &lt; h265.nalus_length; ++i) {+ nalu_infos.push_back(h265.nalus[i]);+ }+ }+ return nalu_infos;+ }+ #endif...size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer, PacketIterator packet_it) { ... const size_t kH264NALHeaderLengthInBytes = 1;+ #ifndef DISABLE_H265+ const size_t kH265NALHeaderLengthInBytes = 2;+ const auto* h265 =+ absl::get_if&lt;RTPVideoHeaderH265&gt;(&amp;packet.video_header.video_type_header);+ #endif ... return packet.sizeBytes;+ #ifndef DISABLE_H265+ } else if (h265 &amp;&amp; h265-&gt;packetization_type == kH265AP) {+ // Similar to H264, for H265 aggregation packets, we rely on jitter buffer+ // to remove the two length bytes between each NAL unit, and potentially add+ // start codes.+ size_t required_length = 0;+ const uint8_t* nalu_ptr =+ packet_buffer + kH265NALHeaderLengthInBytes; // skip payloadhdr+ while (nalu_ptr &lt; packet_buffer + packet.sizeBytes) {+ size_t length = BufferToUWord16(nalu_ptr);+ required_length +=+ length + (packet.insertStartCode ? kH265StartCodeLengthBytes : 0);+ nalu_ptr += kLengthFieldLength + length;+ }+ ShiftSubsequentPackets(packet_it, required_length);+ nalu_ptr = packet_buffer + kH265NALHeaderLengthInBytes;+ uint8_t* frame_buffer_ptr = frame_buffer + offset;+ while (nalu_ptr &lt; packet_buffer + packet.sizeBytes) {+ size_t length = BufferToUWord16(nalu_ptr);+ nalu_ptr += kLengthFieldLength;+ // since H265 shares the same start code as H264, use the same Insert+ // function to handle start code.+ frame_buffer_ptr += Insert(nalu_ptr, length, packet.insertStartCode,+ const_cast&lt;uint8_t*&gt;(frame_buffer_ptr));+ nalu_ptr += length;+ }+ packet.sizeBytes = required_length;+ return packet.sizeBytes;+ #endif } ShiftSubsequentPackets( packet_it, packet.sizeBytes + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0)); packet.sizeBytes = Insert(packet_buffer, packet.sizeBytes, packet.insertStartCode, const_cast&lt;uint8_t*&gt;(packet.dataPtr)); return packet.sizeBytes;}...int VCMSessionInfo::InsertPacket(const VCMPacket&amp; packet, uint8_t* frame_buffer, const FrameData&amp; frame_data) {...+ #ifndef DISABLE_H265+ } else if (packet.codec() == kVideoCodecH265) {+ frame_type_ = packet.video_header.frame_type;+ if (packet.is_first_packet_in_frame() &amp;&amp;+ (first_packet_seq_num_ == -1 ||+ IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum))) {+ first_packet_seq_num_ = packet.seqNum;+ }+ if (packet.markerBit &amp;&amp;+ (last_packet_seq_num_ == -1 ||+ IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_))) {+ last_packet_seq_num_ = packet.seqNum;+ }+ #endif... return static_cast&lt;int&gt;(returnLength);} modules/video_coding/session_info.h std::vector&lt;NaluInfo&gt; GetNaluInfos() const;#ifndef DISABLE_H265 std::vector&lt;H265NaluInfo&gt; GetH265NaluInfos() const;#endif å°†æ–°å¢ž2ä¸ªæ–‡ä»¶æ·»åŠ åˆ°ninjaä¸­å‚ä¸Žæž„å»ºï¼š if (rtc_use_h265) { sources += [ &quot;h265_vps_sps_pps_tracker.cc&quot;, &quot;h265_vps_sps_pps_tracker.h&quot;, ] } RTPç›¸å…³æ”¯æŒ é…ç½®æœ€å°ç çŽ‡æžšä¸¾ï¼Œé¿å…ç¼–è¯‘ä¸é€šè¿‡ï¼š absl::optional&lt;DataRate&gt; GetExperimentalMinVideoBitrate(VideoCodecType type) { ...#ifndef DISABLE_H265 case kVideoCodecH265:#endif case kVideoCodecGeneric: ...} ä½¿rtpè½½è·å¢žåŠ H265æ”¯æŒï¼š video/rtp_video_stream_receiver.ccvoid RtpVideoStreamReceiver::OnReceivedPayloadData( rtc::CopyOnWriteBuffer codec_payload, const RtpPacketReceived&amp; rtp_packet, const RTPVideoHeader&amp; video) {...#ifndef DISABLE_H265 } else if (packet-&gt;codec() == kVideoCodecH265) { // Only when we start to receive packets will we know what payload type // that will be used. When we know the payload type insert the correct // sps/pps into the tracker. if (packet-&gt;payload_type != last_payload_type_) { last_payload_type_ = packet-&gt;payload_type; InsertSpsPpsIntoTracker(packet-&gt;payload_type); } video_coding::H265VpsSpsPpsTracker::FixedBitstream fixed = h265_tracker_.CopyAndFixBitstream( rtc::MakeArrayView(codec_payload.cdata(), codec_payload.size()), &amp;packet-&gt;video_header); switch (fixed.action) { case video_coding::H265VpsSpsPpsTracker::kRequestKeyframe: rtcp_feedback_buffer_.RequestKeyFrame(); rtcp_feedback_buffer_.SendBufferedRtcpFeedback(); ABSL_FALLTHROUGH_INTENDED; case video_coding::H265VpsSpsPpsTracker::kDrop: return; case video_coding::H265VpsSpsPpsTracker::kInsert: packet-&gt;video_payload = std::move(fixed.bitstream); break; }#endif } else { packet-&gt;video_payload = std::move(codec_payload); } } video/rtp_video_stream_receiver.h#ifndef DISABLE_H265#include &quot;modules/video_coding/h265_vps_sps_pps_tracker.h&quot;#endif... std::map&lt;uint8_t, std::unique_ptr&lt;VideoRtpDepacketizer&gt;&gt; payload_type_map_;#ifndef DISABLE_H265 video_coding::H265VpsSpsPpsTracker h265_tracker_;#endif video/rtp_video_stream_receiver2.ccvoid RtpVideoStreamReceiver2::OnReceivedPayloadData( rtc::CopyOnWriteBuffer codec_payload, const RtpPacketReceived&amp; rtp_packet, const RTPVideoHeader&amp; video) {...#ifndef DISABLE_H265 } else if (packet-&gt;codec() == kVideoCodecH265) { // Only when we start to receive packets will we know what payload type // that will be used. When we know the payload type insert the correct // sps/pps into the tracker. if (packet-&gt;payload_type != last_payload_type_) { last_payload_type_ = packet-&gt;payload_type; InsertSpsPpsIntoTracker(packet-&gt;payload_type); } video_coding::H265VpsSpsPpsTracker::FixedBitstream fixed = h265_tracker_.CopyAndFixBitstream( rtc::MakeArrayView(codec_payload.cdata(), codec_payload.size()), &amp;packet-&gt;video_header); switch (fixed.action) { case video_coding::H265VpsSpsPpsTracker::kRequestKeyframe: rtcp_feedback_buffer_.RequestKeyFrame(); rtcp_feedback_buffer_.SendBufferedRtcpFeedback(); ABSL_FALLTHROUGH_INTENDED; case video_coding::H265VpsSpsPpsTracker::kDrop: return; case video_coding::H265VpsSpsPpsTracker::kInsert: packet-&gt;video_payload = std::move(fixed.bitstream); break; }#endif } else { packet-&gt;video_payload = std::move(codec_payload); } video/rtp_video_stream_receiver2.h#ifndef DISABLE_H265#include &quot;modules/video_coding/h265_vps_sps_pps_tracker.h&quot;#endif... std::map&lt;uint8_t, std::unique_ptr&lt;VideoRtpDepacketizer&gt;&gt; payload_type_map_ RTC_GUARDED_BY(worker_task_checker_);#ifndef DISABLE_H265 video_coding::H265VpsSpsPpsTracker h265_tracker_;#endif ç»Ÿè®¡æ”¯æŒï¼š video/send_statistics_proxy.ccenum HistogramCodecType { kVideoUnknown = 0, kVideoVp8 = 1, kVideoVp9 = 2, kVideoH264 = 3,#ifndef DISABLE_H265 kVideoH265 = 4,#endif kVideoMax = 64,};HistogramCodecType PayloadNameToHistogramCodecType( const std::string&amp; payload_name) { VideoCodecType codecType = PayloadStringToCodecType(payload_name); switch (codecType) { case kVideoCodecVP8: return kVideoVp8; case kVideoCodecVP9: return kVideoVp9; case kVideoCodecH264: return kVideoH264;#ifndef DISABLE_H265 case kVideoCodecH265: return kVideoH265;#endif default: return kVideoUnknown; }} æŽ¥æ”¶æµè§£ç å™¨åˆå§‹åŒ–æ”¯æŒï¼š video/video_receive_stream.ccVideoCodec CreateDecoderVideoCodec(const VideoReceiveStream::Decoder&amp; decoder) { VideoCodec codec; memset(&amp;codec, 0, sizeof(codec)); codec.codecType = PayloadStringToCodecType(decoder.video_format.name);... return associated_codec;#ifndef DISABLE_H265 } else if (codec.codecType == kVideoCodecH265) { *(codec.H265()) = VideoEncoder::GetDefaultH265Settings();#endif }... return codec;} æŽ¥æ”¶æµç¼–ç å™¨æ”¯æŒï¼š video/video_stream_encoder.ccbool RequiresEncoderReset(const VideoCodec&amp; prev_send_codec, const VideoCodec&amp; new_send_codec, bool was_encode_called_since_last_initialization) {... case kVideoCodecH264: if (new_send_codec.H264() != prev_send_codec.H264()) { return true; } break;#ifndef DISABLE_H265 case kVideoCodecH265: if (new_send_codec.H265() != prev_send_codec.H265()) { return true; } break;#endif} ç¼–è§£ç å™¨æ”¯æŒ è§†é¢‘æ•°æ®ä¸­å¢žåŠ H265ç±»åž‹ï¼š api/video/encoded_image.h#include &quot;api/video/video_codec_type.h&quot; api/video/video_codec_type.h#ifndef DISABLE_H265enum VideoCodecType { // Java_cpp_enum.py does not allow ifdef in enum class, // so we have to create two version of VideoCodecType here kVideoCodecGeneric = 0, kVideoCodecVP8, kVideoCodecVP9, kVideoCodecAV1, kVideoCodecH264, kVideoCodecH265, kVideoCodecMultiplex,};#elseenum VideoCodecType { // There are various memset(..., 0, ...) calls in the code that rely on // kVideoCodecGeneric being zero. kVideoCodecGeneric = 0, kVideoCodecVP8, kVideoCodecVP9, kVideoCodecAV1, kVideoCodecH264, kVideoCodecMultiplex,};#endif codecåŸºæœ¬ä¿¡æ¯æ”¯æŒï¼š api/video_codecs/video_codec.ccconstexpr char kPayloadNameH264[] = &quot;H264&quot;;#ifndef DISABLE_H265constexpr char kPayloadNameH265[] = &quot;H265&quot;;#endif...#ifndef DISABLE_H265bool VideoCodecH265::operator==(const VideoCodecH265&amp; other) const { return (frameDroppingOn == other.frameDroppingOn &amp;&amp; keyFrameInterval == other.keyFrameInterval &amp;&amp; vpsLen == other.vpsLen &amp;&amp; spsLen == other.spsLen &amp;&amp; ppsLen == other.ppsLen &amp;&amp; (spsLen == 0 || memcmp(spsData, other.spsData, spsLen) == 0) &amp;&amp; (ppsLen == 0 || memcmp(ppsData, other.ppsData, ppsLen) == 0));}#endif...const VideoCodecH264&amp; VideoCodec::H264() const { RTC_DCHECK_EQ(codecType, kVideoCodecH264); return codec_specific_.H264;}#ifndef DISABLE_H265VideoCodecH265* VideoCodec::H265() { RTC_DCHECK_EQ(codecType, kVideoCodecH265); return &amp;codec_specific_.H265;}const VideoCodecH265&amp; VideoCodec::H265() const { RTC_DCHECK_EQ(codecType, kVideoCodecH265); return codec_specific_.H265;}#endifconst char* CodecTypeToPayloadString(VideoCodecType type) { ... case kVideoCodecH264: return kPayloadNameH264;#ifndef DISABLE_H265 case kVideoCodecH265: return kPayloadNameH265;#endif case kVideoCodecMultiplex: return kPayloadNameMultiplex; case kVideoCodecGeneric: return kPayloadNameGeneric;}VideoCodecType PayloadStringToCodecType(const std::string&amp; name) { ... if (absl::EqualsIgnoreCase(name, kPayloadNameH264)) return kVideoCodecH264;#ifndef DISABLE_H265 if (absl::EqualsIgnoreCase(name, kPayloadNameH265)) return kVideoCodecH265;#endif if (absl::EqualsIgnoreCase(name, kPayloadNameMultiplex)) return kVideoCodecMultiplex; return kVideoCodecGeneric;} api/video_codecs/video_codec.h#ifndef DISABLE_H265struct VideoCodecH265 { bool operator==(const VideoCodecH265&amp; other) const; bool operator!=(const VideoCodecH265&amp; other) const { return !(*this == other); } bool frameDroppingOn; int keyFrameInterval; const uint8_t* vpsData; size_t vpsLen; const uint8_t* spsData; size_t spsLen; const uint8_t* ppsData; size_t ppsLen;};#endif...union VideoCodecUnion { VideoCodecVP8 VP8; VideoCodecVP9 VP9; VideoCodecH264 H264;#ifndef DISABLE_H265 VideoCodecH265 H265;#endif};...class RTC_EXPORT VideoCodec { public: ...#ifndef DISABLE_H265 VideoCodecH265* H265(); const VideoCodecH265&amp; H265() const;#endif private: // TODO(hta): Consider replacing the union with a pointer type. // This will allow removing the VideoCodec* types from this file. VideoCodecUnion codec_specific_;}; è§£ç å™¨é™çº§æ”¯æŒï¼š api/video_codecs/video_decoder_software_fallback_wrapper.ccvoid VideoDecoderSoftwareFallbackWrapper::UpdateFallbackDecoderHistograms() { switch (codec_settings_.codecType) { ... case kVideoCodecH264: RTC_HISTOGRAM_COUNTS_100000(kFallbackHistogramsUmaPrefix + &quot;H264&quot;, hw_decoded_frames_since_last_fallback_); break;#ifndef DISABLE_H265 case kVideoCodecH265: RTC_HISTOGRAM_COUNTS_100000(kFallbackHistogramsUmaPrefix + &quot;H265&quot;, hw_decoded_frames_since_last_fallback_); break;#endif case kVideoCodecMultiplex: RTC_HISTOGRAM_COUNTS_100000(kFallbackHistogramsUmaPrefix + &quot;Multiplex&quot;, hw_decoded_frames_since_last_fallback_); break; }} ç¼–ç å™¨é…ç½®ï¼š api/video_codecs/video_encoder_config.ccvoid VideoEncoderConfig::EncoderSpecificSettings::FillEncoderSpecificSettings( VideoCodec* codec) const { if (codec-&gt;codecType == kVideoCodecH264) { FillVideoCodecH264(codec-&gt;H264()); } else if (codec-&gt;codecType == kVideoCodecVP8) { FillVideoCodecVp8(codec-&gt;VP8()); } else if (codec-&gt;codecType == kVideoCodecVP9) { FillVideoCodecVp9(codec-&gt;VP9());#ifndef DISABLE_H265 } else if (codec-&gt;codecType == kVideoCodecH265) { FillVideoCodecH265(codec-&gt;H265());#endif } else { RTC_NOTREACHED() &lt;&lt; &quot;Encoder specifics set/used for unknown codec type.&quot;; }}#ifndef DISABLE_H265void VideoEncoderConfig::EncoderSpecificSettings::FillVideoCodecH265( VideoCodecH265* h265_settings) const { RTC_NOTREACHED();}#endif#ifndef DISABLE_H265VideoEncoderConfig::H265EncoderSpecificSettings::H265EncoderSpecificSettings( const VideoCodecH265&amp; specifics) : specifics_(specifics) {}void VideoEncoderConfig::H265EncoderSpecificSettings::FillVideoCodecH265( VideoCodecH265* h265_settings) const { *h265_settings = specifics_;}#endif api/video_codecs/video_encoder_config.h class EncoderSpecificSettings : public rtc::RefCountInterface { public: ... virtual void FillVideoCodecH264(VideoCodecH264* h264_settings) const;#ifndef DISABLE_H265 virtual void FillVideoCodecH265(VideoCodecH265* h265_settings) const;#endif private: ~EncoderSpecificSettings() override {} friend class VideoEncoderConfig; };#ifndef DISABLE_H265 class H265EncoderSpecificSettings : public EncoderSpecificSettings { public: explicit H265EncoderSpecificSettings(const VideoCodecH265&amp; specifics); void FillVideoCodecH265(VideoCodecH265* h265_settings) const override; private: VideoCodecH265 specifics_; };#endif api/video_codecs/video_encoder.cc#ifndef DISABLE_H265VideoCodecH265 VideoEncoder::GetDefaultH265Settings() { VideoCodecH265 h265_settings; memset(&amp;h265_settings, 0, sizeof(h265_settings)); // h265_settings.profile = kProfileBase; h265_settings.frameDroppingOn = true; h265_settings.keyFrameInterval = 3000; h265_settings.spsData = nullptr; h265_settings.spsLen = 0; h265_settings.ppsData = nullptr; h265_settings.ppsLen = 0; return h265_settings;}#endif api/video_codecs/video_encoder.h static VideoCodecH264 GetDefaultH264Settings();#ifndef DISABLE_H265 static VideoCodecH265 GetDefaultH265Settings();#endif è½½è·é…ç½®ï¼š call/rtp_payload_params.ccvoid PopulateRtpWithCodecSpecifics(const CodecSpecificInfo&amp; info, absl::optional&lt;int&gt; spatial_index, RTPVideoHeader* rtp) { switch (info.codecType) { ... case kVideoCodecH264: { auto&amp; h264_header = rtp-&gt;video_type_header.emplace&lt;RTPVideoHeaderH264&gt;(); h264_header.packetization_mode = info.codecSpecific.H264.packetization_mode; rtp-&gt;simulcastIdx = spatial_index.value_or(0); return; }#ifndef DISABLE_H265 case kVideoCodecH265: { auto h265_header = rtp-&gt;video_type_header.emplace&lt;RTPVideoHeaderH265&gt;(); h265_header.packetization_mode = info.codecSpecific.H265.packetization_mode; } return;#endif... }}void RtpPayloadParams::SetGeneric(const CodecSpecificInfo* codec_specific_info, int64_t frame_id, bool is_keyframe, RTPVideoHeader* rtp_video_header) {... switch (rtp_video_header-&gt;codec) { ... case VideoCodecType::kVideoCodecH264: if (codec_specific_info) { H264ToGeneric(codec_specific_info-&gt;codecSpecific.H264, frame_id, is_keyframe, rtp_video_header); } return;#ifndef DISABLE_H265 case VideoCodecType::kVideoCodecH265:#endif case VideoCodecType::kVideoCodecMultiplex: return; }} rtpä¿¡æ¯è§£æžé…ç½® åœ¨common_videoä¸­æ–°å¢žh265æ–‡ä»¶å¤¹ï¼š common_video/h265/h265_bitstream_parser.cc >folded#include &quot;common_video/h265/h265_bitstream_parser.h&quot;#include &lt;stdlib.h&gt;#include &lt;cstdint&gt;#include &lt;vector&gt;#include &quot;common_video/h265/h265_common.h&quot;#include &quot;rtc_base/bit_buffer.h&quot;#include &quot;rtc_base/logging.h&quot;namespace {const int kMaxAbsQpDeltaValue = 51;const int kMinQpValue = 0;const int kMaxQpValue = 51;} // namespacenamespace webrtc {#define RETURN_ON_FAIL(x, res) \\ if (!(x)) { \\ RTC_LOG_F(LS_ERROR) &lt;&lt; &quot;FAILED: &quot; #x; \\ return res; \\ }#define RETURN_INV_ON_FAIL(x) RETURN_ON_FAIL(x, kInvalidStream)H265BitstreamParser::H265BitstreamParser() {}H265BitstreamParser::~H265BitstreamParser() {}H265BitstreamParser::Result H265BitstreamParser::ParseNonParameterSetNalu( const uint8_t* source, size_t source_length, uint8_t nalu_type) { if (!sps_ || !pps_) return kInvalidStream; last_slice_qp_delta_ = absl::nullopt; const std::vector&lt;uint8_t&gt; slice_rbsp = H265::ParseRbsp(source, source_length); if (slice_rbsp.size() &lt; H265::kNaluTypeSize) return kInvalidStream; rtc::BitBuffer slice_reader(slice_rbsp.data() + H265::kNaluTypeSize, slice_rbsp.size() - H265::kNaluTypeSize); // Check to see if this is an IDR slice, which has an extra field to parse // out. //bool is_idr = (source[0] &amp; 0x0F) == H265::NaluType::kIdr; //uint8_t nal_ref_idc = (source[0] &amp; 0x60) &gt;&gt; 5; uint32_t golomb_tmp; uint32_t bits_tmp; // first_slice_segment_in_pic_flag: u(1) uint32_t first_slice_segment_in_pic_flag = 0; RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;first_slice_segment_in_pic_flag, 1)); if (H265::NaluType::kBlaWLp &lt;= nalu_type &amp;&amp; nalu_type &lt;= H265::NaluType::kRsvIrapVcl23) { // no_output_of_prior_pics_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1)); } // slice_pic_parameter_set_id: ue(v) RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp)); uint32_t dependent_slice_segment_flag = 0; if (first_slice_segment_in_pic_flag == 0) { if (pps_-&gt;dependent_slice_segments_enabled_flag) { // dependent_slice_segment_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;dependent_slice_segment_flag, 1)); } // slice_segment_address: u(v) int32_t log2_ctb_size_y = sps_-&gt;log2_min_luma_coding_block_size_minus3 + 3 + sps_-&gt;log2_diff_max_min_luma_coding_block_size; uint32_t ctb_size_y = 1 &lt;&lt; log2_ctb_size_y; uint32_t pic_width_in_ctbs_y = sps_-&gt;pic_width_in_luma_samples / ctb_size_y; if(sps_-&gt;pic_width_in_luma_samples % ctb_size_y) pic_width_in_ctbs_y++; uint32_t pic_height_in_ctbs_y = sps_-&gt;pic_height_in_luma_samples / ctb_size_y; if(sps_-&gt;pic_height_in_luma_samples % ctb_size_y) pic_height_in_ctbs_y++; uint32_t slice_segment_address_bits = H265::Log2(pic_height_in_ctbs_y * pic_width_in_ctbs_y); RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, slice_segment_address_bits)); } if (dependent_slice_segment_flag == 0) { for (uint32_t i = 0; i &lt; pps_-&gt;num_extra_slice_header_bits; i++) { // slice_reserved_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1)); } // slice_type: ue(v) uint32_t slice_type = 0; RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;slice_type)); if (pps_-&gt;output_flag_present_flag) { // pic_output_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1)); } if (sps_-&gt;separate_colour_plane_flag) { // colour_plane_id: u(2) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 2)); } uint32_t num_long_term_sps = 0; uint32_t num_long_term_pics = 0; std::vector&lt;uint32_t&gt; lt_idx_sps; std::vector&lt;uint32_t&gt; used_by_curr_pic_lt_flag; uint32_t short_term_ref_pic_set_sps_flag = 0; uint32_t short_term_ref_pic_set_idx = 0; H265SpsParser::ShortTermRefPicSet short_term_ref_pic_set; uint32_t slice_temporal_mvp_enabled_flag = 0; if (nalu_type != H265::NaluType::kIdrWRadl &amp;&amp; nalu_type != H265::NaluType::kIdrNLp) { // slice_pic_order_cnt_lsb: u(v) uint32_t slice_pic_order_cnt_lsb_bits = sps_-&gt;log2_max_pic_order_cnt_lsb_minus4 + 4; RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, slice_pic_order_cnt_lsb_bits)); // short_term_ref_pic_set_sps_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;short_term_ref_pic_set_sps_flag, 1)); if (!short_term_ref_pic_set_sps_flag) { absl::optional&lt;H265SpsParser::ShortTermRefPicSet&gt; ref_pic_set = H265SpsParser::ParseShortTermRefPicSet(sps_-&gt;num_short_term_ref_pic_sets, sps_-&gt;num_short_term_ref_pic_sets, sps_-&gt;short_term_ref_pic_set, *sps_, &amp;slice_reader); if (ref_pic_set) { short_term_ref_pic_set = *ref_pic_set; } else { return kInvalidStream; } } else if (sps_-&gt;num_short_term_ref_pic_sets &gt; 1) { // short_term_ref_pic_set_idx: u(v) uint32_t short_term_ref_pic_set_idx_bits = H265::Log2(sps_-&gt;num_short_term_ref_pic_sets); if ((uint32_t)(1 &lt;&lt; short_term_ref_pic_set_idx_bits) &lt; sps_-&gt;num_short_term_ref_pic_sets) { short_term_ref_pic_set_idx_bits++; } if (short_term_ref_pic_set_idx_bits &gt; 0) { RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;short_term_ref_pic_set_idx, short_term_ref_pic_set_idx_bits)); } } if (sps_-&gt;long_term_ref_pics_present_flag) { if (sps_-&gt;num_long_term_ref_pics_sps &gt; 0) { // num_long_term_sps: ue(v) RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;num_long_term_sps)); } // num_long_term_sps: ue(v) RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;num_long_term_pics)); lt_idx_sps.resize(num_long_term_sps + num_long_term_pics, 0); used_by_curr_pic_lt_flag.resize(num_long_term_sps + num_long_term_pics, 0); for (uint32_t i = 0; i &lt; num_long_term_sps + num_long_term_pics; i++) { if (i &lt; num_long_term_sps) { if (sps_-&gt;num_long_term_ref_pics_sps &gt; 1) { // lt_idx_sps: u(v) uint32_t lt_idx_sps_bits = H265::Log2(sps_-&gt;num_long_term_ref_pics_sps); RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;lt_idx_sps[i], lt_idx_sps_bits)); } } else { // poc_lsb_lt: u(v) uint32_t poc_lsb_lt_bits = sps_-&gt;log2_max_pic_order_cnt_lsb_minus4 + 4; RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, poc_lsb_lt_bits)); // used_by_curr_pic_lt_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;used_by_curr_pic_lt_flag[i], 1)); } // delta_poc_msb_present_flag: u(1) uint32_t delta_poc_msb_present_flag = 0; RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;delta_poc_msb_present_flag, 1)); if (delta_poc_msb_present_flag) { // delta_poc_msb_cycle_lt: ue(v) RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp)); } } } if (sps_-&gt;sps_temporal_mvp_enabled_flag) { // slice_temporal_mvp_enabled_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;slice_temporal_mvp_enabled_flag, 1)); } } if (sps_-&gt;sample_adaptive_offset_enabled_flag) { // slice_sao_luma_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1)); uint32_t chroma_array_type = sps_-&gt;separate_colour_plane_flag == 0 ? sps_-&gt;chroma_format_idc : 0; if (chroma_array_type != 0) { // slice_sao_chroma_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1)); } } if (slice_type == H265::SliceType::kP || slice_type == H265::SliceType::kB) { // num_ref_idx_active_override_flag: u(1) uint32_t num_ref_idx_active_override_flag = 0; RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;num_ref_idx_active_override_flag, 1)); uint32_t num_ref_idx_l0_active_minus1 = pps_-&gt;num_ref_idx_l0_default_active_minus1; uint32_t num_ref_idx_l1_active_minus1 = pps_-&gt;num_ref_idx_l1_default_active_minus1; if (num_ref_idx_active_override_flag) { // num_ref_idx_l0_active_minus1: ue(v) RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;num_ref_idx_l0_active_minus1)); if (slice_type == H265::SliceType::kB) { // num_ref_idx_l1_active_minus1: ue(v) RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;num_ref_idx_l1_active_minus1)); } } uint32_t num_pic_total_curr = CalcNumPocTotalCurr( num_long_term_sps, num_long_term_pics, lt_idx_sps, used_by_curr_pic_lt_flag, short_term_ref_pic_set_sps_flag, short_term_ref_pic_set_idx, short_term_ref_pic_set); if (pps_-&gt;lists_modification_present_flag &amp;&amp; num_pic_total_curr &gt; 1) { // ref_pic_lists_modification() uint32_t list_entry_bits = H265::Log2(num_pic_total_curr); if ((uint32_t)(1 &lt;&lt; list_entry_bits) &lt; num_pic_total_curr) { list_entry_bits++; } // ref_pic_list_modification_flag_l0: u(1) uint32_t ref_pic_list_modification_flag_l0 = 0; RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;ref_pic_list_modification_flag_l0, 1)); if (ref_pic_list_modification_flag_l0) { for (uint32_t i = 0; i &lt; num_ref_idx_l0_active_minus1; i++) { // list_entry_l0: u(v) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, list_entry_bits)); } } if (slice_type == H265::SliceType::kB) { // ref_pic_list_modification_flag_l1: u(1) uint32_t ref_pic_list_modification_flag_l1 = 0; RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;ref_pic_list_modification_flag_l1, 1)); if (ref_pic_list_modification_flag_l1) { for (uint32_t i = 0; i &lt; num_ref_idx_l1_active_minus1; i++) { // list_entry_l1: u(v) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, list_entry_bits)); } } } } if (slice_type == H265::SliceType::kB) { // mvd_l1_zero_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1)); } if (pps_-&gt;cabac_init_present_flag) { // cabac_init_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;bits_tmp, 1)); } if (slice_temporal_mvp_enabled_flag) { uint32_t collocated_from_l0_flag = 0; if (slice_type == H265::SliceType::kB) { // collocated_from_l0_flag: u(1) RETURN_INV_ON_FAIL(slice_reader.ReadBits(&amp;collocated_from_l0_flag, 1)); } if ((collocated_from_l0_flag &amp;&amp; num_ref_idx_l0_active_minus1 &gt; 0) || (!collocated_from_l0_flag &amp;&amp; num_ref_idx_l1_active_minus1 &gt; 0)) { // collocated_ref_idx: ue(v) RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp)); } } if ((pps_-&gt;weighted_pred_flag &amp;&amp; slice_type == H265::SliceType::kP) || (pps_-&gt;weighted_bipred_flag &amp;&amp; slice_type == H265::SliceType::kB)) { // pred_weight_table() // TODO(piasy): Do we need support for pred_weight_table()? RTC_LOG(LS_ERROR) &lt;&lt; &quot;Streams with pred_weight_table unsupported.&quot;; return kUnsupportedStream; } // five_minus_max_num_merge_cand: ue(v) RETURN_INV_ON_FAIL(slice_reader.ReadExponentialGolomb(&amp;golomb_tmp)); // TODO(piasy): motion_vector_resolution_control_idc? } } // slice_qp_delta: se(v) int32_t last_slice_qp_delta; RETURN_INV_ON_FAIL( slice_reader.ReadSignedExponentialGolomb(&amp;last_slice_qp_delta)); if (abs(last_slice_qp_delta) &gt; kMaxAbsQpDeltaValue) { // Something has gone wrong, and the parsed value is invalid. RTC_LOG(LS_WARNING) &lt;&lt; &quot;Parsed QP value out of range.&quot;; return kInvalidStream; } last_slice_qp_delta_ = last_slice_qp_delta; return kOk;}uint32_t H265BitstreamParser::CalcNumPocTotalCurr( uint32_t num_long_term_sps, uint32_t num_long_term_pics, const std::vector&lt;uint32_t&gt; lt_idx_sps, const std::vector&lt;uint32_t&gt; used_by_curr_pic_lt_flag, uint32_t short_term_ref_pic_set_sps_flag, uint32_t short_term_ref_pic_set_idx, const H265SpsParser::ShortTermRefPicSet&amp; short_term_ref_pic_set) { uint32_t num_poc_total_curr = 0; uint32_t curr_sps_idx; bool used_by_curr_pic_lt[16]; uint32_t num_long_term = num_long_term_sps + num_long_term_pics; for (uint32_t i = 0; i &lt; num_long_term; i++) { if (i &lt; num_long_term_sps) { used_by_curr_pic_lt[i] = sps_-&gt;used_by_curr_pic_lt_sps_flag[lt_idx_sps[i]]; } else { used_by_curr_pic_lt[i] = used_by_curr_pic_lt_flag[i]; } } if (short_term_ref_pic_set_sps_flag) { curr_sps_idx = short_term_ref_pic_set_idx; } else { curr_sps_idx = sps_-&gt;num_short_term_ref_pic_sets; } if (sps_-&gt;short_term_ref_pic_set.size() &lt;= curr_sps_idx) { if (curr_sps_idx != 0 || short_term_ref_pic_set_sps_flag) { return 0; } } const H265SpsParser::ShortTermRefPicSet* ref_pic_set; if (curr_sps_idx &lt; sps_-&gt;short_term_ref_pic_set.size()) { ref_pic_set = &amp;(sps_-&gt;short_term_ref_pic_set[curr_sps_idx]); } else { ref_pic_set = &amp;short_term_ref_pic_set; } for (uint32_t i = 0; i &lt; ref_pic_set-&gt;num_negative_pics; i++) { if (ref_pic_set-&gt;used_by_curr_pic_s0_flag[i]) { num_poc_total_curr++; } } for (uint32_t i = 0; i &lt; ref_pic_set-&gt;num_positive_pics; i++) { if (ref_pic_set-&gt;used_by_curr_pic_s1_flag[i]) { num_poc_total_curr++; } } for (uint32_t i = 0; i &lt; num_long_term_sps + num_long_term_pics; i++) { if (used_by_curr_pic_lt[i]) { num_poc_total_curr++; } } return num_poc_total_curr;}void H265BitstreamParser::ParseSlice(const uint8_t* slice, size_t length) { H265::NaluType nalu_type = H265::ParseNaluType(slice[0]); if (nalu_type == H265::NaluType::kSps) { sps_ = H265SpsParser::ParseSps(slice + H265::kNaluTypeSize, length - H265::kNaluTypeSize); if (!sps_) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Unable to parse SPS from H265 bitstream.&quot;; } } else if (nalu_type == H265::NaluType::kPps) { pps_ = H265PpsParser::ParsePps(slice + H265::kNaluTypeSize, length - H265::kNaluTypeSize); if (!pps_) { RTC_LOG(LS_WARNING) &lt;&lt; &quot;Unable to parse PPS from H265 bitstream.&quot;; } } else if (nalu_type &lt;= H265::NaluType::kRsvIrapVcl23) { Result res = ParseNonParameterSetNalu(slice, length, nalu_type); if (res != kOk) { RTC_LOG(LS_INFO) &lt;&lt; &quot;Failed to parse bitstream. Error: &quot; &lt;&lt; res; } }}void H265BitstreamParser::ParseBitstream(const uint8_t* bitstream, size_t length) { std::vector&lt;H265::NaluIndex&gt; nalu_indices = H265::FindNaluIndices(bitstream, length); for (const H265::NaluIndex&amp; index : nalu_indices) ParseSlice(&amp;bitstream[index.payload_start_offset], index.payload_size);}bool H265BitstreamParser::GetLastSliceQp(int* qp) const { if (!last_slice_qp_delta_ || !pps_) { return false; } const int parsed_qp = 26 + pps_-&gt;pic_init_qp_minus26 + *last_slice_qp_delta_; if (parsed_qp &lt; kMinQpValue || parsed_qp &gt; kMaxQpValue) { RTC_LOG(LS_ERROR) &lt;&lt; &quot;Parsed invalid QP from bitstream.&quot;; return false; } *qp = parsed_qp; return true;}void H265BitstreamParser::ParseBitstream( rtc::ArrayView&lt;const uint8_t&gt; bitstream) { ParseBitstream(bitstream.data(), bitstream.size());}absl::optional&lt;int&gt; H265BitstreamParser::GetLastSliceQp() const { int qp; bool success = GetLastSliceQp(&amp;qp); return success ? absl::optional&lt;int&gt;(qp) : absl::nullopt;}} // namespace webrtc common_video/h265/h265_bitstream_parser.h >folded#ifndef COMMON_VIDEO_H265_H265_BITSTREAM_PARSER_H_#define COMMON_VIDEO_H265_H265_BITSTREAM_PARSER_H_#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include &quot;absl/types/optional.h&quot;#include &quot;api/video_codecs/bitstream_parser.h&quot;#include &quot;common_video/h265/h265_pps_parser.h&quot;#include &quot;common_video/h265/h265_sps_parser.h&quot;namespace webrtc {// Stateful H265 bitstream parser (due to SPS/PPS). Used to parse out QP values// from the bitstream.// TODO(pbos): Unify with RTP SPS parsing and only use one H265 parser.// TODO(pbos): If/when this gets used on the receiver side CHECKs must be// removed and gracefully abort as we have no control over receive-side// bitstreams.class H265BitstreamParser : public BitstreamParser { public: H265BitstreamParser(); ~H265BitstreamParser() override; // These are here for backwards-compatability for the time being. void ParseBitstream(const uint8_t* bitstream, size_t length); bool GetLastSliceQp(int* qp) const; // New interface. void ParseBitstream(rtc::ArrayView&lt;const uint8_t&gt; bitstream) override; absl::optional&lt;int&gt; GetLastSliceQp() const override; protected: enum Result { kOk, kInvalidStream, kUnsupportedStream, }; void ParseSlice(const uint8_t* slice, size_t length); Result ParseNonParameterSetNalu(const uint8_t* source, size_t source_length, uint8_t nalu_type); uint32_t CalcNumPocTotalCurr(uint32_t num_long_term_sps, uint32_t num_long_term_pics, const std::vector&lt;uint32_t&gt; lt_idx_sps, const std::vector&lt;uint32_t&gt; used_by_curr_pic_lt_flag, uint32_t short_term_ref_pic_set_sps_flag, uint32_t short_term_ref_pic_set_idx, const H265SpsParser::ShortTermRefPicSet&amp; short_term_ref_pic_set); // SPS/PPS state, updated when parsing new SPS/PPS, used to parse slices. absl::optional&lt;H265SpsParser::SpsState&gt; sps_; absl::optional&lt;H265PpsParser::PpsState&gt; pps_; // Last parsed slice QP. absl::optional&lt;int32_t&gt; last_slice_qp_delta_;};} // namespace webrtc#endif // COMMON_VIDEO_H265_H265_BITSTREAM_PARSER_H_ common_video/h265/h265_common.cc >folded#include &quot;common_video/h265/h265_common.h&quot;#include &quot;common_video/h264/h264_common.h&quot;namespace webrtc {namespace H265 {const uint8_t kNaluTypeMask = 0x7E;std::vector&lt;NaluIndex&gt; FindNaluIndices(const uint8_t* buffer, size_t buffer_size) { std::vector&lt;H264::NaluIndex&gt; indices = H264::FindNaluIndices(buffer, buffer_size); std::vector&lt;NaluIndex&gt; results; for (auto&amp; index : indices) { results.push_back({index.start_offset, index.payload_start_offset, index.payload_size}); } return results;}NaluType ParseNaluType(uint8_t data) { return static_cast&lt;NaluType&gt;((data &amp; kNaluTypeMask) &gt;&gt; 1);}std::vector&lt;uint8_t&gt; ParseRbsp(const uint8_t* data, size_t length) { return H264::ParseRbsp(data, length);}void WriteRbsp(const uint8_t* bytes, size_t length, rtc::Buffer* destination) { H264::WriteRbsp(bytes, length, destination);}uint32_t Log2(uint32_t value) { uint32_t result = 0; // If value is not a power of two an additional bit is required // to account for the ceil() of log2() below. if ((value &amp; (value - 1)) != 0) { ++result; } while (value &gt; 0) { value &gt;&gt;= 1; ++result; } return result;}} // namespace H265} // namespace webrtc common_video/h265/h265_common.h >folded#ifndef COMMON_VIDEO_H265_H265_COMMON_H_#define COMMON_VIDEO_H265_H265_COMMON_H_#include &lt;memory&gt;#include &lt;vector&gt;#include &quot;rtc_base/buffer.h&quot;namespace webrtc {namespace H265 {// The size of a full NALU start sequence {0 0 0 1}, used for the first NALU// of an access unit, and for SPS and PPS blocks.const size_t kNaluLongStartSequenceSize = 4;// The size of a shortened NALU start sequence {0 0 1}, that may be used if// not the first NALU of an access unit or an SPS or PPS block.const size_t kNaluShortStartSequenceSize = 3;// The size of the NALU type byte (2).const size_t kNaluTypeSize = 2;enum NaluType : uint8_t { kTrailN = 0, kTrailR = 1, kTsaN = 2, kTsaR = 3, kStsaN = 4, kStsaR = 5, kRadlN = 6, kRadlR = 7, kBlaWLp = 16, kBlaWRadl = 17, kBlaNLp = 18, kIdrWRadl = 19, kIdrNLp = 20, kCra = 21, kRsvIrapVcl23 = 23, kVps = 32, kSps = 33, kPps = 34, kAud = 35, kPrefixSei = 39, kSuffixSei = 40, kAP = 48, kFU = 49};enum SliceType : uint8_t { kB = 0, kP = 1, kI = 2 };struct NaluIndex { // Start index of NALU, including start sequence. size_t start_offset; // Start index of NALU payload, typically type header. size_t payload_start_offset; // Length of NALU payload, in bytes, counting from payload_start_offset. size_t payload_size;};// Returns a vector of the NALU indices in the given buffer.std::vector&lt;NaluIndex&gt; FindNaluIndices(const uint8_t* buffer, size_t buffer_size);// Get the NAL type from the header byte immediately following start sequence.NaluType ParseNaluType(uint8_t data);// Methods for parsing and writing RBSP. See section 7.4.2 of the H265 spec.//// The following sequences are illegal, and need to be escaped when encoding:// 00 00 00 -&gt; 00 00 03 00// 00 00 01 -&gt; 00 00 03 01// 00 00 02 -&gt; 00 00 03 02// And things in the source that look like the emulation byte pattern (00 00 03)// need to have an extra emulation byte added, so it's removed when decoding:// 00 00 03 -&gt; 00 00 03 03//// Decoding is simply a matter of finding any 00 00 03 sequence and removing// the 03 emulation byte.// Parse the given data and remove any emulation byte escaping.std::vector&lt;uint8_t&gt; ParseRbsp(const uint8_t* data, size_t length);// Write the given data to the destination buffer, inserting and emulation// bytes in order to escape any data the could be interpreted as a start// sequence.void WriteRbsp(const uint8_t* bytes, size_t length, rtc::Buffer* destination);uint32_t Log2(uint32_t value);} // namespace H265} // namespace webrtc#endif // COMMON_VIDEO_H265_H265_COMMON_H_ common_video/h265/h265_pps_parser.cc >folded#include &quot;common_video/h265/h265_pps_parser.h&quot;#include &lt;memory&gt;#include &lt;vector&gt;#include &quot;common_video/h265/h265_common.h&quot;#include &quot;common_video/h265/h265_sps_parser.h&quot;#include &quot;rtc_base/bit_buffer.h&quot;#include &quot;rtc_base/logging.h&quot;#define RETURN_EMPTY_ON_FAIL(x) \\ if (!(x)) { \\ return absl::nullopt; \\ }namespace {const int kMaxPicInitQpDeltaValue = 25;const int kMinPicInitQpDeltaValue = -26;} // namespacenamespace webrtc {// General note: this is based off the 06/2019 version of the H.265 standard.// You can find it on this page:// http://www.itu.int/rec/T-REC-H.265absl::optional&lt;H265PpsParser::PpsState&gt; H265PpsParser::ParsePps( const uint8_t* data, size_t length) { // First, parse out rbsp, which is basically the source buffer minus emulation // bytes (the last byte of a 0x00 0x00 0x03 sequence). RBSP is defined in // section 7.3.1.1 of the H.265 standard. std::vector&lt;uint8_t&gt; unpacked_buffer = H265::ParseRbsp(data, length); rtc::BitBuffer bit_buffer(unpacked_buffer.data(), unpacked_buffer.size()); return ParseInternal(&amp;bit_buffer);}bool H265PpsParser::ParsePpsIds(const uint8_t* data, size_t length, uint32_t* pps_id, uint32_t* sps_id) { RTC_DCHECK(pps_id); RTC_DCHECK(sps_id); // First, parse out rbsp, which is basically the source buffer minus emulation // bytes (the last byte of a 0x00 0x00 0x03 sequence). RBSP is defined in // section 7.3.1.1 of the H.265 standard. std::vector&lt;uint8_t&gt; unpacked_buffer = H265::ParseRbsp(data, length); rtc::BitBuffer bit_buffer(unpacked_buffer.data(), unpacked_buffer.size()); return ParsePpsIdsInternal(&amp;bit_buffer, pps_id, sps_id);}absl::optional&lt;uint32_t&gt; H265PpsParser::ParsePpsIdFromSliceSegmentLayerRbsp( const uint8_t* data, size_t length, uint8_t nalu_type) { rtc::BitBuffer slice_reader(data, length); // first_slice_segment_in_pic_flag: u(1) uint32_t first_slice_segment_in_pic_flag = 0; RETURN_EMPTY_ON_FAIL( slice_reader.ReadBits(&amp;first_slice_segment_in_pic_flag, 1)); if (nalu_type &gt;= H265::NaluType::kBlaWLp &amp;&amp; nalu_type &lt;= H265::NaluType::kRsvIrapVcl23) { // no_output_of_prior_pics_flag: u(1) RETURN_EMPTY_ON_FAIL(slice_reader.ConsumeBits(1)); } // slice_pic_parameter_set_id: ue(v) uint32_t slice_pic_parameter_set_id = 0; if (!slice_reader.ReadExponentialGolomb(&amp;slice_pic_parameter_set_id)) return absl::nullopt; return slice_pic_parameter_set_id;}absl::optional&lt;H265PpsParser::PpsState&gt; H265PpsParser::ParseInternal( rtc::BitBuffer* bit_buffer) { PpsState pps; RETURN_EMPTY_ON_FAIL(ParsePpsIdsInternal(bit_buffer, &amp;pps.id, &amp;pps.sps_id)); uint32_t bits_tmp; uint32_t golomb_ignored; int32_t signed_golomb_ignored; // dependent_slice_segments_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps.dependent_slice_segments_enabled_flag, 1)); // output_flag_present_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps.output_flag_present_flag, 1)); // num_extra_slice_header_bits: u(3) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps.num_extra_slice_header_bits, 3)); // sign_data_hiding_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); // cabac_init_present_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps.cabac_init_present_flag, 1)); // num_ref_idx_l0_default_active_minus1: ue(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadExponentialGolomb(&amp;pps.num_ref_idx_l0_default_active_minus1)); // num_ref_idx_l1_default_active_minus1: ue(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadExponentialGolomb(&amp;pps.num_ref_idx_l1_default_active_minus1)); // init_qp_minus26: se(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadSignedExponentialGolomb(&amp;pps.pic_init_qp_minus26)); // Sanity-check parsed value if (pps.pic_init_qp_minus26 &gt; kMaxPicInitQpDeltaValue || pps.pic_init_qp_minus26 &lt; kMinPicInitQpDeltaValue) { RETURN_EMPTY_ON_FAIL(false); } // constrained_intra_pred_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); // transform_skip_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); // cu_qp_delta_enabled_flag: u(1) uint32_t cu_qp_delta_enabled_flag = 0; RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;cu_qp_delta_enabled_flag, 1)); if (cu_qp_delta_enabled_flag) { // diff_cu_qp_delta_depth: ue(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); } // pps_cb_qp_offset: se(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadSignedExponentialGolomb(&amp;signed_golomb_ignored)); // pps_cr_qp_offset: se(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadSignedExponentialGolomb(&amp;signed_golomb_ignored)); // pps_slice_chroma_qp_offsets_present_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); // weighted_pred_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps.weighted_pred_flag, 1)); // weighted_bipred_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps.weighted_bipred_flag, 1)); // transquant_bypass_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); // tiles_enabled_flag: u(1) uint32_t tiles_enabled_flag = 0; RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;tiles_enabled_flag, 1)); // entropy_coding_sync_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); if (tiles_enabled_flag) { // num_tile_columns_minus1: ue(v) uint32_t num_tile_columns_minus1 = 0; RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadExponentialGolomb(&amp;num_tile_columns_minus1)); // num_tile_rows_minus1: ue(v) uint32_t num_tile_rows_minus1 = 0; RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadExponentialGolomb(&amp;num_tile_rows_minus1)); // uniform_spacing_flag: u(1) uint32_t uniform_spacing_flag = 0; RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;uniform_spacing_flag, 1)); if (!uniform_spacing_flag) { for (uint32_t i = 0; i &lt; num_tile_columns_minus1; i++) { // column_width_minus1: ue(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); } for (uint32_t i = 0; i &lt; num_tile_rows_minus1; i++) { // row_height_minus1: ue(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); } // loop_filter_across_tiles_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); } } // pps_loop_filter_across_slices_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); // deblocking_filter_control_present_flag: u(1) uint32_t deblocking_filter_control_present_flag = 0; RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;deblocking_filter_control_present_flag, 1)); if (deblocking_filter_control_present_flag) { // deblocking_filter_override_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); // pps_deblocking_filter_disabled_flag: u(1) uint32_t pps_deblocking_filter_disabled_flag = 0; RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps_deblocking_filter_disabled_flag, 1)); if (!pps_deblocking_filter_disabled_flag) { // pps_beta_offset_div2: se(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadSignedExponentialGolomb(&amp;signed_golomb_ignored)); // pps_tc_offset_div2: se(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadSignedExponentialGolomb(&amp;signed_golomb_ignored)); } } // pps_scaling_list_data_present_flag: u(1) uint32_t pps_scaling_list_data_present_flag = 0; RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps_scaling_list_data_present_flag, 1)); if (pps_scaling_list_data_present_flag) { // scaling_list_data() if (!H265SpsParser::ParseScalingListData(bit_buffer)) { return absl::nullopt; } } // lists_modification_present_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;pps.lists_modification_present_flag, 1)); // log2_parallel_merge_level_minus2: ue(v) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // slice_segment_header_extension_present_flag: u(1) RETURN_EMPTY_ON_FAIL(bit_buffer-&gt;ReadBits(&amp;bits_tmp, 1)); return pps;}bool H265PpsParser::ParsePpsIdsInternal(rtc::BitBuffer* bit_buffer, uint32_t* pps_id, uint32_t* sps_id) { // pic_parameter_set_id: ue(v) if (!bit_buffer-&gt;ReadExponentialGolomb(pps_id)) return false; // seq_parameter_set_id: ue(v) if (!bit_buffer-&gt;ReadExponentialGolomb(sps_id)) return false; return true;}} // namespace webrtc common_video/h265/h265_pps_parser.h >folded#ifndef COMMON_VIDEO_H265_PPS_PARSER_H_#define COMMON_VIDEO_H265_PPS_PARSER_H_#include &quot;absl/types/optional.h&quot;namespace rtc {class BitBuffer;}namespace webrtc {// A class for parsing out picture parameter set (PPS) data from a H265 NALU.class H265PpsParser { public: // The parsed state of the PPS. Only some select values are stored. // Add more as they are actually needed. struct PpsState { PpsState() = default; uint32_t dependent_slice_segments_enabled_flag = 0; uint32_t cabac_init_present_flag = 0; uint32_t output_flag_present_flag = 0; uint32_t num_extra_slice_header_bits = 0; uint32_t num_ref_idx_l0_default_active_minus1 = 0; uint32_t num_ref_idx_l1_default_active_minus1 = 0; int32_t pic_init_qp_minus26 = 0; uint32_t weighted_pred_flag = 0; uint32_t weighted_bipred_flag = 0; uint32_t lists_modification_present_flag = 0; uint32_t id = 0; uint32_t sps_id = 0; }; // Unpack RBSP and parse PPS state from the supplied buffer. static absl::optional&lt;PpsState&gt; ParsePps(const uint8_t* data, size_t length); static bool ParsePpsIds(const uint8_t* data, size_t length, uint32_t* pps_id, uint32_t* sps_id); static absl::optional&lt;uint32_t&gt; ParsePpsIdFromSliceSegmentLayerRbsp( const uint8_t* data, size_t length, uint8_t nalu_type); protected: // Parse the PPS state, for a bit buffer where RBSP decoding has already been // performed. static absl::optional&lt;PpsState&gt; ParseInternal(rtc::BitBuffer* bit_buffer); static bool ParsePpsIdsInternal(rtc::BitBuffer* bit_buffer, uint32_t* pps_id, uint32_t* sps_id);};} // namespace webrtc#endif // COMMON_VIDEO_H265_PPS_PARSER_H_ common_video/h265/h265_sps_parser.cc >folded#include &lt;memory&gt;#include &lt;vector&gt;#include &quot;common_video/h265/h265_common.h&quot;#include &quot;common_video/h265/h265_sps_parser.h&quot;#include &quot;rtc_base/bit_buffer.h&quot;#include &quot;rtc_base/logging.h&quot;namespace {typedef absl::optional&lt;webrtc::H265SpsParser::SpsState&gt; OptionalSps;typedef absl::optional&lt;webrtc::H265SpsParser::ShortTermRefPicSet&gt; OptionalShortTermRefPicSet;#define RETURN_EMPTY_ON_FAIL(x) \\ if (!(x)) { \\ return OptionalSps(); \\ }#define RETURN_FALSE_ON_FAIL(x) \\ if (!(x)) { \\ return false; \\ }#define RETURN_EMPTY2_ON_FAIL(x) \\ if (!(x)) { \\ return OptionalShortTermRefPicSet(); \\ }} // namespacenamespace webrtc {H265SpsParser::SpsState::SpsState() = default;H265SpsParser::ShortTermRefPicSet::ShortTermRefPicSet() = default;// General note: this is based off the 06/2019 version of the H.265 standard.// You can find it on this page:// http://www.itu.int/rec/T-REC-H.265// Unpack RBSP and parse SPS state from the supplied buffer.absl::optional&lt;H265SpsParser::SpsState&gt; H265SpsParser::ParseSps( const uint8_t* data, size_t length) { std::vector&lt;uint8_t&gt; unpacked_buffer = H265::ParseRbsp(data, length); rtc::BitBuffer bit_buffer(unpacked_buffer.data(), unpacked_buffer.size()); return ParseSpsInternal(&amp;bit_buffer);}bool H265SpsParser::ParseScalingListData(rtc::BitBuffer* buffer) { uint32_t scaling_list_pred_mode_flag[4][6]; uint32_t scaling_list_pred_matrix_id_delta[4][6]; int32_t scaling_list_dc_coef_minus8[4][6]; int32_t scaling_list[4][6][64]; for (int size_id = 0; size_id &lt; 4; size_id++) { for (int matrix_id = 0; matrix_id &lt; 6; matrix_id += (size_id == 3) ? 3 : 1) { // scaling_list_pred_mode_flag: u(1) RETURN_FALSE_ON_FAIL(buffer-&gt;ReadBits(&amp;scaling_list_pred_mode_flag[size_id][matrix_id], 1)); if (!scaling_list_pred_mode_flag[size_id][matrix_id]) { // scaling_list_pred_matrix_id_delta: ue(v) RETURN_FALSE_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;scaling_list_pred_matrix_id_delta[size_id][matrix_id])); } else { int32_t next_coef = 8; uint32_t coef_num = std::min(64, 1 &lt;&lt; (4 + (size_id &lt;&lt; 1))); if (size_id &gt; 1) { // scaling_list_dc_coef_minus8: se(v) RETURN_FALSE_ON_FAIL(buffer-&gt;ReadSignedExponentialGolomb(&amp;scaling_list_dc_coef_minus8[size_id - 2][matrix_id])); next_coef = scaling_list_dc_coef_minus8[size_id - 2][matrix_id]; } for (uint32_t i = 0; i &lt; coef_num; i++) { // scaling_list_delta_coef: se(v) int32_t scaling_list_delta_coef = 0; RETURN_FALSE_ON_FAIL(buffer-&gt;ReadSignedExponentialGolomb(&amp;scaling_list_delta_coef)); next_coef = (next_coef + scaling_list_delta_coef + 256) % 256; scaling_list[size_id][matrix_id][i] = next_coef; } } } } return true;}absl::optional&lt;H265SpsParser::ShortTermRefPicSet&gt; H265SpsParser::ParseShortTermRefPicSet( uint32_t st_rps_idx, uint32_t num_short_term_ref_pic_sets, const std::vector&lt;H265SpsParser::ShortTermRefPicSet&gt;&amp; short_term_ref_pic_set, H265SpsParser::SpsState&amp; sps, rtc::BitBuffer* buffer) { H265SpsParser::ShortTermRefPicSet ref_pic_set; uint32_t inter_ref_pic_set_prediction_flag = 0; if (st_rps_idx != 0) { // inter_ref_pic_set_prediction_flag: u(1) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadBits(&amp;inter_ref_pic_set_prediction_flag, 1)); } if (inter_ref_pic_set_prediction_flag) { uint32_t delta_idx_minus1 = 0; if (st_rps_idx == num_short_term_ref_pic_sets) { // delta_idx_minus1: ue(v) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;delta_idx_minus1)); } // delta_rps_sign: u(1) uint32_t delta_rps_sign = 0; RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadBits(&amp;delta_rps_sign, 1)); // abs_delta_rps_minus1: ue(v) uint32_t abs_delta_rps_minus1 = 0; RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;abs_delta_rps_minus1)); uint32_t ref_rps_idx = st_rps_idx - (delta_idx_minus1 + 1); uint32_t num_delta_pocs = 0; if (short_term_ref_pic_set[ref_rps_idx].inter_ref_pic_set_prediction_flag) { auto&amp; used_by_curr_pic_flag = short_term_ref_pic_set[ref_rps_idx].used_by_curr_pic_flag; auto&amp; use_delta_flag = short_term_ref_pic_set[ref_rps_idx].use_delta_flag; if (used_by_curr_pic_flag.size() != use_delta_flag.size()) { return OptionalShortTermRefPicSet(); } for (uint32_t i = 0; i &lt; used_by_curr_pic_flag.size(); i++) { if (used_by_curr_pic_flag[i] || use_delta_flag[i]) { num_delta_pocs++; } } } else { num_delta_pocs = short_term_ref_pic_set[ref_rps_idx].num_negative_pics + short_term_ref_pic_set[ref_rps_idx].num_positive_pics; } ref_pic_set.used_by_curr_pic_flag.resize(num_delta_pocs + 1, 0); ref_pic_set.use_delta_flag.resize(num_delta_pocs + 1, 1); for (uint32_t j = 0; j &lt;= num_delta_pocs; j++) { // used_by_curr_pic_flag: u(1) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadBits(&amp;ref_pic_set.used_by_curr_pic_flag[j], 1)); if (!ref_pic_set.used_by_curr_pic_flag[j]) { // use_delta_flag: u(1) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadBits(&amp;ref_pic_set.use_delta_flag[j], 1)); } } } else { // num_negative_pics: ue(v) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;ref_pic_set.num_negative_pics)); // num_positive_pics: ue(v) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;ref_pic_set.num_positive_pics)); ref_pic_set.delta_poc_s0_minus1.resize(ref_pic_set.num_negative_pics, 0); ref_pic_set.used_by_curr_pic_s0_flag.resize(ref_pic_set.num_negative_pics, 0); for (uint32_t i = 0; i &lt; ref_pic_set.num_negative_pics; i++) { // delta_poc_s0_minus1: ue(v) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;ref_pic_set.delta_poc_s0_minus1[i])); // used_by_curr_pic_s0_flag: u(1) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadBits(&amp;ref_pic_set.used_by_curr_pic_s0_flag[i], 1)); } ref_pic_set.delta_poc_s1_minus1.resize(ref_pic_set.num_positive_pics, 0); ref_pic_set.used_by_curr_pic_s1_flag.resize(ref_pic_set.num_positive_pics, 0); for (uint32_t i = 0; i &lt; ref_pic_set.num_positive_pics; i++) { // delta_poc_s1_minus1: ue(v) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;ref_pic_set.delta_poc_s1_minus1[i])); // used_by_curr_pic_s1_flag: u(1) RETURN_EMPTY2_ON_FAIL(buffer-&gt;ReadBits(&amp;ref_pic_set.used_by_curr_pic_s1_flag[i], 1)); } } return OptionalShortTermRefPicSet(ref_pic_set);}absl::optional&lt;H265SpsParser::SpsState&gt; H265SpsParser::ParseSpsInternal( rtc::BitBuffer* buffer) { // Now, we need to use a bit buffer to parse through the actual HEVC SPS // format. See Section 7.3.2.2.1 (&quot;General sequence parameter set data // syntax&quot;) of the H.265 standard for a complete description. // Since we only care about resolution, we ignore the majority of fields, but // we still have to actively parse through a lot of the data, since many of // the fields have variable size. // We're particularly interested in: // chroma_format_idc -&gt; affects crop units // pic_{width,height}_* -&gt; resolution of the frame in macroblocks (16x16). // frame_crop_*_offset -&gt; crop information SpsState sps; // The golomb values we have to read, not just consume. uint32_t golomb_ignored; // sps_video_parameter_set_id: u(4) uint32_t sps_video_parameter_set_id = 0; RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps_video_parameter_set_id, 4)); // sps_max_sub_layers_minus1: u(3) uint32_t sps_max_sub_layers_minus1 = 0; RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps_max_sub_layers_minus1, 3)); sps.sps_max_sub_layers_minus1 = sps_max_sub_layers_minus1; sps.sps_max_dec_pic_buffering_minus1.resize(sps_max_sub_layers_minus1 + 1, 0); // sps_temporal_id_nesting_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(1)); // profile_tier_level(1, sps_max_sub_layers_minus1). We are acutally not // using them, so read/skip over it. // general_profile_space+general_tier_flag+general_prfile_idc: u(8) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBytes(1)); // general_profile_compatabilitiy_flag[32] RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBytes(4)); // general_progressive_source_flag + interlaced_source_flag+ // non-packed_constraint flag + frame_only_constraint_flag: u(4) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(4)); // general_profile_idc decided flags or reserved. u(43) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(43)); // general_inbld_flag or reserved 0: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(1)); // general_level_idc: u(8) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBytes(1)); // if max_sub_layers_minus1 &gt;=1, read the sublayer profile information std::vector&lt;uint32_t&gt; sub_layer_profile_present_flags; std::vector&lt;uint32_t&gt; sub_layer_level_present_flags; uint32_t sub_layer_profile_present = 0; uint32_t sub_layer_level_present = 0; for (uint32_t i = 0; i &lt; sps_max_sub_layers_minus1; i++) { // sublayer_profile_present_flag and sublayer_level_presnet_flag: u(2) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sub_layer_profile_present, 1)); RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sub_layer_level_present, 1)); sub_layer_profile_present_flags.push_back(sub_layer_profile_present); sub_layer_level_present_flags.push_back(sub_layer_level_present); } if (sps_max_sub_layers_minus1 &gt; 0) { for (uint32_t j = sps_max_sub_layers_minus1; j &lt; 8; j++) { // reserved 2 bits: u(2) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(2)); } } for (uint32_t k = 0; k &lt; sps_max_sub_layers_minus1; k++) { if (sub_layer_profile_present_flags[k]) { // // sub_layer profile_space/tier_flag/profile_idc. ignored. u(8) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBytes(1)); // profile_compatability_flag: u(32) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBytes(4)); // sub_layer progressive_source_flag/interlaced_source_flag/ // non_packed_constraint_flag/frame_only_constraint_flag: u(4) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(4)); // following 43-bits are profile_idc specific. We simply read/skip it. // u(43) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(43)); // 1-bit profile_idc specific inbld flag. We simply read/skip it. u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(1)); } if (sub_layer_level_present_flags[k]) { // sub_layer_level_idc: u(8) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBytes(1)); } } // sps_seq_parameter_set_id: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;sps.id)); // chrome_format_idc: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;sps.chroma_format_idc)); if (sps.chroma_format_idc == 3) { // seperate_colour_plane_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps.separate_colour_plane_flag, 1)); } uint32_t pic_width_in_luma_samples = 0; uint32_t pic_height_in_luma_samples = 0; // pic_width_in_luma_samples: ue(v) RETURN_EMPTY_ON_FAIL( buffer-&gt;ReadExponentialGolomb(&amp;pic_width_in_luma_samples)); // pic_height_in_luma_samples: ue(v) RETURN_EMPTY_ON_FAIL( buffer-&gt;ReadExponentialGolomb(&amp;pic_height_in_luma_samples)); // conformance_window_flag: u(1) uint32_t conformance_window_flag = 0; RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;conformance_window_flag, 1)); uint32_t conf_win_left_offset = 0; uint32_t conf_win_right_offset = 0; uint32_t conf_win_top_offset = 0; uint32_t conf_win_bottom_offset = 0; if (conformance_window_flag) { // conf_win_left_offset: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;conf_win_left_offset)); // conf_win_right_offset: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;conf_win_right_offset)); // conf_win_top_offset: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;conf_win_top_offset)); // conf_win_bottom_offset: ue(v) RETURN_EMPTY_ON_FAIL( buffer-&gt;ReadExponentialGolomb(&amp;conf_win_bottom_offset)); } // bit_depth_luma_minus8: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // bit_depth_chroma_minus8: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // log2_max_pic_order_cnt_lsb_minus4: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;sps.log2_max_pic_order_cnt_lsb_minus4)); uint32_t sps_sub_layer_ordering_info_present_flag = 0; // sps_sub_layer_ordering_info_present_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps_sub_layer_ordering_info_present_flag, 1)); for (uint32_t i = (sps_sub_layer_ordering_info_present_flag != 0) ? 0 : sps_max_sub_layers_minus1; i &lt;= sps_max_sub_layers_minus1; i++) { // sps_max_dec_pic_buffering_minus1: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;sps.sps_max_dec_pic_buffering_minus1[i])); // sps_max_num_reorder_pics: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // sps_max_latency_increase_plus1: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); } // log2_min_luma_coding_block_size_minus3: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;sps.log2_min_luma_coding_block_size_minus3)); // log2_diff_max_min_luma_coding_block_size: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;sps.log2_diff_max_min_luma_coding_block_size)); // log2_min_luma_transform_block_size_minus2: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // log2_diff_max_min_luma_transform_block_size: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // max_transform_hierarchy_depth_inter: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // max_transform_hierarchy_depth_intra: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // scaling_list_enabled_flag: u(1) uint32_t scaling_list_enabled_flag = 0; RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;scaling_list_enabled_flag, 1)); if (scaling_list_enabled_flag) { // sps_scaling_list_data_present_flag: u(1) uint32_t sps_scaling_list_data_present_flag = 0; RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps_scaling_list_data_present_flag, 1)); if (sps_scaling_list_data_present_flag) { // scaling_list_data() if (!ParseScalingListData(buffer)) { return OptionalSps(); } } } // amp_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(1)); // sample_adaptive_offset_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps.sample_adaptive_offset_enabled_flag, 1)); // pcm_enabled_flag: u(1) uint32_t pcm_enabled_flag = 0; RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;pcm_enabled_flag, 1)); if (pcm_enabled_flag) { // pcm_sample_bit_depth_luma_minus1: u(4) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(4)); // pcm_sample_bit_depth_chroma_minus1: u(4) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(4)); // log2_min_pcm_luma_coding_block_size_minus3: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // log2_diff_max_min_pcm_luma_coding_block_size: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;golomb_ignored)); // pcm_loop_filter_disabled_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(1)); } // num_short_term_ref_pic_sets: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;sps.num_short_term_ref_pic_sets)); sps.short_term_ref_pic_set.resize(sps.num_short_term_ref_pic_sets); for (uint32_t st_rps_idx = 0; st_rps_idx &lt; sps.num_short_term_ref_pic_sets; st_rps_idx++) { // st_ref_pic_set() OptionalShortTermRefPicSet ref_pic_set = ParseShortTermRefPicSet( st_rps_idx, sps.num_short_term_ref_pic_sets, sps.short_term_ref_pic_set, sps, buffer); if (ref_pic_set) { sps.short_term_ref_pic_set[st_rps_idx] = *ref_pic_set; } else { return OptionalSps(); } } // long_term_ref_pics_present_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps.long_term_ref_pics_present_flag, 1)); if (sps.long_term_ref_pics_present_flag) { // num_long_term_ref_pics_sps: ue(v) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadExponentialGolomb(&amp;sps.num_long_term_ref_pics_sps)); sps.used_by_curr_pic_lt_sps_flag.resize(sps.num_long_term_ref_pics_sps, 0); for (uint32_t i = 0; i &lt; sps.num_long_term_ref_pics_sps; i++) { // lt_ref_pic_poc_lsb_sps: u(v) uint32_t lt_ref_pic_poc_lsb_sps_bits = sps.log2_max_pic_order_cnt_lsb_minus4 + 4; RETURN_EMPTY_ON_FAIL(buffer-&gt;ConsumeBits(lt_ref_pic_poc_lsb_sps_bits)); // used_by_curr_pic_lt_sps_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps.used_by_curr_pic_lt_sps_flag[i], 1)); } } // sps_temporal_mvp_enabled_flag: u(1) RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;sps.sps_temporal_mvp_enabled_flag, 1)); // Far enough! We don't use the rest of the SPS. sps.vps_id = sps_video_parameter_set_id; sps.pic_width_in_luma_samples = pic_width_in_luma_samples; sps.pic_height_in_luma_samples = pic_height_in_luma_samples; // Start with the resolution determined by the pic_width/pic_height fields. sps.width = pic_width_in_luma_samples; sps.height = pic_height_in_luma_samples; if (conformance_window_flag) { int sub_width_c = ((1 == sps.chroma_format_idc) || (2 == sps.chroma_format_idc)) &amp;&amp; (0 == sps.separate_colour_plane_flag) ? 2 : 1; int sub_height_c = (1 == sps.chroma_format_idc) &amp;&amp; (0 == sps.separate_colour_plane_flag) ? 2 : 1; // the offset includes the pixel within conformance window. so don't need to // +1 as per spec sps.width -= sub_width_c * (conf_win_right_offset + conf_win_left_offset); sps.height -= sub_height_c * (conf_win_top_offset + conf_win_bottom_offset); } return OptionalSps(sps);}} // namespace webrtc common_video/h265/h265_sps_parser.h >folded#ifndef COMMON_VIDEO_H265_H265_SPS_PARSER_H_#define COMMON_VIDEO_H265_H265_SPS_PARSER_H_#include &lt;vector&gt;#include &quot;absl/types/optional.h&quot;namespace rtc {class BitBuffer;}namespace webrtc {// A class for parsing out sequence parameter set (SPS) data from an H265 NALU.class H265SpsParser { public: struct ShortTermRefPicSet { ShortTermRefPicSet(); uint32_t inter_ref_pic_set_prediction_flag = 0; std::vector&lt;uint32_t&gt; used_by_curr_pic_flag; std::vector&lt;uint32_t&gt; use_delta_flag; uint32_t num_negative_pics = 0; uint32_t num_positive_pics = 0; std::vector&lt;uint32_t&gt; delta_poc_s0_minus1; std::vector&lt;uint32_t&gt; used_by_curr_pic_s0_flag; std::vector&lt;uint32_t&gt; delta_poc_s1_minus1; std::vector&lt;uint32_t&gt; used_by_curr_pic_s1_flag; }; // The parsed state of the SPS. Only some select values are stored. // Add more as they are actually needed. struct SpsState { SpsState(); uint32_t sps_max_sub_layers_minus1; uint32_t chroma_format_idc = 0; uint32_t separate_colour_plane_flag = 0; uint32_t pic_width_in_luma_samples = 0; uint32_t pic_height_in_luma_samples = 0; uint32_t log2_max_pic_order_cnt_lsb_minus4 = 0; std::vector&lt;uint32_t&gt; sps_max_dec_pic_buffering_minus1; uint32_t log2_min_luma_coding_block_size_minus3 = 0; uint32_t log2_diff_max_min_luma_coding_block_size = 0; uint32_t sample_adaptive_offset_enabled_flag = 0; uint32_t num_short_term_ref_pic_sets = 0; std::vector&lt;H265SpsParser::ShortTermRefPicSet&gt; short_term_ref_pic_set; uint32_t long_term_ref_pics_present_flag = 0; uint32_t num_long_term_ref_pics_sps = 0; std::vector&lt;uint32_t&gt; used_by_curr_pic_lt_sps_flag; uint32_t sps_temporal_mvp_enabled_flag = 0; uint32_t width = 0; uint32_t height = 0; uint32_t id = 0; uint32_t vps_id = 0; }; // Unpack RBSP and parse SPS state from the supplied buffer. static absl::optional&lt;SpsState&gt; ParseSps(const uint8_t* data, size_t length); static bool ParseScalingListData(rtc::BitBuffer* buffer); static absl::optional&lt;ShortTermRefPicSet&gt; ParseShortTermRefPicSet( uint32_t st_rps_idx, uint32_t num_short_term_ref_pic_sets, const std::vector&lt;ShortTermRefPicSet&gt;&amp; ref_pic_sets, SpsState&amp; sps, rtc::BitBuffer* buffer); protected: // Parse the SPS state, for a bit buffer where RBSP decoding has already been // performed. static absl::optional&lt;SpsState&gt; ParseSpsInternal(rtc::BitBuffer* buffer);};} // namespace webrtc#endif // COMMON_VIDEO_H265_H265_SPS_PARSER_H_ common_video/h265/h265_vps_parser.cc >folded#include &lt;memory&gt;#include &lt;vector&gt;#include &quot;common_video/h265/h265_common.h&quot;#include &quot;common_video/h265/h265_vps_parser.h&quot;#include &quot;rtc_base/bit_buffer.h&quot;#include &quot;rtc_base/logging.h&quot;namespace {typedef absl::optional&lt;webrtc::H265VpsParser::VpsState&gt; OptionalVps;#define RETURN_EMPTY_ON_FAIL(x) \\ if (!(x)) { \\ return OptionalVps(); \\ }} // namespacenamespace webrtc {H265VpsParser::VpsState::VpsState() = default;// General note: this is based off the 06/2019 version of the H.265 standard.// You can find it on this page:// http://www.itu.int/rec/T-REC-H.265// Unpack RBSP and parse SPS state from the supplied buffer.absl::optional&lt;H265VpsParser::VpsState&gt; H265VpsParser::ParseVps( const uint8_t* data, size_t length) { std::vector&lt;uint8_t&gt; unpacked_buffer = H265::ParseRbsp(data, length); rtc::BitBuffer bit_buffer(unpacked_buffer.data(), unpacked_buffer.size()); return ParseInternal(&amp;bit_buffer);}absl::optional&lt;H265VpsParser::VpsState&gt; H265VpsParser::ParseInternal( rtc::BitBuffer* buffer) { // Now, we need to use a bit buffer to parse through the actual HEVC VPS // format. See Section 7.3.2.1 (&quot;Video parameter set RBSP syntax&quot;) of the // H.265 standard for a complete description. VpsState vps; // vps_video_parameter_set_id: u(4) vps.id = 0; RETURN_EMPTY_ON_FAIL(buffer-&gt;ReadBits(&amp;vps.id, 4)); return OptionalVps(vps);}} // namespace webrtc common_video/h265/h265_vps_parser.h >folded#ifndef COMMON_VIDEO_H265_H265_VPS_PARSER_H_#define COMMON_VIDEO_H265_H265_VPS_PARSER_H_#include &quot;absl/types/optional.h&quot;namespace rtc {class BitBuffer;}namespace webrtc {// A class for parsing out sequence parameter set (VPS) data from an H265 NALU.class H265VpsParser { public: // The parsed state of the VPS. Only some select values are stored. // Add more as they are actually needed. struct VpsState { VpsState(); uint32_t id = 0; }; // Unpack RBSP and parse VPS state from the supplied buffer. static absl::optional&lt;VpsState&gt; ParseVps(const uint8_t* data, size_t length); protected: // Parse the VPS state, for a bit buffer where RBSP decoding has already been // performed. static absl::optional&lt;VpsState&gt; ParseInternal(rtc::BitBuffer* bit_buffer);};} // namespace webrtc#endif // COMMON_VIDEO_H265_H265_VPS_PARSER_H_ å°†æ–°å¢žæ–‡ä»¶æ·»åŠ åˆ°ninjaä¸­å‚ä¸Žæž„å»ºï¼š if (rtc_use_h265) { sources += [ &quot;h265/h265_bitstream_parser.cc&quot;, &quot;h265/h265_bitstream_parser.h&quot;, &quot;h265/h265_common.cc&quot;, &quot;h265/h265_common.h&quot;, &quot;h265/h265_pps_parser.cc&quot;, &quot;h265/h265_pps_parser.h&quot;, &quot;h265/h265_sps_parser.cc&quot;, &quot;h265/h265_sps_parser.h&quot;, &quot;h265/h265_vps_parser.cc&quot;, &quot;h265/h265_vps_parser.h&quot;, ]} éƒ¨åˆ†é…ç½®ä¿®æ”¹ logé…ç½®ï¼š logging/rtc_event_log/encoder/rtc_event_log_encoder_new_format.ccrtclog2::FrameDecodedEvents::Codec ConvertToProtoFormat(VideoCodecType codec) { switch (codec) { ... case VideoCodecType::kVideoCodecH264: return rtclog2::FrameDecodedEvents::CODEC_H264;#ifndef DISABLE_H265 case VideoCodecType::kVideoCodecH265: return rtclog2::FrameDecodedEvents::CODEC_H265;#endif case VideoCodecType::kVideoCodecMultiplex: // This codec type is afaik not used. return rtclog2::FrameDecodedEvents::CODEC_UNKNOWN; } RTC_NOTREACHED(); return rtclog2::FrameDecodedEvents::CODEC_UNKNOWN;} logging/rtc_event_log/rtc_event_log2.protomessage FrameDecodedEvents { enum Codec { CODEC_UNKNOWN = 0; CODEC_GENERIC = 1; CODEC_VP8 = 2; CODEC_VP9 = 3; CODEC_AV1 = 4; CODEC_H264 = 5; CODEC_H265 = 6; } ...} ç›¸å…³å¸¸é‡ media/base/media_constants.ccconst char kHEVCCodecName[] = &quot;H265X&quot;;#ifndef DISABLE_H265const char kH265CodecName[] = &quot;H265&quot;;#endif// RFC 6184 RTP Payload Format for H.264 videoconst char kH264FmtpProfileLevelId[] = &quot;profile-level-id&quot;;const char kH264FmtpLevelAsymmetryAllowed[] = &quot;level-asymmetry-allowed&quot;;const char kH264FmtpPacketizationMode[] = &quot;packetization-mode&quot;;const char kH264FmtpSpropParameterSets[] = &quot;sprop-parameter-sets&quot;;const char kH264FmtpSpsPpsIdrInKeyframe[] = &quot;sps-pps-idr-in-keyframe&quot;;const char kH264ProfileLevelConstrainedBaseline[] = &quot;42e01f&quot;;const char kH264ProfileLevelConstrainedHigh[] = &quot;640c1f&quot;;#ifndef DISABLE_H265// RFC 7798 RTP Payload Format for H.265 videoconst char kH265FmtpProfileSpace[] = &quot;profile-space&quot;;const char kH265FmtpProfileId[] = &quot;profile-id&quot;;const char kH265FmtpTierFlag[] = &quot;tier-flag&quot;;const char kH265FmtpLevelId[] = &quot;level-id&quot;;#endif media/base/media_constants.hRTC_EXPORT extern const char kHEVCCodecName[];#ifndef DISABLE_H265RTC_EXPORT extern const char kH265CodecName[];#endif// RFC 6184 RTP Payload Format for H.264 videoRTC_EXPORT extern const char kH264FmtpProfileLevelId[];RTC_EXPORT extern const char kH264FmtpLevelAsymmetryAllowed[];RTC_EXPORT extern const char kH264FmtpPacketizationMode[];extern const char kH264FmtpSpropParameterSets[];extern const char kH264FmtpSpsPpsIdrInKeyframe[];extern const char kH264ProfileLevelConstrainedBaseline[];extern const char kH264ProfileLevelConstrainedHigh[];#ifndef DISABLE_H265// RFC 7798 RTP Payload Format for H.265 videoRTC_EXPORT extern const char kH265FmtpProfileSpace[];RTC_EXPORT extern const char kH265FmtpProfileId[];RTC_EXPORT extern const char kH265FmtpTierFlag[];RTC_EXPORT extern const char kH265FmtpLevelId[];#endifextern const int kDefaultVideoMaxFramerate; æœ€åŽæ‰“å¼€H265å¼€å…³BUILD.gnconfig(&quot;common_inherited_config&quot;) {... if (!rtc_use_h265) { defines += [ &quot;DISABLE_H265&quot; ] }} build_overrides/build.gniif (is_win || is_ios || is_android) { rtc_use_h265 = true} else { rtc_use_h265 = false} endæ¼«é•¿çš„ä¿®æ”¹åŽï¼ŒWebRTCå°†æ”¯æŒH265ï¼Œç¬”è€…åœ¨æµ‹è¯•H265ä¸ŽH264çš„åŒºåˆ«æ—¶ï¼Œå‘çŽ°JitterBufferCache å‡å°‘140msï¼Œæžœç„¶æ˜¯æ›´å¤æ‚çš„ç®—æ³•ã€æ›´é«˜çš„åŽ‹ç¼©çŽ‡ã€‚ å‚è€ƒï¼š owt-deps-webrtc","link":"/2022/09/29/Android%E5%B9%B3%E5%8F%B0WebRTC%E5%BC%80%E5%90%AFH265%E7%BC%96%E8%A7%A3%E7%A0%81/"},{"title":"Mixin","text":"å¯¹Dartä¸­Mixinçš„ç†è§£ Tipå½“ç„¶å¤šç»§æ‰¿ä¼šæœ‰å¾ˆå¤šä¸è¶³ä¹‹å¤„ï¼Œä¾‹å¦‚ï¼Œç»“æž„å¤æ‚åŒ–ï¼Œæœ‰é™é¡ºåºæ¨¡ç³Šï¼ŒåŠŸèƒ½å†²çªç­‰é—®é¢˜ï¼Œä¸¾ä¸€ä¸ªåˆ—å­ï¼š ä¸€ä¸ªç‰©ä½“çš„æœ¬è´¨åªèƒ½æœ‰ä¸€ä¸ªï¼Œä¸€ä¸ªåŠ¨ç‰©åªèƒ½æ˜¯ç‹—æˆ–è€…åªèƒ½æ˜¯çŒ«ï¼Œå¦‚æžœä½ æƒ³åˆ›é€ ä¸€ä¸ªä¼šçŽ©æ¯›çº¿çƒä¼šçŽ©æ¿€å…‰çš„ç‹—ï¼Œé‚£ä¹ˆåªéœ€åˆ›é€ ä¸€ä¸ªæè¿°è¿™ç±»è¡Œä¸ºçš„æŽ¥å£ï¼Œç„¶åŽåœ¨è‡ªå·±çš„ç±»é‡Œé¢å®žçŽ°â€çŽ©è€â€æŽ¥å£ï¼Œå…·ä½“å®žçŽ°è¿™äº›çŽ©çš„è¡Œä¸ºï¼Œæœ€ç»ˆä½ åŒæ ·ä¼šå¾—åˆ°ä¸€ä¸ªæ—¢åƒç‹—åˆåƒçŒ«çš„åŠ¨ç‰©ã€‚å¦‚æžœä½ æƒ³è®©è¿™ä¸ªåŠ¨ç‰©å«èµ·æ¥åƒçŒ«è€Œä¸æ˜¯ç‹—ï¼Œé‚£ä¹ˆé‡å†™å³å¯ï¼Œå­ç±»é‡Œé‡æ–°å®šä¹‰â€œå«â€è¿™ä¸ªè¡Œä¸ºå³å¯ã€‚ä½†æ— è®ºå¦‚ä½•ï¼Œè¿™æ ·å¾—åˆ°çš„ç±»æ˜¯ç»å¯¹ä¸ä¼šæœ‰å¤šé‡ç»§æ‰¿çš„å†²çªçš„ã€‚ å¯¹äºŽMixinå¹¶æ²¡æœ‰ä¸€ä¸ªå‡†ç¡®çš„æ¦‚å¿µï¼Œæœ‰äººç†è§£ä¸ºMix inæ··å…¥ã€‚å®ƒç±»ä¼¼äºŽå¤šç»§æ‰¿ï¼Œä½†é€šå¸¸æ··å…¥Mixinçš„ç±»å’ŒMixinç±»æœ¬èº«æ–Œé‚£ä¸ªä¸æ˜¯is-açš„å…³ç³»ã€‚å®žè´¨ä¸ŠMixinæ˜¯é€šè¿‡è¯­è¨€ç‰¹æ€§ï¼Œæ¥æ›´ç®€æ´åœ°å®žçŽ°ç»„åˆæ¨¡å¼ã€‚å› æ­¤ï¼ŒMixinå¯ä»¥çµæ´»åœ°æ·»åŠ æŸäº›åŠŸèƒ½ã€‚ä¼ ç»Ÿçš„æŽ¥å£æ¦‚å¿µä¸­ï¼Œå¹¶ä¸åŒ…å«å®žçŽ°éƒ¨åˆ†ï¼Œè€ŒMixinåŒ…å«å®žçŽ°ã€‚ åŸºæœ¬æ¦‚å¿µ Mixins in Strongtalkå»ºè®®äº†è§£ä¸€ä¸‹Mixinå­¦æœ¯æ–‡çŒ®èµ„æ–™ï¼Œå› ä¸ºå®ƒå®šä¹‰äº†é‡è¦æ¦‚å¿µå’Œæ³¨è§£ã€‚ æ³¨ï¼šSmalltalkè¢«å…¬è®¤åŽ†å²ä¸Šç¬¬äºŒä¸ªé¢å‘å¯¹è±¡çš„ç¨‹åºè®¾è®¡è¯­è¨€å’Œç¬¬ä¸€ä¸ªçœŸæ­£çš„é›†æˆå¼€å‘çŽ¯å¢ƒï¼ˆIDEï¼‰ã€‚å¹¶ä¸”å®ƒå¯¹å…¶å®ƒä¼—å¤šçš„ç¨‹åºè®¾è®¡è¯­è¨€çš„äº§ç”Ÿèµ·åˆ°äº†æžå¤§çš„æŽ¨åŠ¨ä½œç”¨ï¼Œä¸»è¦æœ‰ï¼šObjective-c,Actor,Javaå’ŒRubyç­‰ï¼Œ90å¹´ä»£çš„è®¸å¤šè½¯ä»¶å¼€å‘æ€æƒ³å¾—åˆ©äºŽSmalltalkï¼Œä¾‹å¦‚Design Patterns,Extreme Programming(XP)å’ŒRefactoringç­‰ã€‚Strongtalkçš„æœ€ç‹¬ç‰¹ä¹‹å¤„æ˜¯æ”¯æŒæ¸è¿›å¼çš„ç±»åž‹æ³¨è§£ï¼Œè¿™ç§æ€æƒ³åœ¨Dart,PHP,Python 3å’ŒTypeScriptç­‰è¯­è¨€ä¸­éƒ½æœ‰ä½“çŽ°ã€‚Gilad Brachaæ˜¯Dartå¼€å‘å›¢é˜Ÿçš„ä¸€å‘˜ï¼Œåœ¨20ä¸–çºª90å¹´ä»£ï¼ŒGiladåŒUrs HÃ¶lzleå’ŒLars Bakç­‰äººä¸€èµ·åˆ›å»ºäº†è¯­è¨€Smalltalkçš„ä¸€ä¸ªé«˜æ€§èƒ½ç‰ˆæœ¬å³Strongtalkã€‚ä½†éšç€Javaçš„æµè¡Œï¼ŒSunåœæ­¢äº†Strongtalkçš„æŠ•å…¥ï¼Œå¹¶å°†å›¢é˜Ÿæˆå‘˜é‡æ–°åˆ†é…æ¥ä¼˜åŒ–Javaçš„æ€§èƒ½ï¼Œè€ŒStrongtalkæ¼”å˜æˆäº†å®˜æ–¹JVMå³Hotspot. â€“ ç»´åŸºç™¾ç§‘ ä½œä¸ºä¸€ä¸ªæ”¯æŒç±»å’Œç»§æ‰¿çš„è¯­è¨€ï¼Œç±»éšå¼åœ°å®šä¹‰äº†Mixinã€‚Mixinéšå¼åœ°é€šè¿‡ç±»ä¸»ä½“ï¼ˆClass Bodyï¼‰è¿›è¡Œå®šä¹‰ï¼Œå¹¶å»ºç«‹å­ç±»å’Œçˆ¶ç±»ä¹‹é—´çš„å˜é‡å¢žé‡ï¼ˆDeltaï¼‰ã€‚è€ŒClassç±»å®žé™…ä¸Šåˆ™æ˜¯ä¸€ä¸ªMixinåº”ç”¨ï¼Œå³æ˜¯é€šè¿‡éšå¼å®šä¹‰çš„Mixinåº”ç”¨äºŽçˆ¶ç±»çš„ç»“æžœã€‚ Mixin Applicationæ··åˆåº”ç”¨ç±»ä¼¼äºŽFunction Applicationå‡½æ•°åº”ç”¨ã€‚åœ¨æ•°å­¦ä¸­ï¼Œæ··åˆç±»Må¯ä»¥è§†ä½œä»Žçˆ¶ç±»åˆ°å­ç±»æ–°å¢žçš„ä¸€ä¸ªåŠŸèƒ½ï¼Œå°†Mæ³¨å…¥è¶…ç±»Sï¼Œå¹¶ä¸”è¿”å›žä¸€ä¸ªSçš„å­ç±»ã€‚åœ¨ç ”ç©¶æ–‡çŒ®ä¸­ï¼Œè¿™é€šå¸¸å†™ä½œ M |&gt; Sã€‚ åŸºäºŽå‡½æ•°åº”ç”¨çš„æ¦‚å¿µï¼Œå¯ä»¥å®šä¹‰å¤åˆå‡½æ•°ï¼ˆå³å‡½æ•°ç»„åˆï¼‰ã€‚è¯¥æ¦‚å¿µè´¯ç©¿äºŽæ··åˆç»„åˆä¸­ã€‚æˆ‘ä»¬å®šä¹‰æ··åˆM1å’ŒM2çš„ç»„åˆï¼Œå†™ä½œM1*M2,å¦‚(M1 * M2) |&gt; S = M1 |&gt; (M2 |&gt; S)ã€‚ å‡½æ•°éžå¸¸æœ‰ç”¨ï¼Œå› ä¸ºä»–ä»¬å¯ä»¥åº”ç”¨äºŽä¸åŒçš„å‚æ•°ã€‚åŒæ ·ï¼ŒClasséšå¼å®šä¹‰çš„Mixinï¼Œé€šå¸¸ä»…åœ¨ç±»å£°æ˜Žç»™å‡ºçš„çˆ¶ç±»ä¸­åº”ç”¨ä¸€æ¬¡ã€‚ä¸ºå…è®¸Mixinåº”ç”¨äºŽä¸åŒçš„çˆ¶ç±»ï¼Œæˆ‘ä»¬è¦ä¹ˆå£°æ˜ŽMixinä¸ä¾èµ–äºŽç‰¹å®šçš„çˆ¶ç±»ï¼Œè¦ä¹ˆè„±ç¦»äºŽClasséšå¼çš„Mixinï¼Œç„¶åŽé‡ç”¨å¤–éƒ¨çš„åŽŸå§‹å®šä¹‰ã€‚ è¯­æ³•å’Œè¯­ä¹‰ Mixiné€šè¿‡æ­£å¸¸çš„ç±»å£°æ˜Žè¢«éšå¼å®šä¹‰ã€‚åŽŸåˆ™ä¸Šï¼Œæ¯ä¸ªç±»éƒ½å®šä¹‰äº†ä¸€ä¸ªMixinï¼Œå¹¶å¯ä»¥ä»Žç±»ä¸­æå–å‡ºæ¥ã€‚ç„¶è€Œï¼ŒMixinåªèƒ½ä»Žæœªå®šä¹‰æž„é€ å‡½æ•°çš„ç±»ä¸­æå–ã€‚ç”±äºŽæ²¿ç€ç»§æ‰¿é“¾ä¼ é€’æž„é€ å‡½æ•°å‚æ•°çš„éœ€è¦ï¼Œè¯¥çº¦æŸèƒ½é¿å…å‡ºçŽ°æ–°çš„è¿žé”é—®é¢˜ã€‚ ä¸¾ä¸€ä¸ªðŸŒ°: abstract class Collection&lt;E&gt; { Collection&lt;E&gt; newInstance(); void forEach(void f(E element)) { //body } void add(E element) { //body } //...}abstract class DOMElementList&lt;E&gt; = DOMList with Collection&lt;E&gt;;abstract class DOMElementSet&lt;E&gt; = DOMSet with Collection&lt;E&gt;; Collectionæ˜¯ä¸€ä¸ªæ ‡å‡†ç±»ï¼Œå¹¶ç”¨æ¥å£°æ˜Žä¸€ä¸ªMixinã€‚å¦å¤–ï¼ŒDOMElementListå’ŒDOMElementSetä¹Ÿæ˜¯æ··åˆåº”ç”¨ã€‚è¿™ä¸¤ä¸ªMixinåœ¨ç±»å£°æ˜Žçš„æ—¶å€™ï¼Œé€šè¿‡ç‰¹æ®Šçš„å½¢å¼æ¥å®šä¹‰ã€‚åœ¨ç±»å£°æ˜Žä¸­åŒ…å«ä¸€ä¸ªåå­—ï¼Œå¹¶ç”¨withè¯­å¥æ¥å£°æ˜Žä»–ä»¬ä¸Žçˆ¶ç±»ä¸­çš„æ··åˆåº”ç”¨ç›¸åŒã€‚**Collectionæ˜¯æŠ½è±¡ç±»ï¼Œå› ä¸ºå®ƒå¹¶æ²¡æœ‰å®žçŽ°ç±»ä¸­å¹´å®šä¹‰çš„æŠ½è±¡æ–¹æ³•newInstance()**ã€‚ ä¸Šè¿°ä¸­ï¼Œäº‹å®žä¸ŠDOMElementListæ··åˆCollection mixin |&gt; DOMListï¼Œè€ŒDOMElementSetåˆ™æ˜¯Collection mixin |&gt; DOMSetã€‚ è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼ŒCollectionä¸­çš„ä»£ç å¯ä»¥åœ¨ç±»çš„å¤šä¸ªç»§æ‰¿å±‚æ¬¡ä¸­è¢«å…±äº«ã€‚å› æ­¤ï¼Œæ— è®ºDOMListè¿˜æ˜¯DOMSetï¼Œéƒ½ä¸éœ€è¦é‡å¤ã€å¤åˆ¶Collectionä¸­çš„ä»£ç ï¼Œå¹¶ä¸”ä»»ä½•å˜åŒ–éƒ½ä¼šä½¿Collectionä¼ é€’åˆ°è¿™ä¸¤ä¸ªç»§æ‰¿ç»“æž„ä¸­ï¼Œå¤§å¤§ç®€åŒ–äº†ç»´æŠ¤ä»£ç ã€‚ä¸Šé¢çš„ä»£ç ä»‹ç»äº†Mixinåº”ç”¨çš„ä¸€ç§æ–¹å¼ï¼šæ··åˆåº”ç”¨æŒ‡å®šåº”ç”¨çš„Mixinå’Œçˆ¶ç±»ï¼Œä»¥åŠæ··åˆåº”ç”¨çš„åç§°ã€‚ å¦å¤–ä¸€ç§æƒ…å†µï¼Œæ··åˆåº”ç”¨å‡ºçŽ°åœ¨ç±»å£°æ˜Žçš„withè¯­å¥ä¸­ï¼Œä»¥é€—å·æ¥åˆ†éš”æ ‡è¯†ç¬¦åˆ—è¡¨çš„æ—¶å€™ã€‚æ­¤æ—¶ï¼Œæ‰€æœ‰çš„æ ‡è¯†ç¬¦ä»£è¡¨Classã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¤šæ··åˆåœ¨extendsè¯­å¥ä¸­å¯ä»¥æž„æˆåŠåº”ç”¨äºŽçˆ¶ç±»åç§°ï¼Œç”Ÿæˆä¸€ä¸ªåŒ¿åçš„çˆ¶ç±»ã€‚å†ä»¥åŒæ ·çš„ðŸŒ°ï¼š class DOMElementList&lt;E&gt; extends DOMList with Collection&lt;E&gt; { DOMElementList&lt;E&gt; newInstance() =&gt; new DOMElementList&lt;E&gt;();}class DOMElementList&lt;E&gt; extends DOMSet with Collection&lt;E&gt; { DOMElementSet&lt;E&gt; newInstance() =&gt; new DOMElementSet&lt;E&gt;();} è¿™é‡Œï¼ŒDOMElementListå¹¶ä¸æ˜¯åº”ç”¨Collection mixin |&gt; DOMListã€‚ç›¸åï¼Œå®ƒæ˜¯ä¸€ä¸ªçˆ¶ç±»ä¸ºåº”ç”¨çš„æ–°å®šä¹‰çš„ç±»ï¼ˆæ³¨æ„extendså…³é”®å­—ï¼‰ï¼ŒDOMElementSetåŒæ ·å¦‚æ­¤ã€‚æ³¨æ„ï¼Œåœ¨æ¯ä¸€ç§æƒ…å†µä¸‹ï¼ŒæŠ½è±¡å‡½æ•°newInstance()å¿…é¡»å•ç‹¬å®žçŽ°ï¼Œä»¥ä¾¿èƒ½å¤Ÿç›´æŽ¥è¢«å®žä¾‹åŒ–ã€‚ æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æžœDOMListæœ‰ä¸€ä¸ªå¸¦å‚æ•°çš„æž„é€ å‡½æ•°ï¼š class DOMElementList&lt;E&gt; extends DOMList with Collection&lt;E&gt; { DOMElementList&lt;E&gt; newInstance() =&gt; new DOMElementList&lt;E&gt;(0); DOMElementList(size):super(size);} æž„é€ å‡½æ•°å¯ä»¥ä¸ºå„ä¸ªå­—æ®µä»¥åŠæ³›åž‹å‚æ•°è®¾ç½®å€¼ã€‚æ¯ä¸ªMixinéƒ½æœ‰ä¸€ä¸ªè‡ªå®šä¹‰çš„æž„é€ å‡½æ•°è¢«å•ç‹¬è°ƒç”¨ï¼Œçˆ¶ç±»ä¹Ÿæ˜¯å¦‚æ­¤ã€‚å› ä¸ºMixinçš„æž„é€ å‡½æ•°ä¸èƒ½å¤Ÿè¢«å£°æ˜Žï¼Œæ‰€ä»¥è°ƒç”¨å‡½æ•°å¯ä»¥çœç•¥ã€‚åœ¨åº•å±‚çš„å®žçŽ°ä¸­ï¼Œè°ƒç”¨æ€»æ˜¯æ”¾åœ¨åˆå§‹åˆ—è¡¨ä¹‹å‰ã€‚ ç¬¬äºŒç§æ˜¯ä»¥æ–¹ä¾¿å®žç”¨çš„è¯­æ³•ç³–å½¢å¼ï¼Œå°†å¤šä¸ªMixinæ··å…¥ç±»ä¸­ï¼Œè€Œä¸éœ€è¦å¼•å…¥å¤šä¸ªä¸­é—´å£°æ˜Žã€‚ä¸¾ä¸€ä¸ªðŸŒ°ï¼š class Person { String name; Person(this.name);}class Maestro extends Person with Musical, Aggressive, Demented { Maestro(name):super(name);} è¿™é‡Œï¼Œçˆ¶ç±»æ˜¯ä¸€ä¸ªæ··åˆåº”ç”¨ï¼šDemented mixin |&gt; Aggressive mixin |&gt; Musical mixin |&gt; Person å‡è®¾Personæœ‰å¸¦å‚æ•°çš„æž„é€ å‡½æ•°ï¼Œåˆ™Musical mixin |&gt; Personå°†ç»§æ‰¿Personçš„æž„é€ å‡½æ•°ã€‚ä»¥æ­¤ç±»æŽ¨ï¼Œä¸€ç›´åˆ°Maestroå®žé™…çš„çˆ¶ç±»Personï¼Œå®ƒç”±ä¸€ç³»åˆ—çš„Mixinåº”ç”¨ç»„æˆã€‚ ç»†èŠ‚æè¿° Privacyç§æœ‰ ä¸€ä¸ªæ··åˆåº”ç”¨å¾ˆå¯èƒ½æ˜¯å’‹å¤–éƒ¨æœ€åˆå£°æ˜ŽClassçš„åº“ä¸­è¢«å£°æ˜Žï¼Œè¿™å¯¹è®¿é—®æ··åˆåº”ç”¨çš„æˆå‘˜æ²¡æœ‰ä»»ä½•å½±å“ã€‚æ ¹æ®æ··åˆåº”ç”¨çš„è¯­ä¹‰å¯çŸ¥ï¼Œè®¿é—®æˆå‘˜å–å†³äºŽåº“æœ€åˆå£°æ˜Žçš„ä½ç½®ã€‚è¿™ä¸Žæ™®é€šçš„ç»§æ‰¿ä¸€æ ·ï¼Œæ˜¯ç”±åº•å±‚è¯­æ³•ï¼ˆC++ï¼‰çš„ç»§æ‰¿è¯­ä¹‰å†³å®šçš„ã€‚ Staticsé™æ€ æ˜¯å¦å¯ä»¥é€šè¿‡æ··åˆåº”ç”¨ä½¿ç”¨æœ€åˆClassçš„é™æ€å€¼ï¼ŸåŒæ ·ï¼Œç”±ç»§æ‰¿çš„è¯­ä¹‰è¿›è¡Œåˆ†æžï¼Œåœ¨Dartä¸­é™æ€æˆå‘˜ä¸ä¼šè¢«ç»§æ‰¿ã€‚ Typesç±»åž‹ æ··åˆåº”ç”¨çš„å®žä¾‹æ˜¯ä»€ä¹ˆç±»åž‹ï¼Ÿé€šå¸¸ï¼Œå®ƒæ˜¯çˆ¶ç±»çš„å­ç±»åž‹ï¼Œä»¥åŠé€šè¿‡Mixinåç§°è¡¨ç¤ºçš„å­ç±»åž‹ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒä¸Žæœ€åˆClassçš„ç±»åž‹ç›¸åŒã€‚ æœ€åˆçš„Classæœ‰å®ƒè‡ªèº«çš„çˆ¶ç±»ã€‚ä¸ºç¡®ä¿ç‰¹å®šçš„æ··åˆåº”ç”¨ä¸Žæœ€åˆè¿›è¡Œæ··å…¥çš„Classå…¼å®¹ï¼Œéœ€è¦ä½¿ç”¨withè¯­å¥ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœé€šè¿‡withè¯­å¥å®šä¹‰äº†Class Aï¼Œå¹¶åº”ç”¨äº†ä¸€ä¸ªæ··åˆMï¼ŒMæºè‡ªClass Kï¼Œé‚£ä¹ˆAå¿…é¡»æ”¯æŒKå®šä¹‰çš„æŽ¥å£ã€‚","link":"/2019/07/25/Mixin/"},{"title":"Task :app:compileDebugJavaWithJavac Failedå¤„ç†","text":"ä»Šå¤©é‡åˆ°äº†Task :app:compileDebugJavaWithJavac FAILEDé—®é¢˜ï¼Œç½‘ä¸Šç­”æ¡ˆå¾ˆæ‚ï¼Œè§£å†³ä»¥åŽæ€»ç»“ä¸€ä¸‹ã€‚ è¯¥é—®é¢˜åŸºæœ¬ç”±äºŽgradleç¼–è¯‘å¯¼è‡´ï¼Œå¯ä»¥ç”¨ $ gradlew compileDebug --stacktrace æ¥è·Ÿè¸ªgradleç¼–è¯‘æ—¶çš„stacktraceä¿¡æ¯ï¼Œå¦‚æžœå‡ºçŽ°-bash: ./gradlew: Permission deniedé”™è¯¯ï¼Œå¯ä»¥è¾“å…¥ $ chmod +x gradlew æ¥è§£å†³æƒé™é—®é¢˜ï¼Œä¸è¿‡gradlew comileDebug å¹¶ä¸èƒ½çœ‹åˆ°æœ‰ä»·å€¼çš„ä¿¡æ¯ï¼Œæ ¹æ®æç¤ºï¼Œè¾“å…¥ $ gradlew compileDebugSources --stacktrace -info è§£å†³é—®é¢˜ï¼ŒåŽŸæ¥æ˜¯æŸä¸ª.javaæ–‡ä»¶æ²¡pushå¯¼è‡´ã€‚","link":"/2018/05/09/Task-app-compileDebugJavaWithJavac-Failed%E5%A4%84%E7%90%86/"},{"title":"WindowManagerçª—å£ç®¡ç†","text":"WindowManagerç›¸å…³å±žæ€§æ±‡æ€» WindowManagerçª—å£ç®¡ç†WindowManageræ˜¯androidçš„çª—å£ç®¡ç†å™¨ï¼Œæ‰€æœ‰æ˜¾ç¤ºçª—å£éƒ½å¯ä»¥é€šè¿‡å®ƒæ¥æŽ§åˆ¶ WindowManager.addView(view,layoutParams) æ·»åŠ ä¸€ä¸ªviewåˆ°çª—å£ä¸­ WindowManager.updateView(view,layoutParams) æ›´æ–°çª—å£ä¸­çš„viewå±žæ€§ WindowManager.removeView(view) åˆ é™¤çª—å£ä¸­çš„View WindowManager.LayoutParamsèŽ·å–å¸ƒå±€å‚æ•° WindowManager.LayoutParams params = getWindow().getAttributes(); åˆ›å»ºå¸ƒå±€å‚æ•° WindowManager.LayoutParams params = new WindowManager.LayoutParams(); WindowManager.LayoutParams.typeç”¨äºŽç¡®å®šçª—å£åœ¨å±å¹•ä¸Šçš„æ˜¾ç¤ºå±‚æ¬¡ FIRST_APPLICATION_WINDOW æ™®é€šåº”ç”¨çš„ç¬¬ä¸€ä¸ªçª—å£ TYPE_BASE_APPLICATION ä½œä¸ºæ‰€æœ‰åº”ç”¨åŸºç¡€çš„çª—å£, å…¶ä»–åº”ç”¨çª—å£éƒ½åœ¨å…¶ä¸Š TYPE_APPLICATION æ™®é€šåº”ç”¨çª—å£. tokenå¿…é¡»ä¸ºActivityçš„token, æŒ‡æ˜Žè¯¥çª—å£å±žäºŽè° TYPE_APPLICATION_STARTING åº”ç”¨å¯åŠ¨æ—¶æ˜¾ç¤ºçš„çª—å£. ç”¨äºŽç³»ç»Ÿåœ¨åº”ç”¨èƒ½å¤Ÿæ˜¾ç¤ºä¹‹å‰æ˜¾ç¤ºä¸€äº›ä¸œè¥¿ LAST_APPLICATION_WINDOW åº”ç”¨æœ€åŽä¸€ç§çª—å£ç±»åž‹ FIRST_SUB_WINDOW å­çª—å£ TYPE_APPLICATION_PANEL åœ¨åº”ç”¨çª—å£ä¹‹ä¸Šçš„é¢æ¿çª—å£, å‡ºçŽ°åœ¨æ‰€ä¾é™„çš„çª—å£ä¹‹ä¸Š TYPE_APPLICATION_MEDIA æ˜¾ç¤ºåª’ä½“(å¦‚è§†é¢‘)çš„çª—å£, åœ¨ä»–ä»¬ä¾é™„çš„çª—å£ä¹‹ä¸‹æ˜¾ç¤º TYPE_APPLICATION_SUB_PANEL åº”ç”¨çª—å£ä¹‹ä¸Šçš„å­é¢æ¿çª—å£, æ˜¾ç¤ºåœ¨æ‰€ä¾é™„çš„çª—å£å’Œå…¶ä»–é¢æ¿ä¹‹ä¸Š TYPE_APPLICATION_ATTACHED_DIALOG ç±»ä¼¼TYPE_APPLICATION_PANEL, ä½†ä¼šä½œä¸ºé¡¶å±‚çª—å£, è€Œä¸æ˜¯å®¹å™¨çš„å­çª—å£ TYPE_APPLICATION_MEDIA_OVERLAY éšè—åœ¨åª’ä½“çª—å£ä¸Šæ˜¾ç¤ºè¦†ç›–å±‚çš„çª—å£,æ˜¾ç¤ºåœ¨TYPE_APPLICATION_MEDIAå’Œåº”ç”¨çª—å£ä¹‹é—´ TYPE_APPLICATION_ABOVE_SUB_PANEL ä¸€ä¸ªå­é¢æ¿çª—å£, åœ¨åº”ç”¨çª—å£å’Œå­é¢æ¿çª—å£ä¹‹ä¸Š LAST_SUB_WINDOW æœ€åŽä¸€ä¸ªå­çª—å£ FIRST_SYSTEM_WINDOW ç¬¬ä¸€ä¸ªç³»ç»Ÿçª—å£ TYPE_STATUS_BAR çŠ¶æ€æ ,åªèƒ½æœ‰ä¸€ä¸ªçŠ¶æ€æ çª—å£. æ”¾ç½®åœ¨å±å¹•ä¸Šæ–¹, å…¶ä»–æ‰€æœ‰çª—å£éƒ½åœ¨å…¶ä¹‹ä¸‹ TYPE_SEARCH_BAR æœç´¢æ¡,åªèƒ½æœ‰ä¸€ä¸ªæœç´¢æ¡çª—å£, æ”¾ç½®åœ¨å±å¹•é¡¶å±‚ TYPE_PHONE ç”µè¯çª—å£,è¿™æ˜¯éžåº”ç”¨çª—å£, ç”¨äºŽæ¥ç”µçš„ç•Œé¢,è¯¥çª—å£é€šå¸¸ç½®äºŽæ‰€æœ‰åº”ç”¨ä¹‹ä¸Š, ä½†åœ¨çŠ¶æ€æ ä¸‹ TYPE_SYSTEM_ALERT ç³»ç»Ÿçª—å£, ä¾‹å¦‚ä½Žç”µé‡è­¦å‘Šå¼¹çª—, åœ¨åº”ç”¨çª—å£ä¹‹ä¸Š TYPE_KEYGUARD é”å±çª—å£ TYPE_TOAST é€æ˜Žé€šçŸ¥. ä¸ä¼šæ‹¦æˆªè§¦æ‘¸äº‹ä»¶, å¯ä»¥å‘ä¸‹é€ä¼  TYPE_SYSTEM_OVERLAY ç³»ç»Ÿè¦†ç›–çª—å£, åœ¨æ‰€æœ‰ä¸œè¥¿ä¹‹ä¸Š. è¯¥çª—å£å¿…é¡»ç¦æ­¢èŽ·å–è¾“å…¥ç„¦ç‚¹, å¦åˆ™ä¼šå˜æˆé”å± TYPE_PRIORITY_PHONE ä¼˜å…ˆçº§ç”µè¯, å³ä½¿é”å±ä¹Ÿä¼šæ˜¾ç¤º,è¯¥çª—å£å¿…é¡»ç¦æ­¢èŽ·å–è¾“å…¥ç„¦ç‚¹, å¦åˆ™ä¼šå˜æˆé”å± TYPE_SYSTEM_DIALOG çŠ¶æ€æ æ‹‰å‡ºçš„é¢æ¿ TYPE_KEYGUARD_DIALOG é”å± TYPE_SYSTEM_ERROR ç³»ç»Ÿé”™è¯¯çª—å£, åœ¨æ‰€æœ‰å†…å®¹ä¹‹ä¸Š TYPE_INPUT_METHOD è¾“å…¥æ³•çª—å£, åœ¨æ™®é€šUIä¹‹ä¸Šï¼Œå¯ä»¥ç¼©æ”¾ TYPE_INPUT_METHOD_DIALOG è¾“å…¥æ³•å¯¹è¯æ¡†çª—å£, åœ¨å½“å‰è¾“å…¥æ³•çª—å£ä¹‹ä¸Š TYPE_WALLPAPER å£çº¸çª—å£, åœ¨ä»»æ„çª—å£ä¹‹ä¸‹, å£çº¸ä¹‹ä¸Š TYPE_STATUS_BAR_PANEL çŠ¶æ€æ æ‹‰å‡ºçš„é¢æ¿ TYPE_SECURE_SYSTEM_OVERLAY å®‰å…¨çš„ç³»ç»Ÿè¦†ç›–çª—å£, åœ¨æ‰€æœ‰å†…å®¹ä¹‹ä¸Šï¼Œå¿…é¡»ç¦æ­¢èŽ·å–è¾“å…¥ç„¦ç‚¹, å¦åˆ™ä¼šå˜æˆé”å±ï¼ŒåŒTYPE_SYSTEM_OVERLAYç±»ä¼¼, åŒºåˆ«æ˜¯åªå…è®¸ç³»ç»Ÿåˆ›å»ºè¿™ç§è¦†ç›–å±‚,ï¼Œåº”ç”¨æ— æ³•åˆ›å»º TYPE_DRAG æ‹–æ‹½çª—å£ï¼Œæœ€å¤šæœ‰ä¸€ä¸ª, åœ¨æ‰€æœ‰çª—å£ä¹‹ä¸Š TYPE_STATUS_BAR_SUB_PANEL çŠ¶æ€æ æ‹‰å‡ºçš„é¢æ¿, åœ¨çŠ¶æ€æ ä¹‹ä¸‹ TYPE_POINTER é¼ æ ‡æŒ‡é’ˆ TYPE_NAVIGATION_BAR å¯¼èˆªæ¡ TYPE_VOLUME_OVERLAY è°ƒæ•´éŸ³é‡æ—¶æ˜¾ç¤ºçš„éŸ³é‡çª—å£ TYPE_BOOT_PROGRESS éšè—ï¼Œå¯åŠ¨è¿›åº¦å¯¹è¯æ¡†, åœ¨å…¨å±€ä»»ä½•äº‹ç‰©ä¹‹ä¸Š TYPE_INPUT_CONSUMER æ¶ˆè´¹è¾“å…¥äº‹ä»¶çš„çª—å£ TYPE_DREAM éšè—ï¼Œå±ä¿çª—å£, åœ¨é”å±ä¹‹ä¸Š TYPE_NAVIGATION_BAR_PANEL å¯¼èˆªæ¡é¢æ¿ TYPE_DISPLAY_OVERLAY æ˜¾ç¤ºè¦†ç›–çª—å£, ç”¨äºŽæ¨¡æ‹Ÿç¬¬äºŒä¸ªæ˜¾ç¤ºè®¾å¤‡ TYPE_MAGNIFICATION_OVERLAY æ”¾å¤§è¦†ç›–çª—å£ï¼Œç”¨äºŽçªå‡ºæ”¾å¤§çš„éƒ¨åˆ† TYPE_KEYGUARD_SCRIM éšè—ï¼Œé”å±scrimçª—å£, å½“é”å±éœ€è¦é‡å¯æ—¶æ˜¾ç¤º TYPE_PRIVATE_PRESENTATION Presentationçª—å£ TYPE_VOICE_INTERACTION éšè—ï¼Œè¯­éŸ³äº’åŠ¨çª—å£ TYPE_ACCESSIBILITY_OVERLAY è¾…åŠ©åŠŸèƒ½è¦†ç›–å±‚ TYPE_VOICE_INTERACTION_STARTING éšè—ï¼Œè¯­éŸ³äº’åŠ¨å¼€å§‹çª—å£ TYPE_DOCK_DIVIDER éšè—ï¼Œæ‰˜ç›˜çª—å£, ä»…ç³»ç»Ÿè¿›ç¨‹æ‹¥æœ‰ TYPE_QS_DIALOG ç±»ä¼¼TYPE_APPLICATION_ATTACHED_DIALOG, ä½†ç”¨äºŽå¿«é€Ÿè®¾ç½® TYPE_SCREENSHOT éšè—ï¼ŒåŒTYPE_DREAMç±»ä¼¼, ä½†ç”¨äºŽæˆªå± WindowManager.LayoutParams.flagsç”¨äºŽç¡®å®šçª—å£çš„è¡Œä¸º FLAG_ALLOW_LOCK_WHILE_SCREEN_ON å½“çª—å£å¯¹ç”¨æˆ·å¯è§æ—¶, å…è®¸é”å±.å¯ä»¥å•ç‹¬ä½¿ç”¨, ä¹Ÿå¯ä»¥å’ŒFLAG_KEEP_SCREEN_ONå’ŒFLAG_SHOW_WHEN_LOCKEDç»“åˆä½¿ç”¨ FLAG_DIM_BEHIND è¯¥çª—å£ä»¥ä¸‹çš„å†…å®¹éƒ½ä¼šå˜æš—,å¯ä»¥ä½¿ç”¨dimAmountæ¥æŽ§åˆ¶å˜æš—çš„ç¨‹åº¦ FLAG_BLUR_BEHIND å¤±æ•ˆäº†, ä¸å†æ”¯æŒ,è¯¥çª—å£ä»¥ä¸‹çš„å†…å®¹éƒ½ä¼šæ¨¡ç³Š FLAG_NOT_FOCUSABLE è¯¥çª—å£ä¸å¯èŽ·å–æŒ‰é”®è¾“å…¥ç„¦ç‚¹, å› æ­¤ç”¨æˆ·æ— æ³•å‘å…¶å‘é€æŒ‰é”®æˆ–æŒ‰é’®äº‹ä»¶. è¿™äº›äº‹ä»¶ä¼šè¢«çª—å£ä»¥ä¸‹çš„æŽ§ä»¶èŽ·å–.,è¯¥flagåŒæ—¶ä¼šå¯åŠ¨FLAG_NOT_TOUCH_MODAL,æ— è®ºä½ æ˜¯å¦æ˜¾å¼çš„è®¾ç½®,è®¾ç½®è¯¥flagåŒæ—¶æš—ç¤ºç€,è¯¥çª—å£ä¸å†éœ€è¦åŒè¾“å…¥æ³•äº¤äº’,å› æ­¤è¯¥çª—å£å’Œè¾“å…¥æ³•çª—å£ä¼šä»¥Zè½´æ–¹å¼å æ”¾ä¸€èˆ¬è¯¥çª—å£ä¼šè¦†ç›–åœ¨è¾“å…¥æ³•çª—å£ä¹‹ä¸Š),å¯ä»¥ä½¿ç”¨FLAG_ALT_FOCUSABLE_IMæ¥ä¿®æ”¹è¿™ä¸ªè¡Œä¸º FLAG_NOT_TOUCHABLE è¯¥çª—å£ä¸å¯æŽ¥æ”¶ä»»ä½•è§¦æ‘¸äº‹ä»¶ FLAG_NOT_TOUCH_MODAL å…è®¸ä»»ä½•åœ¨è¯¥çª—å£ä¹‹å¤–çš„è§¦æ‘¸äº‹ä»¶ä¼ é€’åˆ°è¯¥çª—å£ä»¥ä¸‹çš„æŽ§ä»¶, å³ä½¿è¯¥çª—å£æ˜¯focusableçš„(å³æ²¡æœ‰è®¾ç½®FLAG_NOT_FOCUSABLE).å¦åˆ™è¯¥çª—å£ä¼šæ¶ˆè´¹æ‰€æœ‰çš„è§¦æ‘¸äº‹ä»¶, æ— è®ºè§¦æ‘¸æ˜¯å¦åœ¨çª—å£ä¹‹å†… FLAG_TOUCHABLE_WHEN_WAKING å·²ç»è¿‡æ—¶, çŽ°åœ¨æ²¡æœ‰ä»»ä½•æ•ˆæžœ,å¦‚æžœè®¾å¤‡å¤„äºŽç¡çœ ä¸­, æ­¤æ—¶ç¬¬ä¸€æ¬¡ç‚¹å‡»å±å¹•çš„äº‹ä»¶å°†ä¼šè¢«è¯¥çª—å£æŽ¥æ”¶,é€šå¸¸ç¬¬ä¸€æ¬¡è§¦æ‘¸äº‹ä»¶ä¼šè¢«ç³»ç»Ÿæ¶ˆè´¹,å› ä¸ºç”¨æˆ·æ— æ³•çœ‹è§ä»–ä»¬ç‚¹å‡»çš„æ˜¯ä»€ä¹ˆ FLAG_KEEP_SCREEN_ON å½“çª—å£å¯¹äºŽç”¨æˆ·å¯è§æ—¶, ä¿æŒè®¾å¤‡å±å¹•å¸¸äº® FLAG_LAYOUT_IN_SCREEN å°†çª—å£æ”¾ç½®åœ¨æ•´ä¸ªå±å¹•ä¸­,å¿½ç•¥çŠ¶æ€æ ç­‰å‘¨è¾¹è£…é¥°è¾¹æ¡†.,çª—å£å†…å®¹å¿…é¡»å®šä½æ­£ç¡®,æ‰èƒ½èŽ·å–åˆ°è£…é¥°è¾¹æ¡†ä¿¡æ¯ FLAG_LAYOUT_NO_LIMITS å…è®¸çª—å£æ‰©å±•åˆ°å±å¹•ä¹‹å¤– FLAG_FULLSCREEN å½“è¯¥çª—å£æ˜¾ç¤ºæ—¶, éšè—æ‰€æœ‰å±å¹•è£…é¥°(å¦‚çŠ¶æ€æ ),å…è®¸çª—å£ä½¿ç”¨æ•´ä¸ªå±å¹•,å½“å¸¦æœ‰è¯¥flagçš„çª—å£æ˜¯é¡¶å±‚çª—å£æ—¶, çŠ¶æ€æ ä¼šè¢«éšè—,å…¨å±çª—å£ä¼šå¿½ç•¥SOFT_INPUT_ADJUST_RESIZEå¯¹äºŽsoftInputModeçš„å€¼,çª—å£ä¼šä¸€ç›´ä¿æŒå…¨å±, ä¸”ä¸èƒ½ç¼©æ”¾å¯ä»¥é€šè¿‡themeå±žæ€§æ¥æŽ§åˆ¶, å¦‚Theme_Black_NoTitleBar_Fullscreenç­‰ FLAG_FORCE_NOT_FULLSCREEN è¦†ç›–FLAG_FULLSCREEN, å¹¶å¼ºåˆ¶æ˜¾ç¤ºå±å¹•è£…é¥°(å¦‚çŠ¶æ€æ ) FLAG_DITHER è¿‡æ—¶, ä¸å†ä½¿ç”¨,å¼€å¯å›¾åƒæŠ–åŠ¨ FLAG_SECURE å°†çª—å£å†…å®¹ä½œä¸ºå®‰å…¨å†…å®¹, é˜»æ­¢çª—å£å‡ºçŽ°åœ¨æˆªå±, æˆ–æ˜¯è¢«ä¸å®‰å…¨çš„æ˜¾ç¤ºå™¨æ˜¾ç¤º FLAG_SCALED å¯ä»¥æ ¹æ®å¸ƒå±€å‚æ•°è¿›è¡Œæ‹‰ä¼¸ FLAG_IGNORE_CHEEK_PRESSES ç”¨äºŽåœ¨ç”¨æˆ·å°†å±å¹•è´´è¿‘è„¸éƒ¨æ—¶, é˜²æ­¢è¯¯æŒ‰ FLAG_LAYOUT_INSET_DECOR ä»…åŒFLAG_LAYOUT_IN_SCREENä¸€èµ·ä½¿ç”¨.çª—å£å¯èƒ½å‡ºçŽ°åœ¨è£…é¥°ä¸‹é¢(å¦‚çŠ¶æ€æ ä¸‹é¢),ä½¿ç”¨è¿™ä¸ªflagåŽ, çª—å£ä¼šç¡®ä¿ä¸ä¼šè¢«è£…é¥°ç‰©è¦†ç›– FLAG_ALT_FOCUSABLE_IM åè½¬FLAG_NOT_FOCUSABLEçš„äº¤äº’çŠ¶æ€.å³, å¦‚æžœåŒæ—¶è®¾ç½®äº†æœ¬flagå’ŒFLAG_NOT_FOCUSABLE,åˆ™çª—å£è¡¨çŽ°ä¸ºéœ€è¦åŒè¾“å…¥æ³•äº¤äº’,åŒæ—¶ä¼šè¢«è‡³äºŽè¾“å…¥æ³•ä¹‹ä¸‹,å¦‚æžœè®¾ç½®äº†æœ¬flagè€Œæ²¡æœ‰è®¾ç½®FLAG_NOT_FOCUSABLE, åˆ™çª—å£è¡¨çŽ°ä¸ºä¸éœ€è¦åŒè¾“å…¥æ³•äº¤äº’, åŒæ—¶ä¼šè¢«è‡³äºŽè¾“å…¥æ³•ä¹‹ä¸Š FLAG_WATCH_OUTSIDE_TOUCH å¦‚æžœè®¾ç½®äº†FLAG_NOT_TOUCH_MODAL,é‚£ä¹ˆå¯ä»¥åŒæ—¶è®¾ç½®æ­¤flagæ¥æŽ¥æ”¶çª—å£ä¹‹å¤–å‘ç”Ÿçš„MotionEvent.ACTION_OUTSIDEäº‹ä»¶.æ³¨æ„, ä½ ä¸ä¼šæŽ¥æ”¶åˆ°å®Œæ•´çš„down/move/upæ‰‹åŠ¿,åªä¼šæŽ¥æ”¶åˆ°æŒ‰ä¸‹ä½ç½®çš„ACTION_OUTSIDEäº‹ä»¶ FLAG_SHOW_WHEN_LOCKED å½“é”å±æ—¶, å…è®¸çª—å£æ˜¾ç¤º,çª—å£ä¼˜å…ˆäºŽé”å±,å¯ä»¥åŒFLAG_KEEP_SCREEN_ONä¸€èµ·ä½¿ç”¨,æ¥ä¿æŒå±å¹•å¸¸äº®å¹¶åœ¨æ˜¾ç¤ºé”å±ä¹‹å‰æ˜¾ç¤ºè¯¥çª—å£,å¯ä»¥åŒFLAG_DISMISS_KEYGUARDä¸€èµ·ä½¿ç”¨,æ¥å–æ¶ˆéžå®‰å…¨çš„é”å±,è¯¥flagåªèƒ½åº”ç”¨äºŽæœ€é¡¶å±‚çš„å…¨å±çª—å£ FLAG_SHOW_WALLPAPER è¦æ±‚ç³»ç»Ÿå£çº¸æ˜¾ç¤ºåœ¨çª—å£ä¹‹ä¸‹,çª—å£å¿…é¡»æ˜¯é€æ˜Žçš„, æ‰å¯ä»¥çœ‹åˆ°å£çº¸,è¯¥flagåªä¿è¯å£çº¸å­˜åœ¨,å¯ä»¥é€šè¿‡themeå±žæ€§æ¥è®¾ç½®,å¦‚Theme_Wallpaper_NoTitleBarç­‰ FLAG_TURN_SCREEN_ON å½“çª—å£è¢«æ·»åŠ æˆ–ä»Žä¸å¯è§åˆ°å¯è§çŠ¶æ€æ—¶, ä¼šç‚¹äº®å±å¹• FLAG_DISMISS_KEYGUARD ç¦ç”¨é”å±,é™¤éžæ˜¯éžå®‰å…¨é”å±,ä¸ŽFLAG_SHOW_WHEN_LOCKEDæ­£ç›¸å,å¦‚æžœé”å±å½“å‰æ˜¯æ¿€æ´»çš„,å¹¶ä¸”æ˜¯å®‰å…¨é”å±(éœ€è¦è§£é”çš„),é‚£ä¹ˆç”¨æˆ·ä»éœ€è¦è¿›è¡Œè§£é”æ‰èƒ½çœ‹åˆ°çª—å£,é™¤éžè®¾ç½®äº†FLAG_SHOW_WHEN_LOCKED FLAG_SPLIT_TOUCH çª—å£ä¼šæŽ¥æ”¶çª—å£ä¹‹å¤–çš„å¤šç‚¹è§¦æ‘¸äº‹ä»¶ FLAG_HARDWARE_ACCELERATED å¯¹çª—å£å¯ç”¨ç¡¬ä»¶åŠ é€Ÿ FLAG_LAYOUT_IN_OVERSCAN å…è®¸çª—å£æ‰©å±•åˆ°overscanåŒºåŸŸ FLAG_TRANSLUCENT_STATUS è¦æ±‚çŠ¶æ€æ é€æ˜Ž FLAG_TRANSLUCENT_NAVIGATION è¦æ±‚å¯¼èˆªæ é€æ˜Ž FLAG_LOCAL_FOCUS_MODE å…è®¸ç‹¬ç«‹äºŽwindow manageræ¥æŽ§åˆ¶ç„¦ç‚¹äº‹ä»¶,é€šå¸¸è¯¥æ¨¡å¼çš„çª—å£ä¸èƒ½ä»Žwindow managerèŽ·å–è§¦æ‘¸/æŒ‰é”®äº‹ä»¶, ä½†èƒ½å¤Ÿé€šè¿‡Window#injectInputEvent(InputEvent)æ¥èŽ·å–æœ¬åœ°æ³¨å…¥äº‹ä»¶ FLAG_SLIPPERY éšè—,å…è®¸è§¦æ‘¸ä»Žä¸€ä¸ªçª—å£åˆ’å‡ºåˆ°å¦ä¸€ä¸ªçª—å£,è¯¥flagä»…å¯¹å½“å‰çª—å£ç”Ÿæ•ˆ,è§¦æ‘¸å¯ä»¥åˆ’å‡º, ä½†æ— æ³•å†åˆ’å…¥ FLAG_LAYOUT_ATTACHED_IN_DECOR å½“å¸ƒå±€ä¾é™„äºŽçª—å£æ—¶, æ‰€ä¾é™„çš„çª—å£å¯èƒ½ä¼šè¦†ç›–åœ¨å±å¹•è£…é¥°ä¹‹ä¸Š, æ¯”å¦‚å¯¼èˆªæ .è®¾ç½®æ­¤flagåŽ,windowmanagerå°†åœ¨decorçª—å£å†…å¯¹æ‰€ä¾é™„çš„çª—å£è¿›è¡Œå¸ƒå±€,è¿™æ ·ä¾¿ä¸ä¼šè¦†ç›–åœ¨å±å¹•è£…é¥°ä¸Š FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS æŒ‡ç¤ºè¯¥çª—å£ç”¨äºŽç»˜åˆ¶ç³»ç»ŸçŠ¶æ€æ çš„èƒŒæ™¯,å¦‚æžœè®¾ç½®æ­¤flag, ç³»ç»ŸçŠ¶æ€æ ä¼šå˜ä¸ºé€æ˜ŽèƒŒæ™¯, çª—å£ä¸­å“åº”çš„åŒºåŸŸä¼šè¢«Window#getStatusBarColor()å’ŒWindow#getNavigationBarColor()çš„é¢œè‰²æ‰€å¡«å…… WindowManager.LayoutParams.softInputModeç”¨äºŽç¡®å®šçª—å£å’Œè¾“å…¥æ³•ä¹‹é—´çš„å…³ç³» SOFT_INPUT_MASK_STATE æŒ‡å®šè¾“å…¥æ³•çš„è¦†ç›–å±‚, ç¡®å®šè¾“å…¥æ³•åŒºåŸŸæ˜¯å¦å¯è§çš„ä»£ç  SOFT_INPUT_STATE_UNSPECIFIED è¾“å…¥æ³•çš„å¯è§çŠ¶æ€ä¸º: æœªæŒ‡å®šçŠ¶æ€ SOFT_INPUT_STATE_UNCHANGED è¾“å…¥æ³•çš„å¯è§çŠ¶æ€ä¸º: ä¸æ”¹å˜è¾“å…¥æ³•å½“å‰çŠ¶æ€ SOFT_INPUT_STATE_HIDDEN è¾“å…¥æ³•çš„å¯è§çŠ¶æ€ä¸º: ç”¨æˆ·è¿›å…¥çª—å£æ—¶, éšè—æ‰€æœ‰è¾“å…¥æ³• SOFT_INPUT_STATE_ALWAYS_HIDDEN è¾“å…¥æ³•çš„å¯è§çŠ¶æ€ä¸º: çª—å£èŽ·å–ç„¦ç‚¹æ—¶, éšè—æ‰€æœ‰è¾“å…¥æ³• SOFT_INPUT_STATE_VISIBLE è¾“å…¥æ³•çš„å¯è§çŠ¶æ€ä¸º: ç”¨æˆ·è¿›å…¥çª—å£æ—¶, æ˜¾ç¤ºè¾“å…¥æ³• SOFT_INPUT_STATE_ALWAYS_VISIBLE è¾“å…¥æ³•çš„å¯è§çŠ¶æ€ä¸º: å½“çª—å£èŽ·å–è¾“å…¥ç„¦ç‚¹æ—¶, æ˜¾ç¤ºè¾“å…¥æ³• SOFT_INPUT_MASK_ADJUST æŒ‡å®šçª—å£æ˜¯å¦åº”è¯¥æ ¹æ®è¾“å…¥æ³•è¿›è¡Œè°ƒæ•´çš„ä»£ç  SOFT_INPUT_ADJUST_UNSPECIFIED çª—å£è°ƒæ•´è®¾ç½®ä¸º: æœªæŒ‡å®š, ç³»ç»Ÿä¼šå°è¯•è¿›è¡Œé€‰æ‹© SOFT_INPUT_ADJUST_RESIZE çª—å£è°ƒæ•´è®¾ç½®ä¸º: å½“æ˜¾ç¤ºè¾“å…¥æ³•æ—¶, å…è®¸çª—å£è¢«ç¼©æ”¾, ä½¿å¾—çª—å£çš„å†…å®¹ä¸ä¼šè¢«è¾“å…¥æ³•è¦†ç›–,ä¸èƒ½åŒSOFT_INPUT_ADJUST_PANä¸€èµ·ä½¿ç”¨,å¦‚æžœçª—å£å¸ƒå±€å±žæ€§åŒ…å«FLAG_FULLSCREEN, è¯¥é€‰é¡¹ä¼šè¢«å¿½ç•¥,çª—å£ä¸ä¼šç¼©æ”¾, è€Œæ˜¯ä¿æŒå…¨å± SOFT_INPUT_ADJUST_PAN çª—å£è°ƒæ•´è®¾ç½®ä¸º: å½“æ˜¾ç¤ºè¾“å…¥æ³•æ—¶,ç§»åŠ¨çª—å£ä½¿å¾—è¾“å…¥ç„¦ç‚¹å¯è§,è€Œä¸ä¼šç¼©æ”¾çª—å£ä¸èƒ½åŒSOFT_INPUT_ADJUST_RESIZEä¸€èµ·ä½¿ç”¨ SOFT_INPUT_ADJUST_NOTHING çª—å£è°ƒæ•´è®¾ç½®ä¸º: å½“æ˜¾ç¤ºè¾“å…¥æ³•æ—¶, æ—¢ä¸ç¼©æ”¾, ä¹Ÿä¸ç§»åŠ¨ SOFT_INPUT_IS_FORWARD_NAVIGATION ç”¨æˆ·å¯¼èˆªåˆ°æ­¤çª—å£æ—¶çš„é…ç½®ä»£ç . é€šå¸¸æœ‰ç³»ç»Ÿé…ç½®, é™¤éžä½ éœ€è¦è‡ªå®šä¹‰. å½“çª—å£æ˜¾ç¤ºåŽ,è¯¥é…ç½®ä¼šæ¸…é™¤ ActivityInfo.screenOrientationç”¨äºŽç¡®å®šçª—å£çš„æ–¹å‘ SCREEN_ORIENTATION_UNSPECIFIED ä¸æŒ‡å®šå±å¹•æ–¹å‘, è·Ÿéšç³»ç»Ÿ SCREEN_ORIENTATION_LANDSCAPE é»˜è®¤çš„æ¨ªå‘(å¬ç­’åœ¨å·¦, æŒ‰é”®åœ¨å³) SCREEN_ORIENTATION_PORTRAIT é»˜è®¤çš„ç«–å‘(å¬ç­’åœ¨ä¸Š, æŒ‰é”®åœ¨ä¸‹, ä¸åŒ…æ‹¬å¬ç­’åœ¨ä¸‹, æŒ‰é”®åœ¨ä¸Š) SCREEN_ORIENTATION_REVERSE_LANDSCAPE ä¸Žé»˜è®¤ç›¸åçš„æ¨ªå‘(å¬ç­’åœ¨å³, æŒ‰é”®åœ¨å·¦) SCREEN_ORIENTATION_REVERSE_PORTRAIT ä¸Žé»˜è®¤ç›¸åçš„ç«–å‘(å®žé™…å’ŒSCREEN_ORIENTATION_PORTRAITä¸€æ ·) SCREEN_ORIENTATION_SENSOR é‡åŠ›ä¼ æ„Ÿå™¨æ„ŸçŸ¥çš„æ–¹å‘(é™¤å¬ç­’åœ¨ä¸‹, æŒ‰é”®åœ¨ä¸Šçš„3ä¸ªæ–¹å‘) SCREEN_ORIENTATION_NOSENSOR ä¸ä½¿ç”¨ä¼ æ„Ÿå™¨æ–¹å‘ SCREEN_ORIENTATION_SENSOR_LANDSCAPE é‡åŠ›æ–¹å‘çš„æ¨ªå‘(å¬ç­’åœ¨å·¦, æŒ‰é”®åœ¨å³ / å¬ç­’åœ¨å³, æŒ‰é”®åœ¨å·¦) SCREEN_ORIENTATION_SENSOR_PORTRAIT é‡åŠ›æ–¹å‘çš„ç«–å‘(å¬ç­’åœ¨ä¸Š, æŒ‰é”®åœ¨ä¸‹, ä¸åŒ…æ‹¬å¬ç­’åœ¨ä¸‹, æŒ‰é”®åœ¨ä¸Š) SCREEN_ORIENTATION_FULL_SENSOR é‡åŠ›æ–¹å‘(å¬ç­’åœ¨ä¸Š, æŒ‰é”®åœ¨ä¸‹ / å¬ç­’åœ¨ä¸‹, æŒ‰é”®åœ¨ä¸Š / å¬ç­’åœ¨å·¦, æŒ‰é”®åœ¨å³ /å¬ç­’åœ¨å³,æŒ‰é”®åœ¨å·¦) SCREEN_ORIENTATION_USER ç”¨æˆ·è®¾ç½®çš„æ–¹å‘ SCREEN_ORIENTATION_USER_LANDSCAPE ç”¨æˆ·è®¾ç½®çš„æ¨ªå‘ SCREEN_ORIENTATION_USER_PORTRAIT ç”¨æˆ·è®¾ç½®çš„ç«–å‘ SCREEN_ORIENTATION_FULL_USER ç”¨æˆ·è®¾ç½®çš„4ä¸ªæ–¹å‘(å¬ç­’åœ¨ä¸Š, æŒ‰é”®åœ¨ä¸‹ / å¬ç­’åœ¨ä¸‹, æŒ‰é”®åœ¨ä¸Š / å¬ç­’åœ¨å·¦, æŒ‰é”®åœ¨å³ /å¬ç­’åœ¨å³, æŒ‰é”®åœ¨å·¦) SCREEN_ORIENTATION_BEHIND å½“å‰ç•Œé¢ä¸‹çš„Activityçš„æ–¹å‘ SCREEN_ORIENTATION_LOCKED é”å®šå½“å‰æ–¹å‘ èŽ·å–å½“å‰æ–¹å‘ int mCurrentOrientation = getResources().getConfiguration().orientation; WindowManager.LayoutParams.rotationAnimationç”¨äºŽç¡®å®šå±å¹•æ—‹è½¬æ—¶çš„åŠ¨ç”». æ˜¯å¦æœ‰æ•ˆå–å†³äºŽæ‰‹æœº ROTATION_ANIMATION_JUMPCUT ç«‹åˆ»åˆ‡æ¢, æ²¡æœ‰åŠ¨ç”» ROTATION_ANIMATION_CROSSFADE æœ‰æ·¡å…¥æ·¡å‡ºæ•ˆæžœ ROTATION_ANIMATION_ROTATE æ—‹è½¬åŠ¨ç”» ROTATION_ANIMATION_CHANGED (ä¸çŸ¥é“) params.dimAmountçª—å£ä¸‹å±‚å˜æš—ç¨‹åº¦, é»˜è®¤1.0fä¸å˜æš—0.0f~1.0f buttonBrightnessè®¾ç½®æŒ‰é”®çš„äº®åº¦. æœ‰äº›æ‰‹æœºæ²¡æœ‰é”®ç›˜ç¯çš„æ— æ•ˆ0.0f~1.0f screenBrightnesså±å¹•äº®åº¦,é»˜è®¤æ˜¯è´Ÿæ•°, è¡¨ç¤ºè·Ÿéšç³»ç»Ÿäº®åº¦.0.0f~1.0fè¡¨ç¤ºæœ€æš—åˆ°æœ€äº® systemUiVisibilityè®¾ç½®ç³»ç»Ÿç•Œé¢çš„å¯è§æ€§. æ˜¯å¦æœ‰æ•ˆå’Œæ‰‹æœºç³»ç»Ÿæœ‰å…³ View.INVISIBLE ç³»ç»ŸUIä¸å¯è§ View.SYSTEM_UI_FLAG_LOW_PROFILE ä½Žè°ƒæ¨¡å¼, çŠ¶æ€æ å’Œå›¾æ ‡ä¼šå˜æš— å¸¸è§åº”ç”¨åœºæ™¯æ‚¬æµ®çª—æ‚¬æµ®çª—ä¸»è¦æ˜¯è®¾ç½®type, æœ‰å¤šç§typeéƒ½å¯ä»¥å®žçŽ°æ‚¬æµ®çª—æ•ˆæžœ(PHONE, SYSTEM_ALERTâ€¦) WindowManager mWindowManager = (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE);// åˆ›å»ºä¸€ä¸ªæ–°çš„å¸ƒå±€WindowManager.LayoutParams param = new WindowManager.LayoutParams();// è®¾ç½®çª—å£å±žæ€§param.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT; // è®¾ç½®ä¸ºç³»ç»Ÿè­¦å‘Šçª—, å¯ä»¥æ‚¬æµ®åœ¨å…¶ä»–åº”ç”¨ä¹‹ä¸Šparam.format = PixelFormat.TRANSLUCENT; // æ”¯æŒé€æ˜Žparam.flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN // å¯åœ¨å…¨å±å¹•å¸ƒå±€, ä¸å—çŠ¶æ€æ å½±å“ | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; // æœ€åˆä¸å¯èŽ·å–ç„¦ç‚¹, è¿™æ ·ä¸å½±å“åº•å±‚åº”ç”¨æŽ¥æ”¶è§¦æ‘¸äº‹ä»¶param.alpha = 0.9f; // æ‚¬æµ®çª—çš„é€æ˜Žåº¦param.gravity = Gravity.LEFT | Gravity.TOP; // æ‚¬æµ®çª—çš„é‡åŠ›æ•ˆæžœparam.width = dp2px(140); // æ‚¬æµ®çª—å®½åº¦param.height = WindowManager.LayoutParams.WRAP_CONTENT; // æ‚¬æµ®çª—é«˜åº¦// ä»¥ä¸‹å°†æ‚¬æµ®ç©¿å®šä½åœ¨å±å¹•ä¸­å¤®int screenWidth = mWindowManager.getDefaultDisplay().getWidth();int screenHeight = mWindowManager.getDefaultDisplay().getHeight();param.x = (screenWidth - param.width) / 2;param.y = (screenHeight - param.height) / 2;// åˆ›å»ºæ‚¬æµ®çª—viewmFloatView = View.inflate(this, R.layout.view_float_window, null);ButterKnife.bind(this, mFloatView);// æ·»åŠ åˆ°å±å¹•mWindowManager.addView(mFloatView, param); æ‚¬æµ®çª—ä¸­éœ€è¦EditTextè¿›è¡Œè¾“å…¥æ‚¬æµ®çª—å¦‚æžœéœ€è¦å¼¹å‡ºè¾“å…¥æ³•è¿›è¡Œè¾“å…¥ï¼Œå°±éœ€è¦èŽ·å–ç„¦ç‚¹ å½“æ‚¬æµ®çª—ä¸­æœ‰EditTextéœ€è¦ä½¿ç”¨è¾“å…¥æ³•æ—¶, ä½¿ç”¨FLAG_NOT_TOUCH_MODAL, è¿™æ ·æ‚¬æµ®çª—ä¸­çš„EditTextå°±å¯ä»¥å¼¹å‡ºè¾“å…¥æ³•. æ­¤æ—¶ä¸‹å±‚åº”ç”¨å¯ä»¥æ“ä½œ, ä½†ä¸èƒ½å¼¹å‡ºè¾“å…¥æ³•, ä¸èƒ½ä½¿ç”¨è¿”å›žé”®. å¦‚éœ€è¦æ¢å¤ä¸‹å±‚åº”ç”¨çš„å®Œå…¨æ“ä½œ, å¯ä»¥ç­‰è¾“å…¥å®Œæ¯•åŽ, æ‰¾åˆé€‚æ—¶æœºå†æŠŠæ‚¬æµ®çª—æ”¹å›žFLAG_NOT_FOCUSABLE, ä»¥ä¾¿æ¢å¤èƒŒæ™¯windowçš„æŽ§åˆ¶ æ‚¬æµ®çª—ä¸å½±å“ä¸‹å±‚åº”ç”¨çš„æ“ä½œæ¯”å¦‚åœ¨æ‚¬æµ®çª—ä¸­æ²¡æœ‰EditTextæ—¶, ä½¿ç”¨FLAG_NOT_FOCUSABLEç¦æ­¢èŽ·å–ç„¦ç‚¹, è¿™æ ·èƒŒæ™¯windowå°±å¯ä»¥æ“ä½œ, å¯ä»¥è¾“å…¥, å¯ä»¥ä½¿ç”¨æŒ‰é”® æ‚¬æµ®çª—å’Œè¾“å…¥æ³•ä¹‹é—´çš„å æ”¾æ•ˆæžœ å½“è¾“å…¥æ³•å’Œæ‚¬æµ®çª—è¾“å…¥çª—å£é‡å æ—¶, æœ‰ä¸¤ç§å¤„ç†æ–¹å¼, éƒ½æ˜¯é€šè¿‡param.softInputModeæ¥å®žçŽ°:æ•´ä½“ç§»åŠ¨æ‚¬æµ®çª—, ä½¿è¾“å…¥çš„åœ°æ–¹å‡ºçŽ° WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN ç¼©å°æ‚¬æµ®çª—ä¸­å¯ä»¥ç¼©å°çš„éƒ¨åˆ†, ä½¿è¾“å…¥çš„åœ°æ–¹å‡ºçŽ° WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE æ‚¬æµ®çª—çš„æ‹–åŠ¨æ•ˆæžœä¸ºæ‚¬æµ®çª—è®¾ç½®onTouchListener, é€šè¿‡äº‹ä»¶åˆ¤æ–­æ˜¯ç‚¹å‡»è¿˜æ˜¯ç§»åŠ¨,ä½¿ç”¨mWindowManager.updateViewLayout(mFloatView, param)æ¥æ›´æ–°çª—å£ä½ç½® floatView.setOnTouchListener(new View.OnTouchListener() { // è®°å½•ä¸Šæ¬¡ç§»åŠ¨çš„ä½ç½® private float lastX = 0; private float lastY = 0; // æ˜¯å¦æ˜¯ç§»åŠ¨äº‹ä»¶ boolean isMoved = false; @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: isMoved = false; // è®°å½•æŒ‰ä¸‹ä½ç½® lastX = event.getRawX(); lastY = event.getRawY(); break; case MotionEvent.ACTION_MOVE: isMoved = true; // è®°å½•ç§»åŠ¨åŽçš„ä½ç½® float moveX = event.getRawX(); float moveY = event.getRawY(); // èŽ·å–å½“å‰çª—å£çš„å¸ƒå±€å±žæ€§, æ·»åŠ åç§»é‡, å¹¶æ›´æ–°ç•Œé¢, å®žçŽ°ç§»åŠ¨ WindowManager.LayoutParams param = (WindowManager.LayoutParams) mFloatView.getLayoutParams(); param.x += (int) (moveX - lastX); param.y += (int) (moveY - lastY); mWindowManager.updateViewLayout(mFloatView, param); lastX = moveX; lastY = moveY; case MotionEvent.ACTION_CANCEL: isMoved = true; break; } // å¦‚æžœæ˜¯ç§»åŠ¨äº‹ä»¶, åˆ™æ¶ˆè´¹æŽ‰; å¦‚æžœä¸æ˜¯, åˆ™ç”±å…¶ä»–å¤„ç†, æ¯”å¦‚ç‚¹å‡» return isMoved; }}); Activityè®¾ç½®å±å¹•æ—‹è½¬, å…¨å±ç­‰android:configChanges=&quot;orientation|screenSize&quot;keyboardHiddenorientationscreenSizeorientation|screenSize: æ”¹å˜å±å¹•æ–¹å‘æ—¶å¹¶ä¸é‡å¯ActivitysetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);getWindow().setAttributes(windowParams); å¼¹çª—ä½äºŽè½¯é”®ç›˜ä¹‹ä¸‹ï¼Œå…¶ä»–è§†å›¾ä¹‹ä¸ŠgetWindow().addFlags( WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM|WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE); FLAG_ALT_FOCUSABLE_IM|FLAG_NOT_FOCUSABLEå¯ä»¥å®žçŽ°UIï¼Œä¸è¿‡å¼¹çª—ä¸Šçš„edittextä¸ä¼šæŽ¥å—åˆ°è½¯é”®ç›˜ä¸Šçš„è¾“å…¥äº‹ä»¶ï¼ŒFLAG_NOT_FOCUSABLEå·²ç»æ‹’ç»æŽ¥å—äº†ã€‚é‚£å¯ä»¥åœ¨dialog onCreateçš„æ—¶å€™å®Œæˆä»¥ä¸ŠUI FLAGè®¾ç½®ï¼Œåœ¨showçš„æ—¶å€™æ¸…é™¤flagå³å¯æŽ¥å—åˆ°è¾“å…¥äº‹ä»¶ getWindow().clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM|WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE);getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE); Dialogå…¨å±æ˜¾ç¤º Phonewindowä¸­å¯¹windowIsFloatingè¿›è¡Œåˆ¤æ–­ï¼Œactivityé»˜è®¤ä¸»é¢˜ä¸ºfalseï¼ŒgenerateLayoutæ–¹æ³•ä¸­å¯¹è¯¥å‚æ•°è¿›è¡Œåˆ¤æ–­è®¾ç½®LayoutParamsä¸ºMATCH_PARENTæˆ–WRAP_CONTENNTã€‚ windowBackgroundä¸»è¦æ˜¯é»˜è®¤èƒŒæ™¯çš„é—®é¢˜ï¼Œé»˜è®¤é‡‡ç”¨äº†æœ‰paddingçš„InsetDrawable,è®¾ç½®äº†ä¸€äº›è¾¹è·ï¼Œå¯¼è‡´ä¸Šé¢çš„çŠ¶æ€æ ï¼Œåº•éƒ¨çš„å¯¼èˆªæ ï¼Œå·¦å³éƒ½æœ‰ä¸€å®šçš„è¾¹è·ã€‚ windowNoTitleåŽ»é™¤toolbarç­‰é¡¶éƒ¨UIã€‚&lt;style name=&quot;Dialog.FullScreen&quot; parent=&quot;Theme.AppCompat.Dialog&quot;&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/transparent&lt;/item&gt; &lt;item name=&quot;android:windowIsFloating&quot;&gt;false&lt;/item&gt;&lt;/style&gt;","link":"/2018/10/23/WindowManager%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86/"},{"title":"MAC adbæ— çº¿è¿žæŽ¥AndroidçœŸæœº","text":"ä¸€ç›´æ‡’å¾—æžï¼Œå› ä¸ºç”¨ä¸ä¸Šï¼Œæœ€è¿‘é…ç½®äº†åŒå±ï¼Œçž¬é—´usbæ’å£ä¸å¤Ÿç”¨ï¼ŒäºŽæ˜¯æœ‰äº†ä¸‹æ–‡ã€‚ ä¸€ç›´æ‡’å¾—æžï¼Œå› ä¸ºç”¨ä¸ä¸Šï¼Œæœ€è¿‘é…ç½®äº†åŒå±ï¼Œçž¬é—´usbæ’å£ä¸å¤Ÿç”¨äº†ï¼ŒäºŽæ˜¯å°±æœ‰äº†ä¸‹æ–‡ã€‚ å‡†å¤‡å·¥ä½œ æ‰‹æœºå’Œç”µè„‘éœ€è¦å†åŒä¸€ä¸ªå±€åŸŸç½‘ ç”µè„‘ä¸Šå·²ç»å®‰è£…adbå·¥å…·ã€‚ å¼€å§‹æ‰“å¼€æ‰‹æœºç«¯å£è®©æ‰‹æœºåœ¨æŒ‡å®šçš„ç«¯å£å¯ä»¥æŽ¥æ”¶åˆ°TCP/IPè¿žæŽ¥ ç¡®ä¿æ‰‹æœºå¼€å¯usbè°ƒè¯• ç”¨usbçº¿æŠŠæ‰‹æœºå’Œç”µè„‘è¿žæŽ¥èµ·æ¥ æ‰§è¡Œå‘½ä»¤ï¼šâ€™adb tcpip 5555â€™ æ‰§è¡ŒæˆåŠŸåŽæ‹”æŽ‰usbçº¿ï¼Œç«¯å£å¯ä»¥ä¸ç”¨5555ï¼Œè¿™ä¸ªå®˜æ–¹é»˜è®¤ä½¿ç”¨çš„ã€‚ æ‰¾åˆ°æ‰‹æœºçš„IPåœ°å€ä¸€èˆ¬åœ¨ è®¾ç½®-æˆ‘å¾—è®¾å¤‡-å…¨éƒ¨å‚æ•°-çŠ¶æ€ä¿¡æ¯-IPåœ°å€ é€šè¿‡IPåœ°å€è¿žæŽ¥æ‰‹æœºæ‰§è¡Œå‘½ä»¤ï¼š &gt; adb connect 192.168.26.58:5555 è‹¥ç«¯å£å·æ˜¯5555ï¼Œåˆ™å¯ä»¥çœç•¥ï¼Œç›´æŽ¥ï¼š &gt; adb connect 192.168.26.58 å¦‚æžœæ²¡æœ‰è¿žæŽ¥æˆåŠŸå¦‚æžœç¡®å®šç½‘ç»œä¸Žç«¯å£æ²¡æœ‰é—®é¢˜ï¼Œå¯ä»¥å°è¯•é‡å¯adbæœåŠ¡ï¼š &gt; adb kill-server è¿žæŽ¥æˆåŠŸå¦‚æžœè¿žæŽ¥æˆåŠŸï¼Œå¯ä»¥æ‰§è¡Œä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹å½“å‰è¿žæŽ¥çš„è®¾å¤‡åˆ—è¡¨ï¼š &gt; adb devices","link":"/2018/05/29/MAC-adb%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5Android%E7%9C%9F%E6%9C%BA/"},{"title":"cocoapodsç§æœ‰åº“å¤„ç†","text":"æŠ½ç¦»å·¥å…·ç±»å¹¶æäº¤cocoaPodsç§æœ‰åº“ æœ€è¿‘åœ¨æå–é¡¹ç›®ä¸­çš„éƒ¨åˆ†å·¥å…·ç±»ï¼Œæœ‰ç”¨åˆ°cocoaPodsç§æœ‰åº“ï¼Œæ‰€ä»¥æŠŠå®ƒè®°å½•ä¸‹æ¥ã€‚ ç§æœ‰åº“ä½¿ç”¨æµç¨‹ä¸ºç§æœ‰åº“æ·»åŠ repo$ pod repo add REPO_NAME git@github:artsy/Specs.git åˆ›å»ºç§æœ‰åº“$ pod repo add REPO_NAME SOURCE_URL æ£€æŸ¥repoå®‰è£…æˆåŠŸ$ cd ~/.cocoapods/repos/REPO_NAME $ pod repo lint . æŠŠå‡†å¤‡å¥½çš„ä»£ç åº“specåŠ å…¥åˆ°ç§æœ‰åº“ä¸­è¯¥å‘½ä»¤ä¼šæŠŠæ­¤ç‰ˆæœ¬çš„.podSpecæ‹·è´åˆ°ç§æœ‰åº“ä¸­å¹¶pushåˆ°è¿œç¨‹gitä»£ç åº“ $ pod repo push REPO_NAME SPEC_NAME.podspec .podSpecæ–‡ä»¶å¼•ç”¨å…¶ä»–ç§æœ‰åº“æƒ…å†µé¡¹ç›®ä¸­éœ€è¦å¼•ç”¨åˆ°ç§æœ‰åº“çš„library,è¿™ä¸ªæ—¶å€™éœ€è¦ç”¨åˆ° sources s.dependency 'THLTencentOpenAPI' $ pod lib lint --sources=https://xx/ThirdSDK.git $ pod repo push ThirdSDK --sources=https://xx/ThirdSDK.git åŒ…å«é™æ€åº“æƒ…å†µæ·»åŠ  --use-libraries å¿½ç•¥æŽ‰ç›¸å…³æ£€æŸ¥ éƒ¨åˆ†é—®é¢˜å¤„ç† The repo `MyRepo` at `../.cocoapods/repos/ThirdSDK` is not clean $ pod repo update ThirdSDK","link":"/2018/03/29/cocoapods%E7%A7%81%E6%9C%89%E5%BA%93%E5%A4%84%E7%90%86/"},{"title":"android studioæ”¯æŒç³»ç»Ÿç­¾å","text":"Androidæºç çŽ¯å¢ƒç¼–è¯‘è°ƒè¯• å¦‚æžœæƒ³è®©apkæ‹¥æœ‰ç³»ç»Ÿæƒé™ï¼Œéœ€è¦å†AndroidManifest.xmlä¸­æ·»åŠ å…±äº«ç³»ç»Ÿè¿›ç¨‹å±žæ€§ï¼š android:sharedUserId=&quot;android.uid.system&quot; android:sharedUserId=&quot;android.uid.shared&quot; android:sharedUserId=&quot;android.media&quot; è¿™æ—¶å€™apkçš„ç­¾åå°±éœ€è¦æ˜¯ç³»ç»Ÿç­¾å(platformã€sharedæˆ–media)æ‰èƒ½æ­£å¸¸ä½¿ç”¨ã€‚ å¸¸ç”¨ç³»ç»Ÿç­¾åæ–¹å¼Androidæºç çŽ¯å¢ƒä¸‹ç­¾åè¿™ç§æ–¹å¼æ¯”è¾ƒéº»çƒ¦ï¼Œä½ éœ€è¦æœ‰ç¼–è¯‘è¿‡çš„æºç çŽ¯å¢ƒï¼Œå¹¶æŒ‰å¦‚ä¸‹æ­¥éª¤ï¼š 1ã€æ‹·è´Appæºç åˆ°Androidæºç çš„packages/apps/ç›®å½•ä¸‹ï¼Œä¸”Appæºç æ˜¯æ™®é€š(Eclipse)æ ¼å¼çš„2ã€é…ç½®Android.mkï¼Œåœ¨å…¶ä¸­æ·»åŠ  LOCAL_CERTIFICATE := platform æˆ– shared æˆ– media 3ã€ä½¿ç”¨mmç¼–è¯‘Appï¼Œç”Ÿæˆçš„apkå³ç³»ç»Ÿç­¾å æ‰‹åŠ¨é‡æ–°ç­¾åè¿™ç§æ–¹å¼æ¯”åœ¨æºç çŽ¯å¢ƒä¸‹ç­¾åç®€å•ï¼ŒAppå¯ä»¥åœ¨Eclipseæˆ–Android Studioä¸‹ç¼–è¯‘ï¼Œç„¶åŽç»™apké‡æ–°ç­¾åå³å¯ã€‚ä½†è¿™ç§æ–¹å¼åœ¨é¢‘ç¹è°ƒè¯•çš„æ—¶å€™æ¯”è¾ƒç—›è‹¦ï¼Œå³ä½¿å†™æˆè„šæœ¬ï¼Œä¹Ÿéœ€è¦é‡å¤ä¸€æ ·çš„æ“ä½œã€‚ ç›¸å…³æ–‡ä»¶platform.x509.pemã€platform.pk8ã€signapk.jar æ–‡ä»¶ä½ç½®platform.x509.pemã€platform.pk8: ../build/target/product/security signapk.jar: ../out/host/linux-x86/framework signapkæºç è·¯å¾„: ../build/tools/signapk ç­¾åå‘½ä»¤java -jar signapk.jar platform.x509.pem platform.pk8 old.apk new.apk æ­¥éª¤1ã€å°†ç›¸å…³æ–‡ä»¶åŠæºapkæ–‡ä»¶ç½®äºŽåŒä¸€è·¯å¾„ä¸‹2ã€æ£€æŸ¥æºapkåŒ…ï¼ŒåŽ»æŽ‰META-INF/CERT.SF å’Œ META-INF/CERT.RSA æ–‡ä»¶3ã€æ‰§è¡Œç­¾åå‘½ä»¤å³å¯ Android Studioç³»ç»Ÿç­¾åè®©Android Studioé›†æˆç³»ç»Ÿç­¾åï¼Œéœ€è¦ç”¨åˆ°ä¸€ä¸ªå·¥å…·keytool-importkeypairï¼Œè¯¦è§ä¸‹æ–‡ã€‚ keytool-importkeypairkeytool-importkeypair â€“ A shell script to import key/certificate pairs into an existing Java keystore ç›¸å…³æ–‡ä»¶platform.x509.pemã€platform.pk8ã€keytool-importkeypairã€demo.jksã€signature.shæˆ‘çš„åšæ³•æ˜¯åœ¨Appæ ¹ç›®å½•æ–°å»ºSignatureæ–‡ä»¶å¤¹ä¸“é—¨å­˜æ”¾ç­¾åç›¸å…³æ–‡ä»¶ã€‚1.ç”Ÿæˆç­¾åæ–‡ä»¶xx.jks2.ç¼–å†™ç­¾åè„šæœ¬signature.shï¼Œå†…å®¹å¦‚ä¸‹: #!/bin/sh è½¬æ¢ç³»ç»Ÿç­¾åå‘½ä»¤./keytool-importkeypair -k demo.jks -p 123456 -pk8 platform.pk8 -cert platform.x509.pem -alias demo # demo.jks : ç­¾åæ–‡ä»¶ # 123456 : ç­¾åæ–‡ä»¶å¯†ç  # platform.pk8ã€platform.x509.pem : ç³»ç»Ÿç­¾åæ–‡ä»¶ # demo : ç­¾åæ–‡ä»¶åˆ«å ä¸ºè„šæœ¬æ–‡ä»¶æ·»åŠ å¯æ‰§è¡Œæƒé™ï¼š $ sudo chmod a+x signature.sh æ‰§è¡Œè„šæœ¬ï¼š $ ./signature.sh 3.é…ç½®builde.gradle signingConfigs { release { storeFile file(&quot;../signature/demo.jks&quot;) storePassword '123456' keyAlias 'demo' keyPassword '123456' } debug { storeFile file(&quot;../signature/demo.jks&quot;) storePassword '123456' keyAlias 'demo' keyPassword '123456' } } è¿™æ ·debugæˆ–release apkå°±å¸¦æœ‰ç³»ç»Ÿç­¾åäº†ã€‚","link":"/2018/05/21/android-studio%E6%94%AF%E6%8C%81%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D/"},{"title":"kotlin inline","text":"ä½¿ç”¨é«˜é˜¶å‡½æ•°ä¼šå¸¦æ¥ä¸€äº›è¿è¡Œæ—¶çš„æ•ˆçŽ‡æŸå¤±ï¼šæ¯ä¸€ä¸ªå‡½æ•°éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”ä¼šæ•èŽ·ä¸€ä¸ªé—­åŒ…ã€‚å³é‚£äº›åœ¨å‡½æ•°ä½“å†…ä¼šè®¿é—®åˆ°çš„å˜é‡ã€‚å†…å­˜åˆ†é…å’Œè™šæ‹Ÿè°ƒç”¨ä¼šå¼•å…¥è¿è¡Œæ—¶é—´å¼€é”€ã€‚ å‰è¨€Kotlinåœ¨é›†åˆAPIä¸­å¤§é‡ä½¿ç”¨äº†Lambdaï¼Œè¿™ä½¿å¾—æˆ‘ä»¬åœ¨å¯¹é›†åˆè¿›è¡Œæ“ä½œçš„æ—¶å€™ä¼˜é›…äº†è®¸å¤šã€‚ä½†æ˜¯è¿™ç§æ–¹å¼çš„ä»£ä»·å°±æ˜¯ï¼Œåœ¨Kotlinä¸­ä½¿ç”¨Lambdaè¡¨è¾¾å¼ä¼šå¸¦æ¥ä¸€äº›é¢å¤–çš„å¼€é”€ï¼Œè€Œå†…è”å‡½æ•°åº”è¿è€Œç”Ÿï¼Œç”¨æ¥è§£å†³ä¼˜åŒ–Kotlinæ”¯æŒLambdaè¡¨è¾¾å¼ä¹‹åŽæ‰€å¸¦æ¥çš„å¼€é”€ã€‚ ä¼˜åŒ–Lambdaå¼€é”€Kotliné»˜è®¤é¢å‘JDK6ï¼Œè€ŒJDK8æ‰å¼•å…¥Lambdaè¡¨è¾¾å¼æ”¯æŒã€‚åœ¨Kotlinä¸­æ¯ç”³æ˜Žä¸€ä¸ªLambdaè¡¨è¾¾å¼ï¼Œå°±ä¼šåœ¨å­—èŠ‚ç ä¸­äº§ç”Ÿä¸€ä¸ªåŒ¿åç±»ï¼Œè¯¥åŒ¿åç±»åŒ…å«äº†ä¸€ä¸ªinvokeæ–¹æ³•ï¼Œä½œä¸ºLambdaçš„è°ƒç”¨æ–¹æ³•ï¼Œæ¯æ¬¡è°ƒç”¨éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œå¿…é¡»é‡‡ç”¨æŸç§æ–¹æ³•æ¥ä¼˜åŒ–Lambdaå¸¦æ¥çš„é¢å¤–å¼€é”€ï¼Œä¹Ÿå°±æ˜¯å†…è”å‡½æ•°ã€‚ invokedynamicä¸ŽKotlinè¿™ç§åœ¨ç¼–è¯‘æœŸé€šè¿‡ç¡¬ç¼–ç ç”ŸæˆLambdaè½¬æ¢ç±»çš„æœºåˆ¶ä¸åŒï¼ŒJavaåœ¨SE 7ä¹‹åŽé€šè¿‡invokedynamicæŠ€æœ¯å®žçŽ°äº†åœ¨è¿è¡ŒæœŸæ‰äº§ç”Ÿç›¸åº”çš„ç¿»è¯‘ä»£ç ã€‚åœ¨invokedynamicè¢«é¦–æ¬¡è°ƒç”¨çš„æ—¶å€™ï¼Œå°±ä¼šè§¦å‘äº§ç”Ÿä¸€ä¸ªåŒ¿åç±»æ¥æ›¿æ¢ä¸­é—´ç invokedynamicï¼ŒåŽç»­çš„è°ƒç”¨ä¼šç›´æŽ¥é‡‡ç”¨è¿™ä¸ªåŒ¿åç±»çš„ä»£ç ï¼Œè¿™æ ·åšçš„å¥½å¤„ä¸»è¦ä½“çŽ°åœ¨ï¼š ç”±äºŽå…·ä½“çš„è½¬æ¢å®žçŽ°æ˜¯åœ¨è¿è¡Œæ—¶äº§ç”Ÿçš„ï¼Œåœ¨å­—èŠ‚ç ä¸­èƒ½çœ‹åˆ°çš„åªæœ‰ä¸€ä¸ªå›ºå®šçš„invokedynamicï¼Œæ‰€ä»¥éœ€è¦é™æ€ç”Ÿæˆçš„ç±»çš„ä¸ªæ•°åŠå­—èŠ‚ç å¤§å°éƒ½æ˜¾è‘—å‡å°‘ã€‚ ä¸Žç¼–è¯‘æ—¶å†™æ­»åœ¨å­—èŠ‚ç ä¸­çš„ç­–ç•¥ä¸åŒï¼Œåˆ©ç”¨invokedynamicå¯ä»¥æŠŠå®žé™…çš„ç¿»è¯‘ç­–ç•¥éšè—åœ¨JDKåº“çš„å®žçŽ°ï¼Œè¿™æžå¤§æé«˜äº†çµæ´»æ€§ï¼Œåœ¨ç¡®ä¿å‘åŽå…¼å®¹æ€§çš„åŒæ—¶ï¼ŒåŽæœŸå¯ä»¥ç»§ç»­å¯¹ç¿»è¯‘ç­–ç•¥ä¸æ–­ä¼˜åŒ–å‡çº§ã€‚ JVMå¤©ç„¶æ”¯æŒäº†é’ˆå¯¹è¯¥æ–¹å¼çš„Lambdaè¡¨è¾¾å¼çš„ç¿»è¯‘å’Œä¼˜åŒ–ï¼Œè¿™ä¹Ÿæ„å‘³ç€å¼€å‘è€…åœ¨ä¹¦å†™Lambdaè¡¨è¾¾å¼çš„åŒæ—¶ï¼Œå¯ä»¥å®Œå…¨ä¸ç”¨å…³å¿ƒè¿™ä¸ªé—®é¢˜ï¼Œè¿™æžå¤§çš„æé«˜äº†å¼€å‘ä½“éªŒï¼ˆä½“éªŒå¾ˆé‡è¦ï¼‰ã€‚ å†…è”å‡½æ•°invokedynamicå›ºç„¶ä¸é”™ï¼Œä½†Kotlinä¸æ”¯æŒå®ƒçš„ç†ç”±ä¹Ÿå¾ˆå……åˆ†ã€‚æˆ‘ä»¬æœ‰è¶³å¤Ÿçš„ç†ç”±ç›¸ä¿¡ï¼Œå…¶æœ€å¤§çš„åŽŸå› æ˜¯Kotlinåœ¨ä¸€å¼€å§‹å°±éœ€è¦å…¼å®¹Androidæœ€ä¸»æµçš„Javaç‰ˆæœ¬SE 6ï¼Œè¿™å¯¼è‡´æ— æ³•é€šè¿‡invokedynamicæ¥è§£å†³Androidå¹³å°çš„Lambdaå¼€é”€é—®é¢˜ã€‚å› æ­¤ä½œä¸ºå¦å¤–ä¸€ç§ä¸»æµçš„è§£å†³æ–¹æ¡ˆï¼ŒKotlinæ‹¥æŠ±äº†å†…è”å‡½æ•°ï¼Œåœ¨C++ã€C#ç­‰è¯­è¨€ä¸­ä¹Ÿæ”¯æŒè¿™ç§ç‰¹æ€§ã€‚ç®€å•æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨inlineå…³é”®å­—æ¥ä¿®é¥°å‡½æ•°ï¼Œè¿™äº›å‡½æ•°å°±æˆäº†å†…è”å‡½æ•°ã€‚å®ƒä»¬çš„å‡½æ•°ä½“åœ¨ç¼–è¯‘æœŸè¢«åµŒå…¥æ¯ä¸€ä¸ªè¢«è°ƒç”¨çš„åœ°æ–¹ï¼Œä»¥å‡å°‘é¢å¤–ç”Ÿæˆçš„åŒ¿åç±»æ•°ï¼Œä»¥åŠå‡½æ•°æ‰§è¡Œçš„æ—¶é—´å¼€é”€ã€‚ inlineè¯­æ³•æˆ‘ä»¬çœ‹ä¸€ä¸‹å†…è”å‡½æ•°å¦‚ä½•æ“ä½œ fun main(args:Array&lt;String&gt;) { foo { println(&quot;dive into kotlin...&quot;) }}fun foo(block: () -&gt; Unit) { block()} ç”³æ˜Žä¸€ä¸ªé«˜é˜¶å‡½æ•°fooï¼ŒæŽ¥æ”¶ä¸€ä¸ªç±»åž‹ä¸º()-&gt;Unitçš„Lambdaï¼Œå¹¶åœ¨mainå‡½æ•°ä¸­è°ƒç”¨å®ƒã€‚ä»¥ä¸‹æ˜¯é€šè¿‡å­—èŠ‚ç åç¼–è¯‘å¾—åˆ°çš„Javaä»£ç : public static final void foo(@NotNull Function0 block) { Intrinsics.checkParameterIsNotNull(block, &quot;block&quot;); block.invoke(); } public static final void main(@NotNull String[] args) { Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); foo((Function0)null.INSTANCE); } è°ƒç”¨fooå°±ä¼šäº§ç”Ÿä¸€ä¸ªFunction0ç±»åž‹çš„blockç±»ï¼Œç„¶åŽé€šè¿‡invokeæ–¹æ³•æ¥æ‰§è¡Œï¼Œè¿™ä¼šå¢žåŠ é¢å¤–çš„ç”Ÿæˆç±»å’Œè°ƒç”¨å¼€é”€ï¼ŒçŽ°åœ¨æˆ‘ä»¬ç»™fooå‡½æ•°åŠ ä¸Šinlineä¿®é¥°ç¬¦ï¼Œå¦‚ä¸‹: inline fun foo(block:() -&gt; Unit) { block()} public static final void main(@NotNull String[] args) { Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); int $i$f$foo = false; int var2 = false; String var3 = &quot;xxxx&quot;; boolean var4 = false; System.out.print(var3);} æžœç„¶ï¼Œfooå‡½æ•°ä½“ä»£ç åŠè¢«è°ƒç”¨çš„Lambdaä»£ç éƒ½ç²˜è´´åˆ°äº†ç›¸åº”è°ƒç”¨çš„ä½ç½®ï¼Œå¦‚æžœè¿™æ˜¯ä¸€ä¸ªå·¥ç¨‹ä¸­çš„å…¬å…±çš„æ–¹æ³•ï¼Œæˆ–è€…è¢«åµŒå¥—åœ¨ä¸€ä¸ªå¾ªçŽ¯è°ƒç”¨çš„é€»è¾‘ä½“ä¸­ï¼Œé€šè¿‡inlineè¯­æ³•ç³–ï¼Œæˆ‘ä»¬å¯ä»¥å½»åº•æ¶ˆé™¤è¿™ç§é¢å¤–è°ƒç”¨ï¼Œä»Žè€ŒèŠ‚çº¦å¼€é”€ã€‚ ä¸€äº›æƒ…å†µä¸‹åº”è¯¥é¿å…ä½¿ç”¨inline JVMå¯¹æ™®é€šçš„å‡½æ•°å·²ç»èƒ½å¤Ÿæ ¹æ®å®žé™…æƒ…å†µæ™ºèƒ½åœ°åˆ¤æ–­æ˜¯å¦è¿›è¡Œå†…è”ä¼˜åŒ–ï¼Œæ‰€ä»¥æˆ‘ä»¬å¹¶ä¸éœ€è¦å¯¹å…¶ä½¿ç”¨Kotlinçš„inlineè¯­æ³•ï¼Œé‚£åªä¼šè®©å­—èŠ‚ç å˜å¾—æ›´åŠ å¤æ‚ å°½é‡é¿å…å¯¹å…·æœ‰å¤§é‡å‡½æ•°ä½“çš„å‡½æ•°è¿›è¡Œå†…è”ï¼Œè¿™æ ·ä¼šå¯¼è‡´è¿‡å¤šçš„å­—èŠ‚ç æ•°é‡ ä¸€æ—¦ä¸€ä¸ªå‡½æ•°è¢«å®šä¹‰ä¸ºå†…è”å‡½æ•°ï¼Œä¾¿ä¸èƒ½èŽ·å–é—­åŒ…ç±»çš„ç§æœ‰æˆå‘˜ï¼Œé™¤éžè¢«å£°æ˜Žä¸ºinternal é¿å…å‚æ•°è¢«å†…è”noinlineçŽ°å®žä¸­æƒ…å†µå¾€å¾€ååˆ†å¤æ‚ï¼Œå¯èƒ½å¤šä¸ªå‚æ•°æ—¶ï¼Œæˆ‘ä»¬åªæƒ³å¯¹éƒ¨åˆ†Lambdaå‚æ•°å†…è”ï¼Œå…¶ä»–ä¸å†…è”ï¼Œè¿™ä¸ªæ—¶å€™å°±éœ€è¦noinlineå…³é”®å­— inline fun foo (block1 () -&gt; Unit,noinline block2:()-&gt;Unit) { block1() block2()} éžå±€éƒ¨è¿”å›žKotlinä¸­çš„å†…è”å‡½æ•°é™¤äº†ä¼˜åŒ–Lambdaå¼€é”€ä¹‹å¤–ï¼Œè¿˜å¸¦æ¥äº†å…¶ä»–æ–¹é¢çš„ç‰¹æ•ˆï¼Œå…¸åž‹çš„å°±æ˜¯éžå±€éƒ¨è¿”å›žå’Œå…·ä½“åŒ–å‚æ•°ç±»åž‹ã€‚ ä½¿ç”¨ fun main(args: Array&lt;String&gt;) { foo() } fun localReturn() { return } fun foo() { println(&quot;before local return&quot;) localReturn() println(&quot;after local return&quot;) return }//è¿è¡Œç»“æžœ//before local return//after local return localReturnæ‰§è¡ŒåŽï¼Œå…¶å‡½æ•°ä½“ä¸­çš„returnåªä¼šåœ¨è¯¥å‡½æ•°çš„å±€éƒ¨ç”Ÿæ•ˆï¼Œæ‰€ä»¥localReturn()ä¹‹åŽçš„printlnå‡½æ•°ä¾æ—§ç”Ÿæ•ˆã€‚æ¢æˆLambdaè¡¨è¾¾å¼çš„ç‰ˆæœ¬: fun main(args: Array&lt;String&gt;) { foo {return} } fun foo (returning: () -&gt; Unit) { println(&quot;before local return&quot;) returning() println(&quot;after local return&quot;) return }//è¿è¡Œç»“æžœ// Error:(2,11) Kotlin: 'return' is not allowed here ç¼–è¯‘æŠ¥é”™ï¼Œæ­£å¸¸æƒ…å†µä¸‹Lambdaè¡¨è¾¾å¼ä¸å…è®¸å­˜åœ¨returnå…³é”®å­—ï¼Œè¿™æ—¶å€™å†…è”å‡½æ•°å°±æ´¾ä¸Šç”¨åœºäº†ï¼Œfooå‡½æ•°è¿›è¡Œå†…è”åŽï¼š //è¿è¡Œç»“æžœ//before local return å†…è”å‡½æ•°fooçš„å‡½æ•°ä½“åŠå‚æ•°Lambdaä¼šç›´æŽ¥æ›¿ä»£å…·ä½“çš„è°ƒç”¨ï¼Œæ‰€ä»¥å®žé™…äº§ç”Ÿçš„ä»£ç ä¸­ï¼Œreturnç›¸å½“äºŽç›´æŽ¥æš´éœ²åœ¨mainå‡½æ•°ä¸­ï¼Œæ‰€ä»¥returning()ä¹‹åŽçš„ä»£ç è‡ªç„¶ä¸ä¼šè¢«æ‰§è¡Œã€‚è¿™ä¸ªå°±æ˜¯æ‰€è°“çš„éžå±€éƒ¨è¿”å›žã€‚ ä½¿ç”¨æ ‡ç­¾å®žçŽ°Lambdaéžå±€éƒ¨è¿”å›žå¦å¤–ä¸€ç§ç­‰æ•ˆçš„æ–¹å¼ï¼Œæ˜¯é€šè¿‡æ ‡ç­¾åˆ©ç”¨@ç¬¦å·æ¥å®žçŽ°Lambdaéžå±€éƒ¨è¿”å›žï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸ç”³æ˜Žinlineçš„æƒ…å†µä¸‹ï¼Œå®žçŽ°åŒæ ·çš„æ•ˆæžœï¼š fun main(args: Array&lt;String&gt;) { foo (return@foo) } fun foo(returning: () -&gt; Unit) { println(&quot;before local return&quot;) returning() println(&quot;after local return&quot;) return }//è¿è¡Œç»“æžœ//before local return crossinlineæˆ‘ä»¬å†…è”å‡½æ•°æ‰€æŽ¥æ”¶çš„Lambdaå‚æ•°å¸¸å¸¸æ¥è‡ªäºŽä¸Šä¸‹æ–‡å…¶ä»–åœ°æ–¹ï¼Œä¸ºäº†é¿å…å¸¦æœ‰returnçš„Lambdaå‚æ•°äº§ç”Ÿç ´åï¼Œæˆ‘ä»¬å¯ä»¥æ˜¯crossinlineæ¥ä¿®é¥°è¯¥å‚æ•°ï¼Œä»Žè€Œæœç»è¯¥é—®é¢˜çš„å‘ç”Ÿã€‚ fun main(args:Array&lt;String&gt;) { foo {return}//returnä¼šæœ‰ä¸‹æ»‘æ³¢æµªçº¿ï¼ŒIDEAä¼šæŠ¥é”™}inline fun foo(crossinline returning:()-&gt;Unit) { println(&quot;before&quot;) returning() println(&quot;after&quot;) return} å…·ä½“åŒ–å‚æ•°ç±»åž‹é™¤äº†éžå±€éƒ¨è¿”å›žä¹‹å¤–ï¼Œå†…è”å‡½æ•°è¿˜å¯ä»¥å¸®åŠ©Kotlinå®žçŽ°å…·ä½“åŒ–å‚æ•°ç±»åž‹ï¼ŒKotlinä¸ŽJavaä¸€æ ·ï¼Œç”±äºŽè¿è¡Œæ—¶çš„ç±»åž‹æ“¦æ‹­ï¼Œæˆ‘ä»¬å¹¶ä¸èƒ½ç›´æŽ¥èŽ·å–ä¸€ä¸ªå‚æ•°çš„ç±»åž‹ã€‚ç„¶è€Œï¼Œç”±äºŽå†…è”å‡½æ•°ä¼šç›´æŽ¥åœ¨å­—èŠ‚ç ä¸­ç”Ÿæˆç›¸åº”çš„å‡½æ•°ä½“å®žçŽ°ï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬åè€Œå¯ä»¥èŽ·å¾—å‚æ•°çš„å…·ä½“ç±»åž‹ï¼Œå¯ä»¥ç”¨reifiedä¿®é¥°ç¬¦æ¥å®žçŽ°è¿™ä¸€æ•ˆæžœ fun main(args:Array&lt;String&gt;){ getType&lt;Int&gt;() } inline fun &lt;reified T&gt;getType() { print(T::class) }//è¿è¡Œç»“æžœ//class Kotlin.Int è¿™ä¸€ç‰¹æ€§åœ¨Androidä¸­æ ¼å¤–æœ‰ç”¨ã€‚æ¯”å¦‚ï¼Œå½“æˆ‘ä»¬è¦è°ƒç”¨startActivityæ—¶ï¼Œé€šå¸¸éœ€è¦æŠŠå…·ä½“çš„ç›®æ ‡è§†å›¾ç±»ä½œä¸ºå‚æ•°ä¼ é€’ï¼Œè€Œåœ¨Kotlinä¸­: inline fun &lt;reified T : Activity&gt; Activity.startActivity() { startActivity(Intent(this,T::class.java))}//usagestartActivity&lt;LoginActivity&gt;() END","link":"/2019/11/18/kotlin-inline/"},{"title":"wake me up","text":"Feeling my way through the darkness Guided by a beating heart I can't tell where the journey will end But i know where to start Wake Me up -AviciiFeeling my way through the darkness Guided by a beating heart I canâ€™t tell where the journey will end But i know where to start They tell me Iâ€™m too young to understand They say Iâ€™m caught up in a dream Well life will pass me by if i donâ€™t open up my eyes Well thatâ€™s fine by me So wake me up when itâ€™s all over When Iâ€™m wiser and Iâ€™m older All this time I was finding myself And I didâ€™t know I was lost I tried carrying the weight of the world But I only hava two hands All this time I was finding myself And I didnâ€™t know I was lost I tried carrying the weight of the world But I only have two hands I hope I get the chance to travel the world But I donâ€™t have any plans I wish that I could stay forever this young Not afraid to close my eyes Lifeâ€™s a game made for everyone And love is the prize So wake me up when itâ€™s all over When Iâ€™m wiser and Iâ€™m older All this time I was finding myself And I didnâ€™t know I was lost So wake me up when itâ€™s all over When Iâ€™m wiser and Iâ€™m older All this time I was finding myself And I didnâ€™t know I was lost So wake me up when itâ€™s all over When Iâ€™m wiser and Iâ€™m older All this time I was finding myself And I didnâ€™t know I was lost I didnâ€™t know I was lost I didnâ€™t know I was lost I didnâ€™t know I was lost I didnâ€™t know I was lost I didnâ€™t know I was lost So wake me up when itâ€™s all over When Iâ€™m wiser and Iâ€™m older All this time I was finding myself And I didnâ€™t know I was lost","link":"/2019/03/07/wake-me-up/"},{"title":"Filamentå®žçŽ°ç®€æ˜“Animoji","text":"Animojiæ˜¯é¦–å…ˆç”±è‹¹æžœæå‡ºçš„å¢žå¼ºçŽ°å®žè¡¨æƒ…åŒ…ï¼Œåˆ©ç”¨æ‘„åƒå¤´æ•æ‰åˆ°çš„é¢éƒ¨ç‰¹å¾ç‚¹ï¼ŒåŠéº¦å…‹é£Žè®°å½•çš„å£°éŸ³ï¼Œæœ€ç»ˆç”Ÿæˆçš„3DåŠ¨ç”»è¡¨æƒ…ã€‚æˆ‘ä»¬å°è¯•åœ¨Androidä¸Šå®žçŽ°ç±»ä¼¼çš„æ•ˆæžœï¼ŒäºŽæ˜¯æœ‰äº†è¿™ç¯‡æ–‡ç« è®°å½•æŠ€æœ¯é‡ç‚¹ã€‚ ç‰¹å¾ç‚¹æ•æ‰æ¨¡åž‹é€‰ç”¨Face meshï¼ˆå¦‚æžœå¯¹çœ¼çƒè½¬åŠ¨æœ‰æ•æ‰è¦æ±‚å¯ä»¥ä½¿ç”¨Irisï¼‰ï¼Œè°·æ­Œç»™å‡ºäº†å…¶æ•æ‰çš„468ä¸ªç‰¹å¾ç‚¹åæ ‡å›¾ï¼Œæˆ‘ä»¬åœ¨æ‰¾åˆ°éœ€è¦çš„ç‰¹å¾ç‚¹åŽï¼Œé€šè¿‡å‡æ³•å¾—åˆ°è¡¨æƒ…å€¼å¤§å°ï¼Œä»Žè€Œè®¡ç®—å‡ºåŠ æƒé¡¶ç‚¹åæ ‡ä½ç½®å¯¹åº”çš„æ¨¡åž‹æ•ˆæžœã€‚ åœ¨ç¥žç»ç½‘ç»œæŽ¨ç†æ¡†æž¶çš„é€‰æ‹©ä¸Šï¼Œncnnç›¸å¯¹äºŽMediaPipeæœ‰æ›´é«˜çš„æ€§èƒ½ä¼˜åŠ¿ï¼Œä½†æ˜¯å…¶cameraç›¸å…³åŠŸèƒ½ä½¿ç”¨camera2NDKï¼Œéƒ¨åˆ†æœºåž‹åº•å±‚å¹¶ä¸æ”¯æŒä»¥è‡³äºŽå‡ºçŽ°é»‘å±çŽ°è±¡ï¼Œæ‰€ä»¥è€ƒè™‘åˆ°demoçš„å®žçŽ°æ•ˆçŽ‡ï¼Œæˆ‘ä»¬é€‰ç”¨mediapipeï¼Œè‹¥æƒ³æŠŠæ­¤åŠŸèƒ½è¿ç”¨åœ¨å•†ä¸šäº§å“ä¸Šï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ncnnå¹¶æ›¿æ¢åˆ°cameraéƒ¨åˆ†å®žçŽ°ã€‚ irisåœ¨face meshåŸºç¡€ä¸Šå¢žåŠ äº†Irisåœ°æ ‡æ¨¡åž‹ï¼Œå¦‚ä¸‹å›¾3dè¡¨æƒ…çœ¼ç çš„åŒºåˆ«ï¼š iris vs face_mesh 3Då¼•æ“Žæ¸²æŸ“å·¥å…·æˆ‘ä»¬é€‰æ‹©Filamentä½œä¸º3Dæ¨¡åž‹æ¸²æŸ“åº“ï¼Œä¸€æ˜¯å…¶ç”¨äºŽAndroidè®¾å¤‡ä¸Šçš„Sceneformåº“ä¸­å®žçŽ°ARCoreï¼ŒäºŒæ˜¯å…¶ä¼˜ç§€çš„3Dæ¸²æŸ“æ•ˆæžœåŠä½Žè€—èƒ½ã€‚å½“ç„¶æˆ‘ä»¬å› ä¸ºä¸å¯æŠ—æ‹’å› ç´ æ— æ³•ç›´æŽ¥ä½¿ç”¨ARCoreï¼Œå¯¹Filamentçš„å­¦ä¹ åŠ¿åœ¨å¿…è¡Œã€‚ Filamentä¸ä»…æœ‰è‡ªå·±çš„æ¨¡åž‹æ ¼å¼ï¼Œä¸”æ”¯æŒglb/gltfï¼Œå¹¶ä¸”æä¾›apiæ“ä½œèŠ‚ç‚¹ï¼Œåœ¨åˆæ­¥äº†è§£å…‰ç…§ã€å¤©ç©ºç›’ç­‰æ¦‚å¿µåŽï¼Œå¼€å§‹ç¼–å†™demoã€‚ ä»Žæ‘„åƒå¤´èŽ·å–é¢éƒ¨æ¨¡åž‹Mediapipeå·²ç»æŠŠcameraæ•°æ®è½¬æ¢æˆäº†textureFrameï¼Œè¿›è€Œè§¦å‘filamentæ¸²æŸ“æ¨¡åž‹ã€‚filament demoæä¾›çš„Choreographerè§¦å‘æ–¹å¼åœ¨æ­¤æ˜¯è¡Œä¸é€šçš„ï¼Œåž‚ç›´åŒæ­¥æ—¶é—´æˆ³å·²ç»æ˜¯æœ€å°åˆ·æ–°é—´éš”ï¼ŒåŒæ—¶ä½¿ç”¨ä¼šå‡ºçŽ°ä¸¥é‡çš„å¡é¡¿é—®é¢˜ã€‚ ä»Žç‰¹å¾ç‚¹åˆ°3Dæ¨¡åž‹é‚£ä¹ˆå¦‚ä½•æŠŠæ¨¡åž‹æ•æ‰åˆ°çš„ç‰¹å¾ç‚¹è½¬åŒ–ä¸º3Dè¡¨æƒ…å‘¢ï¼Ÿè¿™é‡Œä»¥å¼ å˜´ä¸ºä¾‹ï¼Œè®¾è®¡ç»™å‡ºçš„GLBæ–‡ä»¶å·²ç»å®šä¹‰å¥½å˜´éƒ¨åŠ¨ä½œçš„æƒé‡ï¼Œå¦‚â€weightsâ€ { &quot;extras&quot;: { &quot;targetNames&quot;: [ &quot;xx&quot; ] }, &quot;name&quot;: &quot;mouth&quot;, &quot;primitives&quot;: [ { &quot;attributes&quot;: { &quot;POSITION&quot;: 0, &quot;NORMAL&quot;: 1 }, &quot;indices&quot;: 2, &quot;material&quot;: 0, &quot;targets&quot;: [ { &quot;POSITION&quot;: 3, &quot;NORMAL&quot;: 4 } ] } ], &quot;weights&quot;: [ 1 ]}, å¯ä»¥çœ‹åˆ°â€weightsâ€æƒé‡é»˜è®¤ä¸º1ï¼Œæˆ‘ä»¬é€šè¿‡èŽ·å–ç‰¹å¾ç‚¹åæ ‡17ã€0å¤„yè½´åæ ‡å€¼ï¼Œè½¬æ¢ndcåæ ‡åŽï¼Œåšå‡æ³•å¾—å‡ºå˜´å·´å¼ å¼€åº¦ï¼Œä»Žä½•èŽ·å–å…¶æƒé‡ val landmarkList = faceMeshResult.multiFaceLandmarks()[0](landmarkList.getLandmark(17).y - 1) * PROJECTION_SCALE - (landmarkList.getLandmark(0).y - 1) * PROJECTION_SCALE Filamentè°ƒç”¨setMorphWeightsè®¾ç½®mouthèŠ‚ç‚¹æƒé‡ï¼Œä»Žè€Œå®žçŽ°å˜´éƒ¨çš„å¼€é—­ã€‚ modelViewer.engine.renderableManager.setMorphWeights( modelViewer.engine.renderableManager.getInstance(modelViewer.asset!!.getFirstEntityByName(&quot;mouth&quot;)), floatArrayOf(1 - 5f * mouthHeight, 0f, 0f, 0f), 0) åœ¨é•œå¤´å‰éœ€è¦ç§»åŠ¨å¤´éƒ¨æ¨¡åž‹ï¼Œé‚£ä¹ˆå¦‚ä½•å®žçŽ°æ¨¡åž‹çš„ç§»åŠ¨å‘¢ï¼Œæˆ‘ä»¬å†³å®šé€‰ç”¨é¼»å­é¡¶éƒ¨åæ ‡æ¥æ˜ å°„æ¨¡åž‹ç§»åŠ¨,å³94å¤„åæ ‡ã€‚ Matrix.setIdentityM(transformMatrix, 0) Matrix.rotateM(transformMatrix, 0, 180f, 0f, 4f, 0f) Matrix.translateM(transformMatrix, 0, 0f, 0f, 4f) Matrix.translateM( transformMatrix, 0, -(noseCoord.x - ratio) * PROJECTION_SCALE, -(noseCoord.y - ratio) * PROJECTION_SCALE, 0f) Filamentä½¿ç”¨setTransformå³å¯å®žçŽ°æ¨¡åž‹ç§»åŠ¨ï¼Œå¦‚ä¸Šå¯å®žçŽ°ç®€æ˜“çš„animojiæ•ˆæžœã€‚","link":"/2022/07/25/Filament%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93Animoji/"},{"title":"äº‘æ‰‹æœºopenvmiæ­å»º","text":"è™½ç„¶ä»˜è´¹äº‘æ‰‹æœºæœåŠ¡æ¯”è¾ƒå¤šï¼Œä½†æ˜¯å¼€æºé¡¹ç›®éžå¸¸å°‘ï¼Œæœ¬æ–‡å°†åˆ†äº«æ­å»ºopenvmiè¿‡ç¨‹ï¼Œèµ„æºå¤ªå°‘ï¼Œå¸Œæœ›æœ‰æ‰€å¸®åŠ©ã€‚ ä¸ºäº†è¿‡ç¨‹å®Œæ•´æ€§ï¼Œæ–‡ç« ä¸Žopenvmiæ–‡æ¡£ä¼šæœ‰æ‰€é‡å¤ï¼Œç€é‡è®²è§£è¸©è¿‡çš„å‘ï¼Œç‰¹åˆ«æ˜¯å¯¹äºŽandroidå¼€å‘è€…è€Œè¨€æœ‰æ‰€éš¾åº¦çš„k8sæ­å»ºè¿‡ç¨‹ã€‚æµç¨‹åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼šandroidé•œåƒç¼–è¯‘ã€k8sçŽ¯å¢ƒæ­å»º/è°ƒè¯• Androidé•œåƒç¼–è¯‘aospçš„ç½‘ç»œè¦æ±‚å¾ˆé«˜ï¼Œç¬”è€…åœ¨è¿™ä¸Šé¢å®°äº†å¾ˆå¤šè·Ÿå¤´ï¼Œmac m1ã€mac x86ã€ubuntuï¼Œæœ€åŽåœ¨è…¾è®¯äº‘ä¹°äº†8æ ¸32Gã€100må¸¦å®½çš„é¦™æ¸¯æœåŠ¡å™¨ï¼ˆubuntu18.04 x86 50Gï¼‰10åˆ†é’Ÿæžå®šaospæ‹‰å–ï¼ˆç«žä»·æ¨¡å¼ï¼Œè°ç”¨è°çŸ¥é“ï¼‰ã€‚ å®‰è£…ä¾èµ–è½¯ä»¶sudo apt install -y build-essential cmake cmake-data debhelper dbus google-mock \\ libboost-dev libboost-filesystem-dev libboost-log-dev libboost-iostreams-dev \\ libboost-program-options-dev libboost-system-dev libboost-test-dev \\ libboost-thread-dev libcap-dev libsystemd-dev libegl1-mesa-dev \\ libgles2-mesa-dev libglm-dev libgtest-dev liblxc1 \\ libproperties-cpp-dev libprotobuf-dev libsdl2-dev libsdl2-image-dev lxc-dev \\ pkg-config protobuf-compiler python-minimal linux-headers-`uname -r` ç¼–è¯‘openvmi// ä¸‹è½½æºç $ cd ~git clone https://github.com/DockDroid/openvmi.git// ç¼–è¯‘ä¸Žå®‰è£…å†…æ ¸æ¨¡å—sudo mkdir -p /opt/openvmi/driver/cd ~/openvmi/kernel/binder/makesudo cp binder_linux.ko /opt/openvmi/driver/cd ../ashmem/makesudo cp ashmem_linux.ko /opt/openvmi/driver/// ç¼–è¯‘ä¸Žå®‰è£…openvmicd ~/openvmimkdir buildcd buildcmake ..make -j8 installsudo mkdir -p /opt/openvmi/bin/ /opt/openvmi/libs/libswiftshadersudo cp bin/openvmi /opt/openvmi/bin/sudo cp ../libs/* /opt/openvmi/libs/libswiftshader/ æ­å»ºAndroidé•œåƒç¼–è¯‘çŽ¯å¢ƒ// å®‰è£…JDKsudo apt-get updatesudo apt-get install openjdk-8-jdk// ç¼–è¯‘ä¾èµ–åº“sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-devsudo apt-get install git-core gnupg flex bison gperf build-essential sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib sudo apt-get install libc6-dev-i386 sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4sudo apt-get install lib32z-dev ccache// ç‹¬ç«‹è¾“å‡ºç›®å½•æ˜“äºŽæé«˜IOexport OUT_DIR_COMMON_BASE=~/out//ccacheæœ‰éœ€è¦çš„å¯ä»¥é€‰æ‹©ï¼Œæœ¬äººæœªå®‰è£… ç¼–è¯‘Androidé•œåƒæ­¤å¤„æ³¨æ„ â€“depth=1 -c ä¸Žå®˜æ–¹çš„ä¸åŒï¼Œç¬”è€…åœ¨ä½¿ç”¨repoæ‹‰å–æºç çš„æ—¶å€™ï¼Œæ‹‰åˆ°500Géƒ½ä¸å¤Ÿç”¨ï¼Œè¿™é‡Œè¦æŒ‡å®šcloneæ·±åº¦ï¼Œä¸éœ€è¦gitåä½œçš„åŽ†å²è®°å½•ï¼›åªåŒæ­¥æŒ‡å®šåˆ†æ”¯ï¼Œä¸æ‹‰åŽ»å…¶ä»–åˆ†æ”¯ã€‚ // å®‰è£…repomkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo//æ‹‰å–æºç mkdir $HOME/openvmi-workcd $HOME/openvmi-workrepo init -u https://github.com/DockDroid/platform_manifests.git -b openvmi --depth=1repo sync -c -j32//100m/sï¼Œ10åˆ†é’Ÿæžå®šï¼Œâœ¿âœ¿ãƒ½(Â°â–½Â°)ãƒŽâœ¿ ç¼–è¯‘Androidæºç å¹¶éžå•çº¯çš„aospï¼Œè¿˜åŠ å…¥äº†openvmiäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå³ä¸Šé¢ç¼–è¯‘çš„openvmi // æ‹·è´openvmimkdir vendormv ~/openvmi ~/openvmi-work/vendor/openvmi// åˆå§‹åŒ–çŽ¯å¢ƒï¼ˆè¿™é‡Œè¾“å‡ºä¸¤æ¡æ—¥å¿—ï¼Œå¦‚æ²¡æœ‰ï¼Œåº”è¯¥æ˜¯syncä¸å®Œå…¨ï¼‰source build/envsetup.sh// æž„å»ºlunchlunch openvmi_arm64-userdebug// å¼€æ•´export LC_ALL=Cmake -j32//å¦‚é‡åˆ°Jack server failed to ,SSL error when connecting to the Jack server. Try 'jack-diagnose'åœ¨ /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/security/java.security ä¸­åˆ é™¤jdk.tls.disabledAlgorithmsé…ç½®ä¸­çš„&quot;TLSv1,TLSv1.1&quot;ã€‚// å¢žåŠ openvmiæ”¯æŒcd $HOME/openvmi-work/vendor/openvmiscripts/create-package.sh \\ /root/openvmi-work/out/target/product/arm64/ramdisk.img \\ /root/openvmi-work/out/target/product/arm64/system.img è‡³æ­¤ï¼Œé•œåƒç¼–è¯‘å®Œæ¯•ã€‚ k8så¹³å°æ­å»ºå®˜æ–¹æ–‡æ¡£è®°å½•çš„å¾ˆæ¸…æ™°ï¼Œä½†ç”±äºŽç½‘ç»œçŽ¯å¢ƒçš„é—®é¢˜ï¼Œå¯¼è‡´Kube-flannelä¸€ç›´æœ‰é—®é¢˜ï¼Œdns podæ‹‰ä¸èµ·æ¥ï¼Œç¬”è€…åœ¨kube-flannel.ymlæ–‡ä»¶æ‰¾åˆ°imageï¼Œä¸€æ¬¡å•ç‹¬pullåŽè§£å†³ã€‚ç”±äºŽèµ„æºæœ‰é™ï¼Œä»¥å•æœºk8sçš„å½¢å¼æ­å»ºï¼Œè‹¥æƒ³æ­å»ºé›†ç¾¤ï¼ŒæŒ‰æ–‡æ¡£åŠ å…¥wokerèŠ‚ç‚¹å³å¯ã€‚ ç›¸å…³å·¥å…·å®‰è£…// å·¥å…·æ‹‰å–cd ~git clone https://github.com/DockDroid/cloud-platform.git// dockerå®‰è£…// dockeré…ç½®æ–‡ä»¶sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;], &quot;log-driver&quot;: &quot;json-file&quot;, &quot;log-opts&quot;: { &quot;max-size&quot;: &quot;100m&quot; }, &quot;storage-driver&quot;: &quot;overlay2&quot;}EOF//æ·»åŠ é˜¿é‡Œæºsudo add-apt-repository &quot;deb [arch=arm64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;//å®‰è£…dockersudo apt-get install docker-ce=5:18.09.9~3-0~ubuntu-bionic//k8sè¿è¡ŒçŽ¯å¢ƒå®‰è£…//å…³é—­swapåˆ†åŒºäº¤æ¢sudo swapoff -asudo vi /etc/fstab #ä»¥â€œ#â€æ³¨é‡Šswapfileæ‰“å¤´çš„é‚£ä¸€è¡Œ//æ·»åŠ k8sç›¸å…³å‘½ä»¤è¡Œå·¥å…·å®‰è£…æºcurl https://mirrors.huaweicloud.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - cat &lt;&lt; EOF | sudo tee /etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.huaweicloud.com/kubernetes/apt kubernetes-xenial mainEOFsudo apt-get update// å®‰è£…k8så‘½ä»¤è¡Œå·¥å…·sudo apt-get install kubelet=1.14.2-00 kubeadm=1.14.2-00 kubectl=1.14.2-00 kubernetes-cni=0.7.5-00 //æ‰‹åŠ¨æ‹‰å–k8s Masterè¿è¡Œç»„ä»¶çš„dockeré•œåƒdocker pull docker.io/mirrorgooglecontainers/kube-apiserver-arm64:v1.14.2 docker pull docker.io/mirrorgooglecontainers/kube-controller-manager-arm64:v1.14.2 docker pull docker.io/mirrorgooglecontainers/kube-scheduler-arm64:v1.14.2 docker pull docker.io/mirrorgooglecontainers/kube-proxy-arm64:v1.14.2 docker pull docker.io/mirrorgooglecontainers/pause-arm64:3.1 docker pull docker.io/mirrorgooglecontainers/etcd-arm64:3.3.10 docker pull docker.io/coredns/coredns:1.3.1//ä¿®æ”¹tagdocker tag docker.io/mirrorgooglecontainers/kube-apiserver-arm64:v1.14.2 k8s.gcr.io/kube-apiserver:v1.14.2 docker tag docker.io/mirrorgooglecontainers/kube-controller-manager-arm64:v1.14.2 k8s.gcr.io/kube-controller-manager:v1.14.2 docker tag docker.io/mirrorgooglecontainers/kube-scheduler-arm64:v1.14.2 k8s.gcr.io/kube-scheduler:v1.14.2 docker tag docker.io/mirrorgooglecontainers/kube-proxy-arm64:v1.14.2 k8s.gcr.io/kube-proxy:v1.14.2 docker tag docker.io/mirrorgooglecontainers/pause-arm64:3.1 k8s.gcr.io/pause:3.1 docker tag docker.io/mirrorgooglecontainers/etcd-arm64:3.3.10 k8s.gcr.io/etcd:3.3.10 docker tag docker.io/coredns/coredns:1.3.1 k8s.gcr.io/coredns:1.3.1//åˆ é™¤åŽŸtagdocker rmi docker.io/mirrorgooglecontainers/kube-apiserver-arm64:v1.14.2 docker rmi docker.io/mirrorgooglecontainers/kube-controller-manager-arm64:v1.14.2 docker rmi docker.io/mirrorgooglecontainers/kube-scheduler-arm64:v1.14.2 docker rmi docker.io/mirrorgooglecontainers/kube-proxy-arm64:v1.14.2 docker rmi docker.io/mirrorgooglecontainers/pause-arm64:3.1 docker rmi docker.io/mirrorgooglecontainers/etcd-arm64:3.3.10 docker rmi docker.io/coredns/coredns:1.3.1 k8så®‰è£…sudo kubeadm init --pod-network-cidr=10.244.0.0/16 --kubernetes-version=v1.14.2 --image-repository registry.aliyuncs.com/google_containers//kubectlæ‰§è¡Œæƒé™sudo mkdir $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config k8sç½‘ç»œæ’ä»¶å®‰è£…ç¬”è€…ä½¿ç”¨kube-flannel 0.15.1ç‰ˆæœ¬ï¼Œæ‰¾åˆ°kube-flannel ä¸­imageé…ç½®ï¼Œå¹¶æå‰pullé•œåƒæ¥è§„é¿ç½‘ç»œçŽ¯å¢ƒé€ æˆdns,flannel-adsæ‹‰ä¸èµ·æ¥çš„é—®é¢˜ï¼Œæ­¥éª¤å¦‚ä¸‹ï¼š docker pull rancher/mirrored-flannelcni-flannel-cni-plugin:v1.0.0-arm64docker pull quay.io/coreos/flannel:v0.15.1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.15.1/Documentation/kube-flannel.yml k8sçŠ¶æ€æŸ¥è¯¢è¿™é‡Œæä¾›ä¸€äº›å¥½ç”¨çš„å‘½ä»¤ï¼Œç”¨ä»¥æŸ¥çœ‹K8sæ­å»ºæƒ…å†µï¼Œåœ¨å®žé™…æ­å»ºè¿‡ç¨‹ä¸­ï¼Œè¦æ³¨æ„å¦‚ä¸‹å‘½ä»¤çš„ä½¿ç”¨ï¼Œå¦‚å‘çŽ°podå¤„äºŽpendingæˆ–è€…è¯´éžRunningçŠ¶æ€ï¼Œå¤§æ¦‚çŽ‡æ˜¯é•œåƒæ‹‰å–å¤±è´¥ï¼Œéœ€è€ƒè™‘ä¸Šé¢æ­¥éª¤æ˜¯å¦æ‰§è¡ŒæˆåŠŸ //æŸ¥çœ‹æœ¬åœ°é•œåƒä¸‹è½½æƒ…å†µdocker images//æŸ¥çœ‹å½“å‰é•œåƒè¿è¡Œæƒ…å†µdocker ps -a//æŸ¥çœ‹podçŠ¶æ€ï¼ŒéžRunningçŠ¶æ€è¯´æ˜Žéƒ¨ç½²æœ‰é—®é¢˜kubectl get pods -A//æŸ¥çœ‹nodeçŠ¶æ€ï¼Œéœ€è¦ReadyçŠ¶æ€kubectl get node//æŸ¥çœ‹æŒ‡å®špodï¼Œnodeè¯¦ç»†çŠ¶å†µkubectl describe node master-01kubectl describe pod coredns-000010-01 -n kube-system//æŸ¥çœ‹ç›¸å…³æœåŠ¡çŠ¶æ€åŠæ—¥å¿—systemctl status kubelet openvmiæœåŠ¡é…ç½®ç¼–è¯‘openvmié•œåƒmkdir mount_dirsudo mount android.img ./mount_dircd ./mount_dirsudo tar --numeric-owner -cf- . | docker import - android:openvmi openvmiæ’ä»¶ï¼Œè¿è¡ŒçŽ¯å¢ƒç®¡ç†æœåŠ¡å®‰è£…cd cloud-platform/services/k8s-dev-plugin-servicesudo ./install.shcd cloud-platform/services/android-env-servicesudo ./install.sh dashboardé…ç½®//æ‹‰å–dashboardkubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc6/aio/deploy/recommended.yaml//ä¿®æ”¹ç«¯å£ç±»åž‹ï¼Œå°†type: ClusterIPæ”¹ä¸ºNodePortkubectl edit svc kubernetes-dashboard -n kubernetes-dashboard//æŸ¥çœ‹dashboardç«¯å£ï¼Œè¿™é‡Œéœ€è¦ä¿®æ”¹å®‰å…¨ç»„é…ç½®ï¼Œå¼€æ”¾è¯¥ç«¯å£kubectl get svc -A ä¹‹åŽé€šè¿‡https://&lt;é›†ç¾¤å…¬ç½‘ip&gt;:&lt;ä¸Šè¿°ç«¯å£&gt;ï¼Œå¦‚ä½¿ç”¨chromeå‡ºçŽ°çš„éžç§å¯†é“¾æŽ¥æç¤ºï¼Œåœ¨å½“å‰é¡µé¢é™é»˜è¾“å…¥â€thisisunsafeâ€å³å¯è§„é¿ã€‚ é…ç½®tokentouch dashboard.yamlvim dashboard.yaml//é”®å…¥å¦‚ä¸‹å†…å®¹apiVersion: v1kind: ServiceAccountmetadata: name: admin-user namespace: kubernetes-dashboard---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: admin-userroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard// åˆ›å»ºè´¦å·kubectl apply -f dashboard.yaml// ç”Ÿæˆtokenkubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '{print $1}')\\ ä¹‹åŽä¾¿å¯å…¬ç½‘è®¿é—®é›†ç¾¤ä»ªè¡¨ç›˜ï¼ŒæŸ¥çœ‹é›†ç¾¤è¿è¡Œæƒ…å†µã€‚ é²²é¹920æœåŠ¡å™¨æž¶æž„å¯¼è‡´createå¤±è´¥ç›®å‰åŽä¸ºäº‘æœåŠ¡å™¨å‡ä¸ºé²²é¹920çº¯armv8æž¶æž„ï¼Œåªæ”¯æŒ64ä½Appï¼Œéœ€è¦ä¿®æ”¹å¦‚ä¸‹é…ç½®åŽå†ç¼–è¯‘ç³»ç»Ÿé•œåƒï¼š device/openvmi/arm64// ä¿®æ”¹BoardConfig.mkï¼š#TARGET_2ND_ARCH := arm#TARGET_2ND_ARCH_VARIANT := armv7-a-neon#TARGET_2ND_CPU_VARIANT := cortex-a15#TARGET_2ND_CPU_ABI := armeabi-v7a#TARGET_2ND_CPU_ABI2 := armeabi// ä¿®æ”¹device.mkï¼šPRODUCT_COPY_FILES += system/core/rootdir/init.zygote64.rc:root/init.zygote64.rcPRODUCT_DEFAULT_PROPERTY_OVERRIDES += ro.zygote=zygote64TARGET_SUPPORTS_32_BIT_APPS := falseTARGET_SUPPORTS_64_BIT_APPS := true ä½¿ç”¨ç›¸å…³è„šæœ¬ä½äºŽcloud-platform/tools/android-vm-manage.shä¸­ï¼Œandroidè™šæ‹Ÿæœºç›¸å…³é…ç½®å¯è‡ªå®šä¹‰ï¼Œæ ¹æ®æœåŠ¡å™¨çŠ¶å†µå¡«å†™ï¼Œé»˜è®¤æ˜¯4æ ¸4Gã€720*1280ï¼Œé’ˆå¯¹å•æœºå¯åŠ¨å‘½ä»¤å¦‚ä¸‹ï¼š // åœ¨å½“å‰æœåŠ¡å™¨åˆ›å»ºä¸€å°ç¼–å·ä¸º1çš„è™šæ‹Ÿæœºï¼ŒcreateæˆåŠŸåŽä¼šè‡ªåŠ¨å¼€æœºï¼Œä¸éœ€è¦æ‰§è¡Œstartupæ“ä½œ./android-vm-manage create - 1//å…¶ä»–å‘½ä»¤è‡ªè¡ŒæŸ¥æ‰¾ ä»¥ä¸ŠåŸºæœ¬èƒ½å®Œæˆopenvmiæ­å»ºï¼Œè¯»è€…å¯ä»¥åœ¨äº‘æ‰‹æœºä½¿ç”¨æŒ‡å¯¼ä¸­å­¦ä¹ å¦‚ä½•è¿œç«¯ä½¿ç”¨äº‘æ‰‹æœºï¼Œå¹¶æ•ˆéªŒæˆæžœã€‚","link":"/2022/11/11/%E4%BA%91%E6%89%8B%E6%9C%BAopenvmi%E6%90%AD%E5%BB%BA/"},{"title":"å†²çªä¸­å¯¹ä¸­è§„ä¸­çŸ©çš„è®¤è¯†","text":"æ¯ä¸ªä¸ªä½“ä¹‹é—´å¿…ç„¶å­˜åœ¨å†²çªï¼Œå¯¹æ¯ä»¶äº‹ç‰©çš„ç†è§£ï¼Œå¤„ç†æ¯ä»¶äº‹æƒ…çš„æ–¹å¼ï¼Œä¸€ä¸‡ä¸ªäººå¿ƒä¸­æœ‰ä¸€ä¸‡ä¸ªå“ˆå§†é›·ç‰¹ï¼Œè¿™æ‰æ˜¯æœ‰è¶£çš„åœ°æ–¹ï¼Œä¸ä¸€æ ·æ‰æ˜¯æœ‰è¶£çš„éƒ¨åˆ†ï¼Œå¦‚æžœéƒ½ä¸€æ ·å²‚ä¸æ˜¯æœºå™¨ã€‚ å†²çªæ¯ä¸ªä¸ªä½“ä¹‹é—´å¿…ç„¶å­˜åœ¨å†²çªï¼Œå¯¹æ¯ä»¶äº‹ç‰©çš„ç†è§£ï¼Œå¤„ç†æ¯ä»¶äº‹æƒ…çš„æ–¹å¼ï¼Œä¸€ä¸‡ä¸ªäººå¿ƒä¸­æœ‰ä¸€ä¸‡ä¸ªå“ˆå§†é›·ç‰¹ï¼Œè¿™æ‰æ˜¯æœ‰è¶£çš„åœ°æ–¹ï¼Œä¸ä¸€æ ·æ‰æ˜¯æœ‰è¶£çš„éƒ¨åˆ†ï¼Œå¦‚æžœéƒ½ä¸€æ ·å²‚ä¸æ˜¯æœºå™¨ã€‚ æˆ‘ä»¬æŠŠå…³æ³¨ç‚¹æ”¾åœ¨äº†ä¸ªä½“ä¸åŒé€ æˆçš„å†²çªä¸Šï¼Œç´§æŽ¥ç€çœ‹åˆ°çš„æ˜¯å†²çªå‡çº§ï¼Œå¦‚æžœæˆ‘ä»¬ä¸å¤Ÿå¼ºå¤§ï¼Œå¾€å¾€ä¼šæˆä¸ºåƒå¤«æ‰€æŒ‡ï¼Œå› ä¸ºå…è®¸å†²çªå­˜åœ¨æ‰æ˜¯ç¤¾ä¼šçš„æ¸¸æˆè§„åˆ™ï¼Œæ¯ä¸ªäººéƒ½åœ¨è¯•å›¾éšè—è‡ªå·±çš„ä¸å¹¸ï¼Œå¹¶ç”¨å„ç§æ–¹å¼åŽ»å¼ºè°ƒè‡ªå·±çš„é•¿å¤„ï¼Œä»–ä»¬æ‰€è®¤ä¸ºè‡ªå·±æ‹¥æœ‰çš„é•¿å¤„ï¼Œæ‰€ç”¨çš„æ‰‹æ®µæ›´æ˜¯åƒå¥‡ç™¾æ€ªã€‚åªè¦æ˜¯ä¸æŸå®³ä»–äººåˆ©ç›Šï¼Œæ‰‹æ®µå°±ç®—æ˜¯åˆç†çš„ï¼Œè¢«é»˜è®¸ï¼ŒåŒæ–¹ç›¸å®‰æ— äº‹ï¼Œå„å®‰å…¶ä½ã€‚çªç„¶æœ‰ä¸€å¤©å‡ºçŽ°ä¸€ä¸ªäººï¼ŒæŒ‡å‡ºè¿™äº›æ‰‹æ®µæ˜¯ä¸åˆç†çš„ï¼Œå¹¶å‘Šè¯‰å¤§å®¶è¿™ç®—ä¸ä¸Šæ˜¯é•¿å¤„ã€‚ç„¶åŽé™é»˜è¢«æ‰“ç ´ï¼Œæ¯ä¸ªäººéƒ½æ‹…å¿ƒè‡ªå·±çš„æ‰‹æ®µè¢«æŒ‘æ˜Žï¼Œå¤§å®¶äººå¿ƒæƒ¶æƒ¶â€¦ ä¸ç”¨å¤šä¹…,å¤§å®¶å°±ä¼šæ‰¾åˆ°è‡ªå·±çš„æ–¹å¼åŽ»ä¿æŠ¤è‡ªå·±ï¼Œæ‰€ä»¥åƒå¤«æ‰€æŒ‡æ˜¯å¿…ç„¶ã€‚ è§‚å¯Ÿå¹¶æ€è€ƒï¼Œç„¶åŽå®žè·µã€‚ è¿›å…¥è¿™ä¸ªå›¢ä½“ï¼Œéµå®ˆæ‰€è°“çš„è§„åˆ™ï¼Œä¿æŠ¤å¥½è‡ªå·±çš„ä¸åŒï¼Œä»»é£Žé›¨è¢­æ¥ï¼Œæˆ‘è‡ªå·ç„¶ä¸åŠ¨ã€‚ ä¸­è§„ä¸­çŸ©&quot;é€‰æ‹©ç”Ÿæ´»ï¼Œé€‰æ‹©å·¥ä½œï¼Œé€‰æ‹©èŒä¸šï¼Œé€‰æ‹©å®¶åº­ã€‚é€‰æ‹©ä»–å¦ˆçš„ä¸€ä¸ªå¤§ç”µè§†ã€‚é€‰æ‹©æ´—è¡£æœºï¼Œæ±½è½¦ï¼Œé›·å°„å”±æœºï¼Œç”µåŠ¨å¼€ç½æœºã€‚é€‰æ‹©å¥åº·ï¼Œä½Žå¡é‡Œè·¯ï¼Œä½Žç³–ã€‚é€‰æ‹©å›ºå®šåˆ©çŽ‡æˆ¿è´·ã€‚é€‰æ‹©èµ·ç‚¹ï¼Œé€‰æ‹©æœ‹å‹ï¼Œé€‰æ‹©è¿åŠ¨æœå’Œçš®ç®±ã€‚é€‰æ‹©ä¸€å¥—ä»–å¦ˆçš„ä¸‰ä»¶å¥—è¥¿è£…ã€‚â€¦â€¦é€‰æ‹©DIYï¼Œåœ¨ä¸€ä¸ªæ˜ŸæœŸå¤©æ—©ä¸Šï¼Œä»–å¦ˆçš„æžä¸æ¸…è‡ªå·±æ˜¯è°ã€‚é€‰æ‹©åœ¨æ²™å‘ä¸Šçœ‹æ— èŠé€é¡¶çš„èŠ‚ç›®ï¼Œå¾€å£é‡Œå¡žåžƒåœ¾é£Ÿç‰©ã€‚é€‰æ‹©è…æœ½ï¼Œç”±ä½ ç²¾å­é€ å‡ºå–ä»£ä½ çš„è‡ªç§å°é¬¼ï¼Œå¯ä»¥è¯´æ˜¯æœ€æ— è€»çš„äº‹äº†ã€‚é€‰æ‹©ä½ çš„æœªæ¥ï¼Œä½ çš„ç”Ÿæ´»ã€‚ä½†æˆ‘å¹²å˜›è¦åšï¼Ÿæˆ‘é€‰æ‹©ä¸è¦ç”Ÿæ´»ï¼Œæˆ‘é€‰æ‹©å…¶ä»–ã€‚ç†ç”±å‘¢ï¼Ÿæ²¡æœ‰ç†ç”±ã€‚åªè¦æœ‰æµ·æ´›å› ï¼Œè¿˜è¦ä»€ä¹ˆç†ç”±&quot; ---â€œçŒœç«è½¦â€ åˆšæ¯•ä¸šé‚£ä¼šå„¿æˆ‘ä»¥ä¸ºæˆ‘çš„ä¸€ç”Ÿå°±åƒæ˜¯åœ¨å»ºä¸€åº§æ‘©å¤©å¤§åŽ¦ï¼Œç¨æœ‰ä¸€ç‚¹åå·®å°±ä¼šè½°ç„¶å´©å¡Œã€‚æ…¢æ…¢çš„æˆ‘å‘çŽ°ï¼Œäººä»¬å¹¶ä¸æ˜¯å°å¿ƒç¿¼ç¿¼çš„åŽ»å¯¹å¾…è‡ªå·±ï¼Œâ€œå·®ä¸å¤šå°±è¡Œäº†â€ï¼Œå¥½åƒæˆäº†å¤§å®¶çš„å£å¤´ç¦…ï¼Œå¾—è¿‡ä¸”è¿‡ã€‚æˆ‘å´ä¾ç„¶ä¸è¿™ä¹ˆè®¤ä¸ºï¼Œå´æœ‰ä¸€äº›ç»†å¾®çš„æ”¹å˜ï¼Œæ²¡æœ‰100%æ­£ç¡®çš„å†³å®šï¼Œåªéœ€è¦åœ¨å†³å®šåŽåŠªåŠ›å®Œå–„ï¼Œä¸€æ­¥ä¸€æ­¥è®©å†³å®šå˜å¾—æ›´åŠ æ­£ç¡®ã€‚ â€œå·®ä¸å¤šå°±è¡Œï¼Ÿâ€ â€œå·®ä¸å¤šå°±è¡Œï¼â€ è¿™å¥è¯åº”è¯¥æ˜¯æ­£ç¡®çš„ï¼Œåªæ˜¯ç›®æ ‡å˜æˆäº†åˆ«äººã€‚ä¸¥äºŽå¾‹å·±ï¼Œå®½ä»¥å¾…äººï¼Œæ‡‚å¾—ä¸ªä½“çš„ä¸åŒï¼Œå­¦ä¼šéµå®ˆè§„åˆ™ï¼Œä¿ç•™ä½å½¼æ­¤é—´çš„å®‰å…¨è·ç¦»ã€‚ä¸€ä¸ªäººçš„ä¸–ç•Œè§‚ï¼Œå–å†³äºŽè¿™ä¸ªäººçš„å—æ•™è‚²ç¨‹åº¦å’Œä»–çš„æˆé•¿çŽ¯å¢ƒï¼Œè€ŒäºŒè€…æ˜¯ä¸å—ä»–æŽ§åˆ¶ã€‚ä»–è‡ªå·±éƒ½æ”¹å˜ä¸äº†çš„ä¸œè¥¿ï¼Œæ—äººæ›´æ— æ³•æŒ‡æ‰‹ç”»è„šã€‚ æƒ³è¦æ‰“ç ´è§„åˆ™å°±åº”è¯¥å­¦ä¼šä¸­è§„ä¸­çŸ©ï¼Œä¸é¸£åˆ™å·²ï¼Œä¸€é¸£æƒŠäººã€‚","link":"/2017/11/25/%E5%86%B2%E7%AA%81%E4%B8%AD%E5%AF%B9%E4%B8%AD%E8%A7%84%E4%B8%AD%E7%9F%A9%E7%9A%84%E8%AE%A4%E8%AF%86/"},{"title":"åˆ©ç”¨é«˜é˜¶å‡½æ•°ç®€åŒ–ç­–ç•¥æ¨¡å¼ã€æ¨¡æ¿æ–¹æ³•æ¨¡å¼","text":"ç­–ç•¥æ¨¡å¼ã€æ¨¡æ¿æ–¹æ³•æ¨¡å¼è§£å†³çš„é—®é¢˜æ¯”è¾ƒç±»ä¼¼ï¼Œå¹¶ä¸”éƒ½å¯ä»¥ä¾é Kotlinä¸­çš„é«˜é˜¶å‡½æ•°ç‰¹æ€§è¿›è¡Œæ”¹è‰¯ã€‚ éµå¾ªå¼€é—­åŽŸåˆ™ï¼šç­–ç•¥æ¨¡å¼å‡è®¾æœ‰ä¸€ä¸ªè¡¨ç¤ºæ¸¸æ³³è¿åŠ¨å‘˜çš„æŠ½è±¡ç±»Swimmerï¼Œæœ‰ä¸€ä¸ªæ¸¸æ³³çš„æ–¹æ³•swimï¼š class Swimmer { fun swim() { println(&quot;I am swimming...&quot;) }}//invoke&gt;&gt;&gt; Swimmer().swim()I am swimming... ç”±äºŽè¿™ä½è¿åŠ¨å‘˜åœ¨æ¸¸æ³³æ–¹é¢å¾ˆæœ‰å¤©èµ‹ï¼Œä»–å¾ˆå¿«æŽŒæ¡äº†è›™æ³³ã€ä»°æ³³ã€è‡ªç”±æ³³å¤šç§å§¿åŠ¿ã€‚æ‰€ä»¥æˆ‘å°†å¯¹Swimmerè¿›è¡Œæ”¹é€ ï¼š class Swimmer { fun breaststroke() { println(&quot;I am breaststroke...&quot;) } fun backstroke() { println(&quot;I am backstroke...&quot;) } fun freestyle() { println(&quot;I am freestyling...&quot;) }} ç„¶è€Œè¿™å¹¶ä¸æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è®¾è®¡ã€‚é¦–å…ˆï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„æ¸¸æ³³è¿åŠ¨å‘˜éƒ½æŽŒæ¡äº†è¿™3ç§æ¸¸æ³³å§¿åŠ¿ï¼Œå¦‚æžœæ¯ä¸ªSwimmerç±»å¯¹è±¡éƒ½å¯ä»¥è°ƒç”¨æ‰€æœ‰æ–¹æ³•ï¼Œæ˜¾å¾—æ¯”è¾ƒå±é™©ã€‚å…¶æ¬¡ï¼ŒåŽç»­éš¾å…ä¼šæœ‰æ–°çš„è¡Œä¸ºæ–¹æ³•åŠ å…¥ï¼Œé€šè¿‡ä¿®æ”¹Swimmerç±»çš„æ–¹å¼è¿èƒŒäº†å¼€æ”¾å°é—­åŽŸåˆ™(open for extension,closed for modificationã€‚é¢å‘æ‰©å±•å¼€æ”¾ï¼Œé¢å‘ä¿®æ”¹å…³é—­)ã€‚ æ‰€ä»¥å‘¢ï¼Œæ›´å¥½çš„åšæ³•æ˜¯å°†æ¸¸æ³³è¿™ä¸ªè¡Œä¸ºå°è£…æˆæŽ¥å£ï¼Œæ ¹æ®ä¸åŒçš„åœºæ™¯æˆ‘ä»¬å¯ä»¥è°ƒç”¨ä¸åŒçš„æ¸¸æ³³æ–¹æ³•ã€‚æ¯”å¦‚è¿™ä½æ¸¸æ³³è¿åŠ¨å‘˜è®¡åˆ’å‘¨æœ«æ¸¸è‡ªç”±æ³³ï¼Œå…¶ä»–æ—¶é—´åˆ™æ¸¸è›™æ³³ã€‚ç­–ç•¥æ¨¡å¼å°±æ˜¯ä¸€ç§è§£å†³è¿™ç§åœºæ™¯å¾ˆå¥½çš„æ€è·¯ã€‚ ç­–ç•¥æ¨¡å¼å®šä¹‰äº†ç®—æ³•æ—ï¼Œåˆ†åˆ«å°è£…èµ·æ¥ï¼Œè®©ä»–ä»¬ä¹‹é—´å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œæ­¤æ¨¡å¼è®©ç®—æ³•çš„å˜åŒ–ç‹¬ç«‹äºŽä½¿ç”¨ç®—æ³•çš„ç”¨æˆ· æœ¬è´¨ä¸Šï¼Œç­–ç•¥æ¨¡å¼åšçš„äº‹æƒ…å°±æ˜¯å°†ä¸åŒçš„è¡Œä¸ºç­–ç•¥ï¼ˆStrategyï¼‰è¿›è¡Œç‹¬ç«‹å°è£…ï¼Œä¸Žç±»çš„é€»è¾‘ä¸Šè§£è€¦ã€‚ç„¶åŽæ ¹æ®ä¸åŒçš„ä¸Šä¸‹æ–‡ï¼ˆContextï¼‰åˆ‡æ¢é€‰æ‹©ä¸åŒçš„ç­–ç•¥ï¼Œç„¶åŽç”¨ç±»å¯¹è±¡è¿›è¡Œè°ƒç”¨ï¼š interface SwimStrategy { fun swim()}class Breaststroke: SwimStrategy { override fun swim() { println(&quot;I am breaststroking...&quot;) }}class Backstroke: SwimStrategy { override fun swim() { println(&quot;I am Backstroke...&quot;) }}class Freestyle: SwimStrategy { override fun swim() { println(&quot;I am freestyling...&quot;) }}class Swimmer(val strategy: SwimStrategy) { fun swim() { strategy.swim() }}//invokeSwimmer(Freestyle()).swim()Swimmer(Breaststroke()).swim() è¿™ä¸ªæ–¹æ¡ˆå®žçŽ°äº†è§£è€¦å’Œå¤ç”¨çš„ç›®çš„ï¼Œä¸”å¾ˆå¥½å®žçŽ°äº†åœ¨ä¸åŒåœºæ™¯åˆ‡æ¢é‡‡ç”¨ä¸åŒçš„ç­–ç•¥ã€‚ç„¶è€Œï¼Œè¯¥ç‰ˆæœ¬çš„ä»£ç é‡ä¹Ÿæ¯”ä¹‹å‰å¤šäº†å¾ˆå¤šã€‚ é«˜é˜¶å‡½æ•°æŠ½è±¡ç®—æ³•å¦‚æžœç”¨é«˜é˜¶å‡½æ•°çš„æ€è·¯æ¥é‡æ–°æ€è€ƒä¸‹ç­–ç•¥ç±»ï¼Œæ˜¾ç„¶å°†ç­–ç•¥å°è£…æˆä¸€ä¸ªå‡½æ•°ç„¶åŽä½œä¸ºå‚æ•°ä¼ é€’ç»™Swimmerç±»ä¼šæ›´åŠ çš„ç®€æ´ã€‚ç”±äºŽç­–ç•¥ç±»çš„ç›®çš„éžå¸¸æ˜Žç¡®ï¼Œä»…ä»…æ˜¯é’ˆå¯¹è¡Œä¸ºç®—æ³•çš„ä¸€ç§æŠ½è±¡ï¼Œæ‰€ä»¥é«˜é˜¶å‡½æ•°å¼æ˜¯ä¸€ç§å¾ˆå¥½çš„æ›¿ä»£æ€è·¯ã€‚ fun breaststroke() { ...}fun Backstroke() { ...}fun freestyle(){ ...}class Swimmer(val swimming: () -&gt; Unit) { fun swim() { swimming() }}//invokeSwimmer(::freestyle).swim ä»£ç é‡ä¸€ä¸‹å­å˜å°‘ï¼Œè€Œä¸”ç»“æž„ä¸Šä¹Ÿæ›´åŠ å®¹æ˜“é˜…è¯»ã€‚ç”±äºŽç­–ç•¥ç®—æ³•éƒ½å°è£…æˆäº†ä¸€ä¸ªä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬åœ¨åˆå§‹åŒ–Swimmerç±»å¯¹è±¡æ—¶ï¼Œå¯ä»¥ç”¨å‡½æ•°å¼•ç”¨çš„è¯­æ³•ä¼ é€’æž„é€ å‚æ•°ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æŠŠå‡½æ•°ç”¨valå£°æ˜ŽæˆLambdaè¡¨è¾¾å¼ï¼Œé‚£ä¹ˆåœ¨ä¼ é€’å‚æ•°æ—¶ä¼šå˜å¾—æ›´åŠ ç®€æ´ç›´è§‚ã€‚ æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼šé«˜é˜¶å‡½æ•°ä»£æ›¿ç»§æ‰¿å¦ä¸€ä¸ªå¯ç”¨é«˜é˜¶å‡½æ•°æ”¹è‰¯çš„è®¾è®¡æ¨¡å¼ï¼Œå°±æ˜¯æ¨¡æ¿æ–¹æ³•æ¨¡å¼ã€‚æŸç§ç¨‹åº¦ä¸Šï¼Œæ¨¡æ¿æ–¹æ³•æ¨¡å¼å’Œç­–ç•¥æ¨¡å¼è¦è§£å†³çš„é—®é¢˜æ˜¯ç›¸ä¼¼çš„ï¼Œå®ƒä»¬éƒ½å¯ä»¥åˆ†ç¦»é€šç”¨çš„ç®—æ³•å’Œå…·ä½“çš„ä¸Šä¸‹æ–‡ã€‚ç„¶è€Œï¼Œå¦‚æžœè¯´ç­–ç•¥æ¨¡å¼é‡‡ç”¨çš„æ€è·¯æ˜¯å°†é…¸å¥¶æ³•è¿›è¡Œå§”æ‰˜ï¼Œé‚£ä¹ˆä¼ ç»Ÿçš„æ¨¡æ¿æ–¹æ³•æ¨¡å¼æ›´å¤šæ˜¯åŸºäºŽç»§æ‰¿çš„æ–¹æ³•å®žçŽ°çš„ã€‚çŽ°åœ¨æ¥çœ‹çœ‹æ¨¡æ¿æ–¹æ³•æ¨¡å¼çš„å®šä¹‰ï¼š å®šä¹‰ä¸€ä¸ªç®—æ³•ä¸­çš„æ“ä½œæ¡†æž¶ï¼Œè€Œå°†ä¸€äº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»ä¸­ï¼Œä½¿å¾—å­ç±»å¯ä»¥ä¸æ”¹å˜ç®—æ³•çš„ç»“æž„å³å¯å®šä¹‰è¯¥ç®—æ³•çš„æŸäº›ç‰¹å®šæ­¥éª¤ã€‚ ä¸Žç­–ç•¥æ¨¡å¼ä¸åŒï¼Œæ¨¡æ¿æ–¹æ³•æ¨¡å¼çš„è¡Œä¸ºç®—æ³•å…·æœ‰æ›´æ˜Žæ™°çš„å¤§çº²ç»“æž„ï¼Œå…¶ä¸­å®Œå…¨ç›¸åŒçš„æ­¥éª¤ä¼šåœ¨æŠ½è±¡ç±»ä¸­å®žçŽ°ï¼Œå¯ä¸ªæ€§åŒ–çš„æŸäº›æ­¥éª¤åˆ™åœ¨æŸå­ç±»ä¸­è¿›è¡Œå®šä¹‰ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æžœæˆ‘ä»¬åŽ»å¸‚æ°‘äº‹åŠ¡ä¸­å¿ƒåŠžäº‹æ—¶ï¼Œä¸€èˆ¬éƒ½ä¼šæœ‰ä»¥ä¸‹å‡ ä¸ªå…·ä½“çš„æ­¥éª¤ï¼š 1ï¼‰ æŽ’é˜ŸåŒºå·ç­‰å¾… 2ï¼‰æ ¹æ®è‡ªå·±çš„éœ€æ±‚åŠžç†ä¸ªæ€§åŒ–çš„ä¸šåŠ¡ï¼Œå¦‚èŽ·å–ç¤¾ä¿æ¸…å•ã€ç”³è¯·å¸‚æ°‘å¡ã€åŠžç†æˆ¿äº§è¯ 3ï¼‰å¯¹æœåŠ¡äººå‘˜çš„æ€åº¦è¿›è¡Œè¯„ä»· è¿™æ˜¯ä¸€ä¸ªå…¸åž‹çš„é€‚ç”¨æ¨¡æ¿æ–¹æ³•æ¨¡å¼çš„åœºæ™¯ï¼ŒåŠžäº‹æ­¥éª¤æ•´ä½“æ˜¯ä¸€ä¸ªç®—æ³•å¤§çº²ï¼Œå…¶ä¸­æ­¥éª¤1ï¼‰å’Œ3ï¼‰éƒ½æ˜¯ç›¸åŒçš„ç®—æ³•ï¼Œè€Œæ­¥éª¤2ï¼‰åˆ™å¯ä»¥æ ¹æ®å®žé™…éœ€æ±‚ä¸ªæ€§åŒ–é€‰æ‹©ã€‚æŽ¥ä¸‹æ¥æˆ‘ä»¬å°±ç”¨ä»£ç å®žçŽ°ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå®ƒå®šä¹‰äº†è¿™ä¸ªä¾‹å­çš„æ“ä½œæ¡†æž¶ï¼š abstract class CivicCenterTask { fun execute() { this.lineup() this.askForHelp() this.evaluate() } private fun lineup() { println(&quot;line up to take a number&quot;) } private fun evaluate() { println(&quot;evaluaten service attitude&quot;) } abstract fun askForHelp()} å…¶ä¸­askForHelpæ–¹æ³•æ˜¯ä¸€ä¸ªæŠ½è±¡æ–¹æ³•ã€‚æŽ¥ä¸‹æ¥æˆ‘ä»¬å†å®šä¹‰å…·ä½“çš„å­ç±»æ¥ç»§æ‰¿CivicCenter-Taskç±»ï¼Œç„¶åŽå¯¹æŠ½è±¡çš„æ­¥éª¤è¿›è¡Œå®žçŽ°ã€‚ class PullSocialSecurity: CivicCenterTask { override fun askForHelp() { println(&quot;ask for pulling teh social security&quot;) }}class ApplyForCitizenCard: CiviCenterTask { override fun askForHelp() { println(&quot;apply for a citizen card&quot;) }}//invoke&gt;&gt;&gt; PullSocialSecurity().execute()line up to take a numberask for pulling the social securityevaluation service attitude&gt;&gt;&gt; ApplyForCitizenCard().execute()line up to take a numberapply for a citizen cardevaluaten service attitude ä¸å‡ºæ„æ–™ï¼Œä¸¤è€…çš„æ­¥éª¤2ï¼‰çš„æ‰§è¡Œç»“æžœæ˜¯ä¸ä¸€æ ·çš„ã€‚ ä¸å¾—ä¸è¯´ï¼Œæ¨¡æ¿æ–¹æ³•æ¨¡å¼çš„ä»£ç å¤ç”¨æ€§å·²ç»éžå¸¸é«˜äº†ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯å¾—æ ¹æ®ä¸åŒçš„ä¸šåŠ¡åœºæ™¯éƒ½å®šä¹‰ä¸€ä¸ªå…·ä½“çš„å­ç±»ã€‚å¹¸è¿çš„æ˜¯ï¼Œåœ¨Kotlinä¸­æˆ‘ä»¬åŒæ ·å¯ä»¥ç”¨æ”¹é€ ç­–ç•¥æ¨¡å¼çš„ç±»ä¼¼æ€æƒ³ï¼Œæ¥ç®€åŒ–æ¨¡æ¿æ–¹æ³•æ¨¡å¼ã€‚ä¾é é«˜é˜¶å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åªéœ€ä¸€ä¸ªCivicCenterTaskç±»çš„æƒ…å†µä¸‹ï¼Œä»£æ›¿ç»§æ‰¿å®žçŽ°ç›¸åŒçš„æ•ˆæžœã€‚ class CivicCenterTask { fun execute(askForHelp: ()-&gt;Unit) { this.lineUp() askForHelp() this.evaluate() } private fun lineup(){ ... } private fun evaluate(){ ... } fun pullSocialSecurity() { ... } fun applyForCitizenCard() { ... }}//invoke&gt;&gt;&gt; CivicCenterTask().execute(::pullSocialSecurity)live up to take a numberask for pulling the social securityevaluaten service attitude&gt;&gt;&gt; CivicCenterTask().excute(::applyForCitizenCard)line up to take numberapply for a citizen cardevaluaten service attitude å¦‚ä½ æ‰€è§ï¼Œåœ¨é«˜é˜¶å‡½æ•°çš„å¸®åŠ©ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥æ›´åŠ è½»æ¾åœ°å®žçŽ°æ¨¡æ¿æ–¹æ³•æ¨¡å¼ã€‚","link":"/2020/01/17/%E5%88%A9%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%AE%80%E5%8C%96%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"åˆä¸€æ¬¡æœ‰æ„æ€çš„ç»åŽ†","text":"åˆæ˜¯ä¸€æ¬¡æœ‰æ„æ€çš„ç»åŽ†ï¼Œè¸‰è¸‰è·„è·„çš„æ¥ï¼Œå¿ƒæ— æ—éª›çš„èµ°ï¼Œæˆ‘æ„Ÿåˆ°äº†å‰æ‰€æœªæœ‰çš„é‡Šç„¶ï¼Œä»Žæ¥éƒ½æ²¡æœ‰è¿‡çš„æˆé•¿ï¼Œè¿™ç§æˆé•¿å¹¶éžèŒä¸šæŠ€èƒ½ä¸Šçš„æˆé•¿ï¼Œæ—¢æ˜¯ä¸ªäººæ€æƒ³ä¸Šçš„æˆé•¿ï¼Œå¦‚æžœå¯¹å¾…æ— æ‰€ä¸åœ¨çš„å†²çªå‘¢ï¼Ÿ åˆæ˜¯ä¸€æ¬¡æœ‰æ„æ€çš„ç»åŽ†ï¼Œè¸‰è¸‰è·„è·„çš„æ¥ï¼Œå¿ƒæ— æ—éª›çš„èµ°ï¼Œæˆ‘æ„Ÿåˆ°äº†å‰æ‰€æœªæœ‰çš„é‡Šç„¶ï¼Œä»Žæ¥éƒ½æ²¡æœ‰è¿‡çš„æˆé•¿ï¼Œè¿™ç§æˆé•¿å¹¶éžèŒä¸šæŠ€èƒ½ä¸Šçš„æˆé•¿ï¼Œæ—¢æ˜¯ä¸ªäººæ€æƒ³ä¸Šçš„æˆé•¿ï¼Œå¦‚æžœå¯¹å¾…æ— æ‰€ä¸åœ¨çš„å†²çªå‘¢ï¼Ÿå¦‚ä½•åœ¨å†²çªä¸­æ‰¾åˆ°å±žäºŽè‡ªå·±çš„ä½ç½®å‘¢ï¼Ÿè¦æ˜¯è‡ªæˆ‘èŒä¸šæŠ€èƒ½æˆé•¿è¿…é€Ÿçš„è¯ï¼Œå¦‚ä½•åœ¨ç‹‚å¦„è‡ªå¤§ä¸­å¹³æ¯å“ªä¸€ç‚¹è™šæ— å‘¢ï¼Ÿè¦æ˜¯èº«å¤„æ··ä¹±ä¹‹ä¸­å¦‚ä½•ä¸åŽ»éšæ³¢é€æµè¿›è¡Œè‡ªæˆ‘æ•‘èµŽå‘¢ï¼Ÿ å†²çªçœŸçš„å­˜åœ¨å—åº”è¯¥ä¸å­˜åœ¨å§ï¼Œæœ‰æ—¢æ˜¯æœ‰ï¼Œæ²¡æœ‰æ—¢æ˜¯æ²¡æœ‰ï¼Œæ²¡æœ‰çš„ä½ æƒ³æœ‰ä¹Ÿå°±æœ‰äº†ï¼Œæœ‰çš„ä¸œè¥¿ä½ æƒ³æ²¡æœ‰ä¹Ÿå°±æ²¡æœ‰äº†ã€‚å¯¹å¾…å„ç§æ¬²æœ›çš„çˆ†å‘ï¼Œå°±åº”è¯¥ç†æ€§çš„æ€è€ƒï¼Œè®©æ€è€ƒè¶…è¿‡éžç†æ€§çš„æƒ…ç»ªçˆ†å‘ï¼Œæƒ…ç»ªåŒ–å…¶å®žå°±æ˜¯æœ€å¤§çš„å¼±ç‚¹ã€‚å†²çªæœ¬ä¸æ˜¯é—®é¢˜çš„æ ¹æœ¬ï¼Œå†²çªæ˜¯äººä¸ºçš„å¼ºåˆ¶æ€§æ·»åŠ çš„ç”¨æ¥è§£å†³è‡ªå·±å¯¹å½“å‰äº‹ç‰©æ— èƒ½å¤„ç†çš„ç»“æžœï¼Œåº”è¯¥åœ¨å¤šæ¬¡æ·±å…¥æ€è€ƒåŽåŽ»è§£å†³è¿™ç§æ— èƒ½ã€‚ è¦æ˜¯é™·å…¥äº†è™šæ— çš„è‡ªå¤§ä¸­ï¼Œå¦‚ä½•å¹³æ¯å‘¢é‚£å…¶å®žåº”è¯¥æ˜¯æ³¨ç„‰è€Œä¸æ»¡é…Œç„‰è€Œä¸ç«­å‘¢ï¼Œè€ç¥–å®—çš„è¿™å¥å¯¹æ¸¸åˆƒæœ‰ä½™çš„è§£é‡Šå®Œç¾Žçš„è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œè‡ªå¤§æºè‡ªè‡ªæ»¡ï¼Œæ­§è§†æ¥è‡ªæ— çŸ¥ã€‚è¦æ˜¯èƒ½æœ‰æ›´å¤§çš„çœ¼ç•Œï¼Œç«™åˆ°æ›´é«˜çš„ä½ç½®ï¼Œåº”è¯¥åªä¼šæ„Ÿå—åˆ°è‡ªå·±çš„æ¸ºå°å§ã€‚å…¶å®žå¦‚æžœå¯¹è¿™ä¸ªä¸–ç•Œæ°¸è¿œå……æ»¡æ•¬ç•çš„è¯ï¼Œé‚£ä¸€å®šä¼šä¸€ç›´å¤„äºŽè‡ªæˆ‘åçœçš„çŠ¶æ€å§ï¼Œæ€Žä¹ˆä¼šè‡ªå¤§å‘¢ã€‚å…¶å®žèƒ½æ‰¿è®¤è‡ªå·±è‡ªå¤§ä¹Ÿå·²ç»æ˜¯å¾ˆå¤§çš„è¿›æ­¥äº†ï¼Œæ‰¿è®¤è‡ªå·±å¹¶éžä½ æ‰€ä»¥ä¸ºçš„é‚£ç§äººï¼Œç§°å¾—ä¸Šæ˜¯ä¸€ç§ç›¸å½“å¯æ€•çš„ç»åŽ†ã€‚æ²¡é‚£ä¹ˆå¯æ€•å‘€ã€‚ æ··ä¹±ä¹‹ä¸­å¦‚ä½•è‡ªå·±æ•‘èµŽå‘¢è¿™é‡Œçš„æ··ä¹±å¹¶éžå°ä¸‘å˜´é‡Œçš„æ··ä¹±ï¼Œä¹Ÿä¸æ˜¯ä»€ä¹ˆåè¯ï¼Œæˆ‘è§‰å¾—åœ¨æˆ‘çœ¼é‡Œåº”è¯¥æ˜¯å½¢å®¹è¯å§ï¼Œå°±æ˜¯ä¸€å †ä¹±éº»è€Œå·²ï¼Œä¹±éº»ç”¨æ¥æè¿°è‡ªå·±çœ‹åˆ°çš„æ–¹æ–¹é¢é¢ï¼Œå¤ªè¿‡æ•æ„Ÿï¼Œæ•æ„Ÿå¹¶éžè´¬ä¹‰è¯ï¼Œæ”¶åˆ°å¤–ç•Œçš„ä¿¡æ¯ä»¥åŽï¼Œå¦‚ä½•å¤„ç†æ‰æ˜¯å…³é”®ã€‚ä½ çœ‹å§ï¼ŒçŽ°åœ¨ä½ å¯ä»¥æ”¶åˆ°å¥½å¤šåˆ«äººæŽ¥æ”¶ä¸åˆ°çš„ä¿¡æ¯å‘¢ï¼Œå¯æ˜¯ä½ ä»Žä¸åŠ å·¥ï¼Œä»Žä¸è¿‡æ»¤ï¼Œå°±è®©å®ƒä»¬æ‘‡æ‘‡æ™ƒæ™ƒçš„è¿›æ¥äº†ï¼Œç»“æžœå¤–é¢ä¸€ç‰‡å¤ªå¹³ï¼Œè€Œä½ è‡ªå·±ç—›ä¸æ¬²ç”Ÿã€‚é‚£ä¸æ˜¯åº”è¯¥åè¿‡æ¥å—ï¼Œå†ä¸æµŽä¹Ÿåº”è¯¥æ˜¯åŒæ ·å¤ªå¹³æ‰å¯¹å‘€ï¼Ÿ endå‰æ®µæ—¶é—´ç»ˆäºŽçœ‹å®Œäº†ã€Šå°˜åŸƒè½å®šã€‹ã€‚å°±åƒå‚»å­æœ€åŽè¯´çš„ï¼Œâ€œæ˜¯çš„ï¼Œä¸Šå¤©å«æˆ‘çœ‹è§ï¼Œå«æˆ‘å¬è§ï¼Œå«æˆ‘ç½®èº«å…¶ä¸­ï¼Œåˆå«æˆ‘è¶…ç„¶ç‰©å¤–ã€‚ä¸Šå¤©æ˜¯ä¸ºäº†è¿™ä¸ªç›®çš„ï¼Œæ‰è®©æˆ‘çœ‹èµ·æ¥åƒä¸ªå‚»å­çš„ã€‚â€å¯¹å•Šï¼Œä½ ä¹Ÿå¯ä»¥çœ‹è§ï¼Œä½ ä¹Ÿå¯ä»¥å¬è§ï¼Œä½ ä¹Ÿç½®èº«äºŽè¿™å¤§åƒä¸–ç•Œé‡Œï¼Œä¸€å®šä¸èƒ½è¾œè´Ÿä¸Šå¤©å¯¹ä½ çš„æ©æƒ ã€‚ä½ ä¸€å®šè¦å­¦ä¼šè¶…ç„¶ç‰©å¤–ï¼Œè¦æ˜¯åˆ°ä¸äº†è¿™ä¸ªå¢ƒç•Œï¼Œä¹Ÿåº”è¯¥ç»™ä¸Žæœ‰åŠ›çš„å›žå‡»ï¼Œä¸ç®¡æ˜¯å–„æ„çš„å›žå‡»è¿˜æ˜¯æ¶æ„çš„ï¼Œç¥ç¦ä½ å§ã€‚","link":"/2019/03/22/%E5%8F%88%E4%B8%80%E6%AC%A1%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%BB%8F%E5%8E%86/"},{"title":"å°†Flutteræ·»åŠ åˆ°å·²æœ‰çš„é¡¹ç›®ä¸­","text":"æŸ¥çœ‹äº†ç½‘ä¸Šå„ç§æ–¹æ¡ˆä¹ŸåŒ…æ‹¬é—²é±¼å›¢é˜Ÿçš„å¼€æºflutter_bootï¼Œéƒ½å„æœ‰ç¼ºç‚¹ã€‚é‰´äºŽå„ç§æ–¹æ¡ˆéƒ½éœ€è¦åˆ¶å®šç›¸åº”çš„Flutterç‰ˆæœ¬ï¼Œè€ƒè™‘åˆ°Flutteræ›´æ–°é€Ÿåº¦ï¼ŒäºŽæ˜¯å†³å®šä¾é å®˜æ–¹çš„äº§ç‰©é›†æˆæ–¹å¼è§£å†³æ··åˆå¼€å‘çš„é—®é¢˜ï¼Œå¹¶è¿›è¡Œè¿œç¨‹SDKç®¡ç†ã€‚ Flutteræž„å»ºæ¨¡å¼ä½ å¯ä»¥åœ¨å®˜æ–¹DOCSä¸­çœ‹åˆ°è¯¦ç»†ä»‹ç»ï¼Œä¸‹æ–‡æ‰“åŒ…å‘½ä»¤éƒ½ä¼šäº§å‡ºå¯¹åº”ä¸‰ç§æ¨¡å¼çš„åŒ…ä»¥ä¾¿æ»¡è¶³å„åœºæ™¯éœ€è¦ï¼Œæˆ‘ä»¬ç®€å•è®°å½•ä¸‹æ¥ï¼š DebugDebugæ¨¡å¼ä¸‹ï¼Œappå¯ä»¥è¢«å®‰è£…åœ¨ç‰©ç†è®¾å¤‡ã€ä»¿çœŸå™¨æˆ–è€…æ¨¡æ‹Ÿå™¨ä¸Šè¿›è¡Œè°ƒè¯•ã€‚ çƒ­é‡è½½ä»…èƒ½åœ¨Debugæ¨¡å¼ä¸‹è¿è¡Œ ä»¿çœŸå™¨ã€æ¨¡æ‹Ÿå™¨ä»…èƒ½åœ¨Debugæ¨¡å¼ä¸‹è¿è¡Œ Debugæ¨¡å¼ä¸‹ï¼ŒAPPæ€§èƒ½å¯èƒ½ä¼šæŽ‰å¸§æˆ–è€…å¡é¡¿ ProfileProfileæ¨¡å¼ä¸‹ï¼Œä¸€äº›è°ƒè¯•èƒ½åŠ›æ˜¯è¢«ä¿ç•™çš„â€”â€”è¶³å¤Ÿåˆ†æžä½ çš„appæ€§èƒ½ã€‚åœ¨ä»¿çœŸå™¨å’Œæ¨¡æ‹Ÿå™¨ä¸Šï¼ŒProfileæ¨¡å¼æ˜¯ä¸å¯ç”¨çš„ã€‚ ReleaseReleaseæ¨¡å¼å¯¹å¿«é€Ÿå¯åŠ¨ã€å¿«é€Ÿæ‰§è¡Œå’Œpackageçš„å¤§å°è¿›è¡Œäº†ä¼˜åŒ–ï¼Œå¹¶ç¦ç”¨äº†è°ƒè¯•ã€æœåŠ¡æ‰©å±•ç­‰åŠŸèƒ½ï¼ŒReleaseæ¨¡å¼åšåˆ°äº†æœ€å¤§çš„ä¼˜åŒ–ä»¥åŠæœ€å°çš„å ç”¨ç©ºé—´ã€‚ å¦‚ä¸Šä¸‰ç§æ¨¡å¼å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤è¿è¡Œåˆ°è®¾å¤‡ä¸Šï¼š flutter run --releaseflutter run --profileflutter run --debug ##iOS - ä»¥frameworkçš„å½¢å¼æ·»åŠ åˆ°ä½ çš„æ—¢æœ‰iOSåº”ç”¨ä¸­ï¼Œå¹¶ä¸Šä¼ CocoaPods åˆ›å»ºFlutter moduleä½ å¯ä»¥åœ¨Android Studioä¸­åˆ›å»º ä¹Ÿå¯ä»¥é€šè¿‡å‘½ä»¤è¡Œ flutter create --template module my_flutter æ­¤moduleå¹¶ä¸æ˜¯Androidé‡Œçš„æ¨¡å—æˆ–è€…iOSé‡Œçš„ç»„ä»¶ï¼Œè€Œæ˜¯Googleæä¾›çš„ä¸€ç§åˆ›å»ºæ¨¡å¼ï¼Œå¯ä»¥ç‹¬ç«‹è¿è¡Œã€‚ äº§ç‰©é›†æˆflutter build ios-framework --output=somePath/ äº§ç‰©ç›®å½•ç»“æž„å¦‚ä¸‹ï¼š somePath/â””â”€â”€ Flutter/ â”œâ”€â”€ Debug/ â”‚ â”œâ”€â”€ Flutter.framework â”‚ â”œâ”€â”€ App.framework â”‚ â”œâ”€â”€ FlutterPluginRegistrant.framework (only if you have plugins with iOS platform code) â”‚ â””â”€â”€ example_plugin.framework (each plugin is a separate framework) â”œâ”€â”€ Profile/ â”‚ â”œâ”€â”€ Flutter.framework â”‚ â”œâ”€â”€ App.framework â”‚ â”œâ”€â”€ FlutterPluginRegistrant.framework â”‚ â””â”€â”€ example_plugin.framework â””â”€â”€ Release/ â”œâ”€â”€ Flutter.framework â”œâ”€â”€ App.framework â”œâ”€â”€ FlutterPluginRegistrant.framework â””â”€â”€ example_plugin.framework Flutter.frameworkæœ‰400M-500Mï¼Œå¹¶ä¸”ä¸ä¼šç»å¸¸å˜åŠ¨ï¼Œä¸‹æ–‡çš„pod libå¤„ç†ä¸­æˆ‘ä»¬éœ€è¦ä¸ºå®ƒå•ç‹¬åˆ›å»ºä¸€ä¸ªpodï¼Œå‰©ä¸‹çš„framworkæ¯æ¬¡æ–°å¢žæ’ä»¶æˆ–å˜æ›´ä»£ç éƒ½ä¼šè·Ÿç€å˜åŠ¨ï¼Œæ”¾åœ¨ä¸€ä¸ªpodã€‚ cocoapods+gitç®¡ç†podfileæ— æ³•ç›´æŽ¥å¼•ç”¨frameworkï¼Œéœ€è¦ä¸€ä¸ªpodä½œä¸ºä¸­è½¬ã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦ä¾æ¬¡è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š åˆ›å»ºä¸€ä¸ªåä¸ºflutter-plugin-libç§æœ‰åº“ pod lib create flutter-plugin-lib æ‰“å¼€flutter-plugin-lib.podspecï¼Œåœ¨endå‰åŠ å…¥ï¼š s.ios.vendored_frameworks = 'flutter_frameworks/App.framework', 'flutter_frameworks/FlutterPluginRegistrant.framework', 'flutter_frameworks/shared_preferences.framework' åœ¨æ ¹ç›®å½•åˆ›å»ºflutter_frameworksæ–‡ä»¶å¤¹ï¼ŒæŠŠåˆšç”ŸæˆReleaseçš„frameworké™¤åŽ»Flutter.framework cvè¿‡æ¥ã€‚ åˆ›å»ºgitä»“åº“å¹¶ä¸Šä¼ åˆ°äº‘ç«¯ã€‚ git initgit remote add origin http://xxx/flutter-plugin-lib.gitgit add .git commit -m &quot;xxx&quot;git push -u origin master åœ¨éœ€è¦æ··ç¼–Flutterçš„nativeé¡¹ç›®çš„podfileä¸­æ·»åŠ ï¼š pod 'flutter-plugin-lib', :git =&gt; 'http://xxx/flutter-plugin-lib' :tag =&gt; 'v1.0.0' åŒæ­¥cocoapods pod install Flutter.frameworkå¤„ç†æ–¹æ¡ˆå¦‚ä¸Šã€‚ è‡³æ­¤ï¼Œå®Œæˆäº†å¼•å…¥æ‰€æœ‰çš„frameworksï¼Œå¹¶ä¸”ä¸éœ€è¦ç»„å†…å…¶ä»–æˆå‘˜åœ¨æœ¬åœ°å®‰è£…Flutter SDKå’ŒCocoapodsã€‚ éªŒè¯AppDelegate.swift import UIKitimport Flutterimport FlutterPluginRegistrant@UIApplicationMainclass AppDelegate: FlutterAppDelegate { lazy var flutterEngine = FlutterEngine(name: &quot;sup flutter engine&quot;) override func application(_ application: UIApplication,didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { flutterEngine.run() GeneratedPluginRegistrant.register(with: self.flutterEngine) return super.application(application, didFinishLaunchingWithOptions: launchOptions) }} ViewController.swift import UIKitimport Flutterclass ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let button = UIButton(type: UIButton.ButtonType.custom) button.addTarget(self, action: #selector(showFlutter), for: .touchUpInside) button.setTitle(&quot;Show Flutter!&quot;, for: UIControl.State.normal) button.frame = CGRect(x: 80.0, y: 200.0, width: 160.0, height: 40.0) button.backgroundColor = UIColor.blue self.view.addSubview(button) self.view.backgroundColor = UIColor.white } @objc func showFlutter() { present(FlutterViewController(engine: (UIApplication.shared.delegate as! AppDelegate).flutterEngine, nibName: nil, bundle: nil),animated: true,completion: nil) }} Android-ä»¥aarçš„å½¢å¼ä¸Šä¼ åˆ°ç§æœ‰maven/æœ¬åœ°ä¾èµ–åˆ›å»ºFlutter moduleä½ å¯ä»¥åœ¨ä¸Šè¿°iOSæ‰€åˆ›å»ºçš„moduleä¸­ç»§ç»­å¼€å‘ã€‚ äº§ç‰©é›†æˆflutter build aar äº§ç‰©ç›®å½•ç»“æž„å¦‚ä¸‹ï¼š build/host/outputs/repoâ””â”€â”€ com â””â”€â”€ example â””â”€â”€ my_flutter â”œâ”€â”€ flutter_release â”‚ â”œâ”€â”€ 1.0 â”‚ â”‚ â”œâ”€â”€ flutter_release-1.0.aar â”‚ â”‚ â”œâ”€â”€ flutter_release-1.0.aar.md5 â”‚ â”‚ â”œâ”€â”€ flutter_release-1.0.aar.sha1 â”‚ â”‚ â”œâ”€â”€ flutter_release-1.0.pom â”‚ â”‚ â”œâ”€â”€ flutter_release-1.0.pom.md5 â”‚ â”‚ â””â”€â”€ flutter_release-1.0.pom.sha1 â”‚ â”œâ”€â”€ maven-metadata.xml â”‚ â”œâ”€â”€ maven-metadata.xml.md5 â”‚ â””â”€â”€ maven-metadata.xml.sha1 â”œâ”€â”€ flutter_profile â”‚ â”œâ”€â”€ ... â””â”€â”€ flutter_debug â””â”€â”€ ... mavenç®¡ç†ä½ å¯ä»¥æŒ‰ç…§google DOCS ä¸­æè¿°çš„æ–¹å¼åœ¨æœ¬åœ°ä¾èµ–aarã€‚ android { // ...}repositories { maven { url 'somepath/my_flutter/build/host/outputs/repo' // This is relative to the location of the build.gradle file // if using a relative path. } maven { url 'https://storage.googleapis.com/download.flutter.io' }}dependencies { // ... debugImplementation 'com.example.flutter_module:flutter_debug:1.0' profileImplementation 'com.example.flutter_module:flutter_profile:1.0' releaseImplementation 'com.example.flutter_module:flutter_release:1.0'} ä½†æ˜¯è¿™æ ·å¯¹nativeå¼€å‘ç»„å‘˜æ¥è¯´æŽ¥å…¥æˆæœ¬è¿˜æ˜¯è¿‡é«˜ï¼ŒäºŽæ˜¯æˆ‘è€ƒè™‘åˆ°ç”¨mavenç§æœç®¡ç†çš„æ–¹å¼å¤„ç†ä¾èµ–ï¼Œå½“ç„¶é¦–å…ˆå…¬å¸åº”è¯¥æœ‰æœåŠ¡å™¨ï¼Œä»¥ä¸‹åŸºäºŽmacæ­å»ºmavenä»“åº“ï¼š brew install nexusnexus start&gt;&gt;http://localhost:8081/nexus/nexus stop åœ¨flutter moduleä¸­ç¼–å†™shè„šæœ¬å¤„ç†ä¸Šä¼ åŠ¨ä½œï¼š #!/bin/bashflutter cleanflutter build aar# å®šä¹‰ç”¨äºŽaarã€pomæ–‡ä»¶ç›®å½•å­˜æ”¾çš„æ•°ç»„aars=()poms=()# æŒ‡å®šæ‰“åŒ…åŽæœ¬åœ°ä»“åº“çš„ç›®å½•ï¼Œç”±äºŽè¿™é‡Œå°†æ­¤è„šæœ¬æ”¾åœ¨flutter moduleæ ¹ç›®å½•ï¼Œå› æ­¤ç›´æŽ¥é…ç½®äº†flutter moduleæ ¹ç›®å½•ä¸‹ç›¸å¯¹ç›®å½•targetPath=&quot;build/host/outputs/repo&quot;# å®šä¹‰éåŽ†æ‰¾åˆ°æ‰€æœ‰pomæ–‡ä»¶å’Œaaræ–‡ä»¶çš„å‡½æ•°# å‚æ•°$1ï¼šå½“å‰æŸ¥æ‰¾çš„ç›®å½•åfunction findAarPom(){ echo &quot;æŸ¥æ‰¾æ­¤ç›®å½•æ˜¯å¦æœ‰aaråŠpomï¼š$1&quot; targetDir=`ls $1` for fileName in $targetDir do if [[ -d $1&quot;/&quot;$fileName ]]; then # è¿˜æ˜¯ç›®å½•ï¼Œåˆ™é€’å½’æ‰¾ä¸‹ä¸€çº§ findAarPom $1&quot;/&quot;$fileName else # å¦‚æžœæ˜¯æ–‡ä»¶ï¼Œåˆ¤æ–­åŽç¼€ï¼Œå¦‚æžœç¬¦åˆæœŸæœ›ï¼Œåˆ™å°†æ–‡ä»¶è·¯å¾„æ‹¼æŽ¥å¥½æ”¾äºŽå¯¹åº”æ•°ç»„æœ€åŽä¸€ä½ if [[ ${fileName:0-4} == '.aar' ]]; then aars[${#aars[@]}]=$1&quot;/&quot;$fileName elif [[ ${fileName:0-4} == '.pom' ]]; then poms[${#poms[@]}]=$1&quot;/&quot;$fileName fi fi done}findAarPom $targetPathecho &quot;============&quot;echo &quot;aaræœ‰ï¼šã€Šå…±${#aars[@]}ä¸ªã€‹&quot;echo &quot;${aars[@]}&quot;echo &quot;pomæœ‰ï¼šã€Šå…±${#poms[@]}ä¸ªã€‹&quot;echo &quot;${poms[@]}&quot;echo &quot;============&quot;# ä¸€ä¸ªaaræ–‡ä»¶å¿…ç„¶å¯¹åº”ä¼šæœ‰ä¸€ä¸ªpomæ–‡ä»¶ï¼Œå¦‚æžœæ•°é‡ä¸å¯¹ï¼Œä¸€å®šæ˜¯æ‰“åŒ…å‡ºé”™if [[ ${#aars[@]} -ne ${#poms[@]} ]]; then echo &quot;-- !!! pomæ–‡ä»¶ä¸Žaarä¸å¯¹ç§°ï¼Œè¯·æ£€æŸ¥aaræ‰“åŒ…é…ç½®ï¼Œä¸Šä¼ ä»»åŠ¡ é€€å‡º !!! --&quot; exit 1fiif [[ ${#aars[@]} == 0 ]]; then echo &quot;-- !!! æœªæ‰¾åˆ°aaræ–‡ä»¶ï¼Œè¯·æ£€æŸ¥aaræ‰“åŒ…é…ç½®ï¼Œä¸Šä¼ ä»»åŠ¡ é€€å‡º !!! --&quot; exit 1fi# å®šä¹‰å°†ç›®æ ‡pomåŠaarä¸Šä¼ åˆ°mavenæŒ‡å®šä»“åº“çš„å‡½æ•°# å‚æ•°$1ï¼šä¸ºpomæ–‡ä»¶# å‚æ•°$2ï¼šä¸ºaaræ–‡ä»¶function upload(){ echo &quot;å¼€å§‹ä¸Šä¼ ï¼š&quot; echo $1 echo $2 # mvnä¸Šä¼ å‘½ä»¤ï¼Œè¿™é‡Œç”±äºŽå°†ä¸Šä¼ ç”¨æˆ·åå¯†ç é…ç½®äºŽå…¨å±€maven settings.xmlï¼Œåˆ™æ— éœ€å†æŒ‡å®šç”¨æˆ·åå¯†ç  mvn deploy:deploy-file \\ -DpomFile=&quot;$1&quot; \\ -DgeneratePom=false \\ -Dfile=&quot;$2&quot; \\ -Durl=&quot;http://localhost:8081/nexus/content/repositories/releases&quot; \\ -DrepositoryId=&quot;nexus&quot; \\ -Dpackaging=aar \\ -s=&quot;mvn-settings.xml&quot;}# å¾ªçŽ¯ä¸Šä¼ for (( i=0;i&lt;${#aars[@]};i++ )); do echo &quot;æ­£åœ¨å¤„ç†ç¬¬$[$i+1]ä¸ªï¼Œå…±${#aars[@]}ä¸ª&quot; upload &quot;${poms[$i]}&quot; &quot;${aars[$i]}&quot;done å…¶ä¸­mvn-settings.xmlæ˜¯å•ç‹¬å¯¹å½“å‰é¡¹ç›®é…ç½®mvnï¼Œä¿®æ”¹admin passwordä¸ºmavençš„è´¦å·å¯†ç ï¼Œé»˜è®¤ä¸ºadmin/admin123 åœ¨Androidé¡¹ç›®appæ¨¡å—ä¸­çš„build.gradle android { // ... buildTypes { ... profile { initWith debug } } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 }}repositories { maven { url 'http://localhost:8081/nexus/content/repositories/releases' // This is relative to the location of the build.gradle file // if using a relative path. } maven { url 'https://storage.googleapis.com/download.flutter.io' }}dependencies { // ... debugImplementation 'com.example.flutter_module:flutter_debug:1.0' profileImplementation 'com.example.flutter_module:flutter_profile:1.0' releaseImplementation 'com.example.flutter_module:flutter_release:1.0'} å¦‚æ­¤å³å¯å®Œæˆmavenç§æœä¸Šä¼ ï¼Œå¦‚æžœä½ æœ‰æœåŠ¡å™¨å¯ä»¥ä¿®æ”¹ipåœ°å€å®Œæˆä¸Šä¼ ã€ä¾èµ–ã€‚ç”±äºŽæˆ‘å¸æ²¡æœ‰ç§æœï¼ŒäºŽæ˜¯å†³å®šæŠŠhost/æ–‡ä»¶å¤¹æ‹–å…¥é¡¹ç›®çš„æ–¹å¼å®žçŽ°ä¾èµ–ï¼š æ ¹ç›®å½•build.gradle: buildscript { ... repositories { ... maven { url '../host/outputs/repo' } maven { url 'https://storage.flutter-io.cn/download.flutter.io' } }}allprojects { repositories { ... maven { url '../host/outputs/repo' } maven { url 'https://storage.flutter-io.cn/download.flutter.io' } }} è‡³æ­¤ï¼Œå®Œæˆäº†å¼•å…¥æ‰€æœ‰çš„aarï¼Œå¹¶ä¸”ä¸éœ€è¦ç»„å†…å…¶ä»–æˆå‘˜åœ¨æœ¬åœ°å®‰è£…Flutter SDKã€‚ç½‘ä¸Šä¹Ÿæœ‰é€šè¿‡fat-aaræ¥åˆå¹¶aaråŒ…è¿›è¡Œä¾èµ–å¤„ç†çš„æ–¹æ³•ï¼Œæˆ‘è®¤ä¸ºå¯¹äºŽè¿­ä»£é¢‘ç¹çš„æ–°æŠ€æœ¯åº”è¯¥å°½é‡ç”¨å®˜æ–¹æŽ¨èçš„æ–¹å¼åŽ»å®žçŽ°ï¼Œä»¥å…ä¹‹åŽçš„è¿­ä»£ã€ç‰ˆæœ¬å‡çº§å¸¦æ¥ä¸å¿…è¦çš„å¼€å‘æˆæœ¬ã€‚ éªŒè¯App.kt class App : Application() { override fun onCreate() { super.onCreate() FlutterMain.startInitialization(this) }} FlutterActivity.kt class FlutterActivity : FlutterFragmentActivity() { var engine:FlutterEngine? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) engine = FlutterEngine(this) engine?.dartExecutor?.executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault()) setContentView(R.layout.activity_flutter) fv_container.attachToFlutterEngine(engine!!) } override fun onResume() { super.onResume() engine?.lifecycleChannel?.appIsResumed() } override fun onPause() { super.onPause() engine?.lifecycleChannel?.appIsInactive() } override fun onStop() { super.onStop() engine?.lifecycleChannel?.appIsPaused() } override fun onDestroy() { fv_container.detachFromFlutterEngine() super.onDestroy() }} End","link":"/2020/09/19/%E5%B0%86Flutter%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B7%B2%E6%9C%89%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD/"},{"title":"å·¥åŽ‚æ–¹æ³•æ¨¡å¼","text":"åˆ©ç”¨Kotlinä¸­çš„ä¼´ç”Ÿå¯¹è±¡å¢žå¼ºå·¥åŽ‚æ¨¡å¼ ä¸€äº›åœ°æ–¹ä¼šæŠŠå·¥åŽ‚æ¨¡å¼ç»†åˆ†ä¸ºç®€å•å·¥åŽ‚ã€å·¥åŽ‚æ–¹æ³•æ¨¡å¼ä»¥åŠæŠ½è±¡å·¥åŽ‚,ä¸€ä¸‹åˆ†ç±»è¯´æ˜Žï¼š ç®€å•å·¥åŽ‚ç®€å•å·¥åŽ‚çš„æ ¸å¿ƒä½œç”¨å°±æ˜¯é€šè¿‡ä¸€ä¸ªå·¥åŽ‚ç±»éšè—å¯¹è±¡å®žä¾‹çš„åˆ›å»ºé€»è¾‘ï¼Œè€Œä¸æ˜¯æš´éœ²ç»™å®¢æˆ·ç«¯ã€‚å…¸åž‹çš„ä½¿ç”¨åœºæ™¯å°±æ˜¯å½“æ‹¥æœ‰ä¸€ä¸ªçˆ¶ç±»ä¸Žå¤šä¸ªå­ç±»çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ç§æ¨¡å¼æ¥åˆ›å»ºå­ç±»å¯¹è±¡ã€‚ ä¾‹å¦‚çŽ°åœ¨æœ‰ä¸€ä¸ªç”µè„‘åŠ å·¥åŽ‚ï¼ŒåŒæ—¶ç”Ÿäº§ä¸ªäººç”µè„‘å’ŒæœåŠ¡å™¨ä¸»æœºã€‚ç”¨javaä¸­çš„æ€ç»´é€»è¾‘æ¥å®žçŽ°å·¥åŽ‚æ¨¡å¼ interface Computer { val cpu: String}class PC(override val cpu: String = &quot;Core&quot;): Computerclass Server(override val cpu: String = &quot;Xeon&quot;): Computerenum class ComputerType { PC,Server}class ComputerFactory { fun produce(type: ComputerType): Computer { return when(type) { ComputerType.PC -&gt; PC() ComputerType.Server -&gt; Server() } }} ä»¥ä¸Šä»£ç é€šè¿‡è°ƒç”¨ComputerFactoryç±»çš„produceæ–¹æ³•æ¥åˆ›å»ºä¸åŒçš„Computerå­ç±»å¯¹è±¡ï¼Œè¿™æ ·æˆ‘ä»¬å°±æŠŠåˆ›å»ºå®žä¾‹çš„é€»è¾‘ä¸Žå®¢æˆ·ç«¯ä¹‹é—´å®žçŽ°è§£è€¦ï¼Œå½“å¯¹è±¡åˆ›å»ºçš„é€»è¾‘å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè¯¥æ¨¡å¼åªéœ€è¦ä¿®æ”¹produceå‡½æ•°å†…éƒ¨çš„ä»£ç å³å¯ï¼Œç›¸æ¯”ç›´æŽ¥åˆ›å»ºå¯¹è±¡çš„æ–¹æ³•æ›´åŠ åˆ©äºŽç»´æŠ¤ã€‚ è™½ç„¶å®ƒæ”¹å–„äº†ç¨‹åºçš„å¯ç»´æŠ¤æ€§ï¼Œä½†åˆ›å»ºå¯¹è±¡çš„çš„è¡¨è¾¾ä¸Šå´æ˜¾å¾—ä¸å¤Ÿç®€æ´ã€‚å½“æˆ‘ä»¬åœ¨ä¸åŒçš„åœ°æ–¹åˆ›å»ºComputerçš„å­ç±»å¯¹è±¡æ—¶ï¼Œæˆ‘ä»¬éƒ½éœ€è¦å…ˆåˆ›å»ºä¸€ä¸ªComputerFactoryç±»å¯¹è±¡ï¼Œè€ŒKotlinå¤©ç”Ÿæ”¯æŒäº†å•ä¾‹ï¼ŒæŽ¥ä¸‹æ¥æˆ‘ä»¬å°±ç”¨objectå…³é”®å­—ä»¥åŠç›¸å…³çš„ç‰¹æ€§æ¥è¿›ä¸€æ­¥ç®€åŒ–ä»¥ä¸Šçš„ä»£ç è®¾è®¡ã€‚ ç”¨å•ä¾‹ä»£æ›¿å·¥åŽ‚ç±»Kotlinæ”¯æŒç”¨objectæ¥å®žçŽ°Javaä¸­çš„å•ä¾‹æ¨¡å¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å®žçŽ°ä¸€ä¸ªComputerFactoryå•ä¾‹ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå·¥åŽ‚ç±»ã€‚ object ComputerFatory { fun produce(type: ComputerType): Computer { return when(type) { ComputerType.PC -&gt; PC() ComputerType.Server -&gt; Server() } }}//è°ƒç”¨ComputerFactory.produce(ComputerType.PC) æ­¤å¤–ï¼Œç”±äºŽæˆ‘ä»¬é€šè¿‡ä¼ å…¥Computerç±»åž‹æ¥åˆ›å»ºä¸åŒçš„å¯¹è±¡ï¼Œæ‰€ä»¥è¿™é‡Œçš„produceåˆæ˜¾å¾—å¤šä½™ï¼Œè€ŒKotlinæ”¯æŒè¿ç®—ç¬¦é‡è½½ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡operatoræ“ä½œç¬¦é‡è½½invokeæ–¹æ³•æ¥ä»£æ›¿produceï¼Œä»Žè€Œè¿›ä¸€æ­¥ç®€åŒ–è¡¨è¾¾ï¼š object ComputerFactory { operator fun invoke(type: ComputerType): Computer { return when(type) { ComputerType.PC -&gt; PC() ComputerType.Server -&gt; Server() } }}//è°ƒç”¨ComputerFactory(ComputerType.PC) ä¾é Kotlinè¿™ä¸€ç‰¹æ€§ï¼Œæˆ‘ä»¬å†åˆ›å»ºä¸€ä¸ªComputerå¯¹è±¡å°±æ˜¾å¾—éžå¸¸ç®€æ´ï¼Œä¸Žç›´æŽ¥åˆ›å»ºä¸€ä¸ªå…·ä½“ç±»å®žä¾‹æ˜¾å¾—æ²¡æœ‰å¤ªå¤§åŒºåˆ«ã€‚ ä¼´ç”Ÿå¯¹è±¡åˆ›å»ºé™æ€å·¥åŽ‚æ–¹æ³•å½“å‰çš„å·¥åŽ‚æ¨¡å¼å®žçŽ°å·²ç»è¶³å¤Ÿä¼˜é›…ï¼Œè€Œä½ ä¾æ—§è§‰å¾—ä¸å¤Ÿå®Œç¾Žï¼šæˆ‘ä»¬æ˜¯å¦å¯ä»¥ç›´æŽ¥é€šè¿‡Computer()è€Œä¸æ˜¯ComputerFactory()æ¥åˆ›å»ºä¸€ä¸ªå®žä¾‹å‘¢ï¼Ÿ ã€ŠEffective Javaã€‹ä¸€ä¹¦çš„ç¬¬ä¸€æ¡æŒ‡å¯¼åŽŸåˆ™ï¼šè€ƒè™‘ç”¨é™æ€å·¥åŽ‚æ–¹æ³•ä»£æ›¿æž„é€ å™¨ã€‚ Kotlinä¸­çš„ä¼´ç”Ÿå¯¹è±¡ï¼Œä»£æ›¿äº†Javaä¸­çš„staticï¼ŒåŒæ—¶åœ¨åŠŸèƒ½å’Œè¡¨è¾¾ä¸Šæ‹¥æœ‰æ›´å¼ºçš„èƒ½åŠ›ã€‚é€šè¿‡åœ¨ComputeræŽ¥å£ä¸­å®šä¹‰ä¸€ä¸ªä¼´ç”Ÿå¯¹è±¡ï¼Œæˆ‘ä»¬å°±èƒ½å®žçŽ°ä»¥ä¸Šçš„éœ€æ±‚ï¼š interface Computer { val cpu: String companion object Factory { operator fun invoke(type: ComputerType): Computer { return when(type) { ComputerType.PC -&gt; PC() ComputerType.Server -&gt; Server() } } }}//è°ƒç”¨Computer.Factory(ComputerType.PC) æ‰©å±•ä¼´ç”Ÿå¯¹è±¡æ–¹æ³•ä¾èµ–ä¼´ç”Ÿå¯¹è±¡çš„ç‰¹æ€§ï¼Œå·²ç»å®žçŽ°äº†ç»å…¸çš„å·¥åŽ‚æ¨¡å¼ã€‚åŒæ—¶è¿™ç§æ–¹å¼è¿˜æœ‰ä¸€ä¸ªä¼˜åŠ¿ï¼Œå®ƒæ¯”åŽŸæœ‰Javaä¸­çš„è®¾è®¡æ›´åŠ å¼ºå¤§ã€‚å‡å¦‚å®žé™…ä¸šåŠ¡ä¸­æˆ‘ä»¬æ˜¯Computerå€Ÿå£çš„ä½¿ç”¨è€…ï¼Œæ¯”å¦‚å®ƒæ˜¯å·¥ç¨‹å¼•å…¥çš„ç¬¬ä¸‰æ–¹ç±»åº“ï¼Œæ‰€æœ‰ç±»çš„å®žçŽ°ç»†èŠ‚éƒ½å¾—åˆ°äº†å¾ˆå¥½åœ°éšè—ã€‚é‚£ä¹ˆï¼Œå¦‚æžœå¸Œæœ›è¿›ä¸€æ­¥æ”¹é€ å…¶ä¸­çš„é€»è¾‘ï¼ŒKotlinä¸­ä¼´ç”Ÿå¯¹è±¡çš„æ–¹å¼åŒæ ·å¯ä»¥ä¾é å…¶æ‰©å±•å‡½æ•°çš„ç‰¹æ€§ï¼Œå¾ˆå¥½åœ°å®žçŽ°è¿™ä¸€éœ€æ±‚ã€‚ æ¯”å¦‚æˆ‘ä»¬éœ€è¦ç»™Computeræ·»åŠ ä¸€ç§åŠŸèƒ½ï¼Œé€šè¿‡CPUåž‹å·æ¥åˆ¤æ–­ç”µè„‘ç±»åž‹ï¼Œé‚£ä¹ˆä¹…å¯ä»¥å¦‚ä¸‹å®žçŽ°ï¼š fun Computer.Companion.fromCPU(cpu: String): ComputerType? { return when (cpu) { &quot;Core&quot; -&gt; ComputerType.PC &quot;Xeon&quot; -&gt; ComputerType.Server else -&gt; null }} å¦‚æžœæŒ‡å®šäº†ä¼´ç”Ÿå¯¹è±¡çš„åå­—ä¸ºFactory,é‚£ä¹ˆå°±å¯ä»¥å¦‚ä¸‹å®žçŽ°ï¼š fun Computer.Factory.fromCPU(cpu: String): ComputerType? = ... å†…è”å‡½æ•°ç®€åŒ–æŠ½è±¡å·¥åŽ‚å·¥åŽ‚æ¨¡å¼å·²ç»èƒ½å¤Ÿå¾ˆå¥½åœ°å¤„ç†ä¸€ä¸ªäº§å“ç­‰çº§ç»“æž„çš„é—®é¢˜ï¼Œä¸Šè¿°ç®€å•å·¥åŽ‚å·²ç»è§£å†³äº†ç”µè„‘åŽ‚å•†ç”Ÿäº§æœåŠ¡å™¨ã€PCæœºçš„é—®é¢˜ã€‚è¿›ä¸€æ­¥æ€è€ƒï¼Œå½“é—®é¢˜ä¸Šå‡åˆ°å¤šä¸ªäº§å“ç­‰çº§ç»“æž„çš„æ—¶å€™ï¼Œæ¯”å¦‚çŽ°åœ¨å¼•å…¥äº†å“ç‰Œå•†çš„æ¦‚å¿µï¼Œæˆ‘ä»¬æœ‰å¥½å‡ ä¸ªä¸åŒçš„ç”µè„‘å“ç‰Œï¼Œæ¯”å¦‚Dell,Asus,Acerï¼Œé‚£ä¹ˆå°±æœ‰å¿…è¦å†å¢žåŠ ä¸€ä¸ªå·¥åŽ‚ç±»ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¹¶ä¸å¸Œæœ›å¯¹æ¯ä¸ªæ¨¡åž‹éƒ½å»ºç«‹ä¸€ä¸ªå·¥åŽ‚ï¼Œè¿™ä¼šè®©ä»£ç å˜å¾—éš¾ä»¥ç»´æŠ¤ï¼Œæ‰€ä»¥è¿™æ—¶å€™éœ€è¦å¼•å…¥æŠ½è±¡å·¥åŽ‚æ¨¡å¼ã€‚ æŠ½è±¡å·¥åŽ‚æ¨¡å¼ä¸ºåˆ›å»ºä¸€ç»„ç›¸å…³æˆ–ç›¸äº’ä¾èµ–çš„å¯¹è±¡æä¾›ä¸€ä¸ªæŽ¥å£ï¼Œè€Œä¸”æ— é¡»æŒ‡å®šå®ƒä»¬çš„å…·ä½“ç±»ã€‚ åœ¨æŠ½è±¡å·¥åŽ‚çš„å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æŠŠâ€œä¸€ç»„ç›¸å…³æˆ–ç›¸äº’ä¾èµ–çš„å¯¹è±¡â€ç§°ä½œâ€œäº§å“æ—â€ï¼Œåœ¨ä¸Šè¿°çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°±æåˆ°äº†3ä¸ªä»£è¡¨ä¸åŒç”µè„‘å“ç‰Œçš„äº§å“æ—ã€‚ä¸‹é¢æˆ‘ä»¬å°±åˆ©ç”¨æŠ½è±¡å·¥åŽ‚ï¼Œæ¥å®žçŽ°å…·ä½“éœ€æ±‚ï¼š interface Computerclass Dell: Computerclass Asus: Computerclass Acer: Computerclass DellFactory: AbstractFactory() { override fun produce() = Dell()}class AsusFactory: AbstractFactory() { override fun produce() = Asus()}class AcerFactory: AbstractFactory() { override fun produce() = Acer()}abstract class AbstractFactory { abstract fun produce(): Computer companion object { operator fun invoke(factory: AbstractFactory) = factory }}//è°ƒç”¨AbstractFactory(DellFactory()).produce() æ¯ä¸ªç”µè„‘å“ç‰Œæ‹¥æœ‰ä¸€ä¸ªä»£è¡¨ç”µè„‘äº§å“çš„ç±»ï¼Œå®ƒä»¬éƒ½å®žçŽ°äº†ComputeræŽ¥å£ã€‚æ­¤å¤–æ¯ä¸ªå“ç‰Œä¹Ÿè¿˜æœ‰ä¸€ä¸ªç”¨äºŽç”Ÿäº§ç”µè„‘çš„AbstractFactoryå­ç±»ï¼Œå¯é€šè¿‡AbstractFactoryç±»çš„ä¼´ç”Ÿå¯¹è±¡ä¸­çš„invokeæ–¹æ³•ï¼Œæ¥æž„é€ å…·ä½“å“ç‰Œçš„å·¥åŽ‚ç±»å¯¹è±¡ã€‚ ç”±äºŽKotlinè¯­æ³•çš„ç®€æ´ï¼Œä»¥ä¸Šä¾‹å­çš„æŠ½è±¡å·¥åŽ‚ç±»çš„è®¾è®¡ä¹Ÿæ¯”è¾ƒç›´è§‚ã€‚ç„¶è€Œï¼Œå½“ä½ æ¯æ¬¡åˆ›å»ºå…·ä½“çš„å·¥åŽ‚ç±»æ—¶ï¼Œéƒ½éœ€è¦ä¼ å…¥ä¸€ä¸ªå…·ä½“çš„å·¥åŽ‚ç±»å¯¹è±¡ä½œä¸ºå‚æ•°è¿›è¡Œæž„é€ ï¼Œè¿™ä¸ªåœ¨è¯­æ³•ä¸Šæ˜¾ç„¶ä¸æ˜¯å¾ˆä¼˜é›…ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å†…è”å‡½æ•°æ¥æ”¹å–„è¿™ä¸€æƒ…å†µï¼š abstract class AbstractFactory { abstract fun produce(): Computer companion object { inline operator fun &lt;reified T : Computer&gt; invoke() = when(T::class) { Dell::class -&gt; DellFactory() Asus::class -&gt; AsusFactory() Acer::class -&gt; AcerFactory() else -&gt; throw IllegalArgumentException() } }}//è°ƒç”¨AbstractFactory&lt;Dell&gt;().produce() é€šè¿‡å°†invokeæ–¹æ³•å®šä¹‰ä¸ºå†…è”å‡½æ•°ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼•å…¥reifiedå…³é”®å­—ï¼Œä½¿ç”¨å…·ä½“åŒ–å‚æ•°ç±»åž‹çš„è¯­æ³•ç‰¹æ€§ è¦å…·ä½“åŒ–çš„å‚æ•°ç±»åž‹ä¸ºComputer,åœ¨invokeæ–¹æ³•ä¸­æˆ‘ä»¬é€šè¿‡åˆ¤æ–­å®ƒçš„å…·ä½“ç±»åž‹ï¼Œæ¥è¿”å›žå¯¹äºŽçš„å·¥åŽ‚ç±»å¯¹è±¡ å‚è€ƒ: Dive in Kotlin","link":"/2020/01/17/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"æ•™è¯²","text":"æ¼”å‘˜è¿™ä¸ªèŒä¸šç‰¹åˆ«æ®‹å¿ï¼Œå› ä¸ºä½ æ˜¯è¢«æŒ‘é€‰çš„ï¼Œäººå®¶æ²¡äººæ¥æ‰¾ä½ ï¼Œä½ å°±æ²¡æ´»å¹²ã€‚å› ä¸ºæˆ‘åšäº†37å¹´çš„æ¼”å‘˜ï¼Œå¤§æ¦‚ä»Žä¸‰åå››äº”å²å¼€å§‹ï¼Œå°±æ²¡æœ‰äººæ‰¾æˆ‘æ¼”æˆäº†ï¼Œç„¶åŽä½ çœ¼çœ‹ç€ä½ å‘¨å›´çš„æœ‹å‹ï¼Œè¿™ä¸ªçº¢äº†ï¼Œé‚£ä¸ªçº¢äº†ã€‚ä¸€ç‚¹ä¸é‡è¦ï¼Œå› ä¸ºä½ è¦ä»Žäº‹çš„è¡Œä¸šä¸æ˜¯ä¸€å¹´ä¸¤å¹´ï¼Œä½ è¦ä»Žäº‹ä¸€ç”Ÿã€‚ &amp;emsp;&amp;emsp;æ¼”å‘˜è¿™ä¸ªèŒä¸šç‰¹åˆ«æ®‹å¿ï¼Œå› ä¸ºä½ æ˜¯è¢«æŒ‘é€‰çš„ï¼Œäººå®¶æ²¡äººæ¥æ‰¾ä½ ï¼Œä½ å°±æ²¡æ´»å¹²ã€‚å› ä¸ºæˆ‘åšäº†37å¹´çš„æ¼”å‘˜ï¼Œå¤§æ¦‚ä»Žä¸‰åå››äº”å²å¼€å§‹ï¼Œå°±æ²¡æœ‰äººæ‰¾æˆ‘æ¼”æˆäº†ï¼Œç„¶åŽä½ çœ¼çœ‹ç€ä½ å‘¨å›´çš„æœ‹å‹ï¼Œè¿™ä¸ªçº¢äº†ï¼Œé‚£ä¸ªçº¢äº†ã€‚ä¸€ç‚¹ä¸é‡è¦ï¼Œå› ä¸ºä½ è¦ä»Žäº‹çš„è¡Œä¸šä¸æ˜¯ä¸€å¹´ä¸¤å¹´ï¼Œä½ è¦ä»Žäº‹ä¸€ç”Ÿã€‚&amp;emsp;&amp;emsp;æ‰€ä»¥ï¼Œèƒ½å¤Ÿåšä¸€ä¸ªä¸æ€¥ä¸èºçš„æ¼”å‘˜ï¼Œæ°¸è¿œè°¦é€Šï¼Œçœ‹å¾—è§çœŸæ­£æ£’çš„äººï¼Œæ¬£èµå¾—äº†çœŸæ­£å¥½çš„è¡¨æ¼”ï¼Œæ°¸è¿œä¸åŽ»æ¯”æ‹¼ç²‰ä¸ï¼Œä½ ä¸€å®šä¼šæˆä¸ºä¸€ä¸ªå¤§æ¼”å‘˜çš„ï¼Œä½ å¾ˆæ£’!","link":"/2017/11/26/%E6%95%99%E8%AF%B2/"},{"title":"ä»Žè‡ªå·±èº«ä¸Šæ‰¾é—®é¢˜æˆ–è®¸æ˜¯ä¸€ç§å¦¥å","text":"é—®é¢˜ä¸€å®šå­˜åœ¨ï¼Œæ²¡æœ‰å®Œäººï¼Œæˆ‘å¸¸ä»Žè‡ªå·±èº«ä¸Šæ‰¾é—®é¢˜ã€‚é—®é¢˜å¸¸å¸¸å­˜åœ¨ï¼Œä½†ä¸æ˜¯éžé»‘å³ç™½ï¼Œä¸ä»£è¡¨ä¸€æ–¹æœ‰é—®é¢˜. é—®é¢˜æ‰€åœ¨é—®é¢˜ä¸€å®šå­˜åœ¨ï¼Œæ²¡æœ‰å®Œäººï¼Œæˆ‘å¸¸ä»Žè‡ªå·±èº«ä¸Šæ‰¾é—®é¢˜ã€‚é—®é¢˜å¸¸å¸¸å­˜åœ¨ï¼Œä½†ä¸æ˜¯éžé»‘å³ç™½ï¼Œä¸ä»£è¡¨ä¸€æ–¹æœ‰é—®é¢˜ï¼Œå¦ä¸€æ–¹å°±ä¸‡äº‹å¤§å‰ï¼Œå¾€å¾€æ˜¯ä¸€ä¸ªå·´æŽŒæ‹ä¸å“çš„äº‹å®žã€‚å¯æ˜¯ç»“æžœå¾€å¾€æ˜¯ï¼Œæ–¹æ¡Œçš„é‚£ä¸€è¾¹è®©è‡ªå·±é«˜é«˜åœ¨ä¸Šï¼Œæ¯«æ— æ±¡ç‚¹ï¼Œå é¢†é“å¾·çš„è‡³é«˜å³°ï¼Œå¼€å§‹ç‹‚è½°æ»¥ç‚¸ï¼Œæ¯æ¯å–„è‰¯çš„æ‰¿è®¤è¿‡å¤±åŽï¼Œå¸¦æ¥çš„ç»“æžœå¾€å¾€ä¸å ªè®¾æƒ³ã€‚ ä¸ºä»€ä¹ˆä¼šå‡ºçŽ°è¿™ç§å±€é¢ï¼Œé—®é¢˜æ‰€åœ¨ä½•å¤„ï¼Ÿ æ¯ä¸ªäººéƒ½æ˜¯ä¸€ä¸ªå®Œæ•´çš„ä¸ªä½“ï¼Œäººå‡ºçŽ°åœ¨è¿™ä¸ªä¸–ç•Œä¸Šï¼Œå°±å¼€å§‹ä¸ºäº†æ´»å››å¤„å¥”æ³¢ï¼Œä¸ºäº†å–åˆ°ç¬¬ä¸€å£å¥¶æ‹¼å‘½å“­å–Šï¼Œä¸ºäº†æ‘†è„±çŽ°æœ‰é˜¶çº§åŠªåŠ›è¯»ä¹¦ï¼Œä¸ºäº†ç¹è‚²åŽä»£ç»“å©šç”Ÿå­ï¼Œä¸ºäº†å…»æ´»å®¶äººåœ¨ä¸–ä¸Šå—å°½å§”å±ˆã€‚å®Œæ•´çš„ä¸ªä½“åº”è¯¥æœ‰ä¸€å¥—ç‹¬ç‰¹çš„è‡ªæˆ‘é˜²å¾¡æœºåˆ¶ï¼Œå…µæ¥å°†æŒ¡æ°´æ¥åœŸæŽ©ã€‚è‡ªæˆ‘æˆé•¿åº”è¯¥æ˜¯éšè—åœ¨å¤–å£³é‡Œçš„ï¼Œå¤–å£³åº”è¯¥æ˜¯åœ†æ»‘åšç¡¬çš„ï¼Œä¸åº”è¯¥é€æ¼å‡ºä»»ä½•å¼±ç‚¹ã€‚å› ä¸ºä¸€æ—¦å¼±ç‚¹å‡ºçŽ°ï¼Œå°±ä¼šå—åˆ°å¤–éƒ¨çš„çŒ›çƒˆæ”»å‡»ï¼Œè¿™æ˜¯ä¸›æž—æ³•åˆ™ï¼Œä¸å®¹è´¨ç–‘ã€‚ é‚£çŽ°åœ¨çŸ¥é“é—®é¢˜æ‰€åœ¨äº†ï¼Œè‡ªæˆ‘åçœæ˜¯ä¸å¯æˆ–ç¼ºçš„ï¼Œåçœçš„è¿‡ç¨‹ï¼Œæ”¹æ­£çš„è¿‡ç¨‹æ­£æ˜¯è‡ªæˆ‘æˆé•¿çš„è¿‡ç¨‹ï¼Œä¹Ÿå°±æ˜¯åœ¨å¤–å£³é‡Œçš„è‡ªæˆ‘è„±å˜ã€‚èœ•å˜åªå±žäºŽè‡ªå·±ï¼Œä¸€æ—¦è¢«å¤–ç•ŒèŽ·çŸ¥ï¼Œç‰¹åˆ«æ˜¯åˆ©ç›Šç›¸å…³ï¼Œè½»åˆ™äººæ ¼å—åˆ°ä¾®è¾±ï¼Œå¤±åŽ»ä¿¡ä»»ï¼Œä¸¢æŽ‰å·¥ä½œï¼Œé‡åˆ™è‡ªæˆ‘é˜²å¾¡æœºåˆ¶è¢«æ”»ç ´ï¼Œæ— æ³•è‡ªæˆ‘ä¿®å¤ï¼Œç»ˆç”ŸæŠ‘éƒä¸å¾—å¿—ã€‚ é‚£ä¹ˆå¾—åˆ°çš„æ˜¯ä¸€ä¸ªä¸–ä¿—çš„ç»“æžœï¼š æŠ«ç€è™šä¼ªçš„çš®åœ¨è¿™ä¸–é—´è¡Œèµ°ï¼Œä»¥åŽï¼ŒæŸ”è½¯çš„ä¸€é¢åªå±žäºŽè‡ªå·±ï¼Œç›´åˆ°é¢å…·é•¿è¿›è‚‰é‡Œï¼Œæ·±å…¥çµé­‚ã€‚ä¸å¿…æ²®ä¸§ï¼Œè‡ªå·±æ‰¿å—è¿™ä¸€åˆ‡ï¼Œç…§é¡¾å¥½èº«è¾¹çš„äº²äººï¼Œç¥ä½ æ´»å‡ºè‡ªå·±ã€‚","link":"/2018/02/02/%E4%BB%8E%E8%87%AA%E5%B7%B1%E8%BA%AB%E4%B8%8A%E6%89%BE%E9%97%AE%E9%A2%98%E6%88%96%E8%AE%B8%E6%98%AF%E4%B8%80%E7%A7%8D%E5%A6%A5%E5%8D%8F/"},{"title":"æ— é¢˜","text":"è‡ªæˆ‘ç¾žè€»æ„Ÿåœ¨ä½ å¿ƒåº•é—ªé—ªå‘å…‰çŸ¥é“æ¯”å­¤ç‹¬å¯æ€•åƒä¸‡å€æˆ‘å¯¹æ¯ä¸ªäººéƒ½å‹å–„ï¼Œå´ä»Žæœªåˆ‡å®žæ„Ÿå—è¿‡â€œå‹æƒ…â€å·®è‡ªå·±çš„ä¸€å¥æŠ±æ­‰ï¼Œè¯´ç»™äº†ä¸–ç•Œ â€”â€”â€”â€”ã€Šäººé—´å¤±æ ¼ã€‹å¤ªå®°æ²»","link":"/2020/02/25/%E6%97%A0%E9%A2%98/"},{"title":"ç”¨åå‡½æ•°å®žçŽ°è´£ä»»é“¾æ¨¡å¼","text":"è´£ä»»é“¾æ¨¡å¼çš„ç›®çš„å°±æ˜¯é¿å…è¯·æ±‚çš„å‘é€è€…å’ŒæŽ¥æ”¶è€…ä¹‹é—´çš„è€¦åˆå…³ç³»ï¼Œå°†è¿™ä¸ªå¯¹è±¡è¿žæˆä¸€æ¡é“¾ï¼Œå¹¶æ²¿ç€è¿™æ¡é“¾ä¼ é€’è¯¥è¯·æ±‚ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªå¯¹è±¡å¤„ç†å®ƒä¸ºæ­¢ã€‚ å‡å¦‚ä½ é‡åˆ°è¿™æ ·çš„ä¸šåŠ¡éœ€æ±‚åœºæ™¯ï¼šå¸Œæœ›ä½¿å¾—å¤šä¸ªå¯¹è±¡éƒ½æœ‰æœºä¼šå¤„ç†æŸç§ç±»åž‹çš„è¯·æ±‚ï¼Œé‚£ä¹ˆå¯èƒ½å°±éœ€è¦è€ƒè™‘æ˜¯å¦å¯ä»¥é‡‡ç”¨è´£ä»»é“¾æ¨¡å¼ã€‚ å…¸åž‹çš„ä¾‹å­å°±æ˜¯Servletä¸­çš„Filterå’ŒFilterChainæŽ¥å£ï¼Œå®ƒä»¬å°±é‡‡ç”¨äº†è´£ä»»é“¾æ¨¡å¼ã€‚åˆ©ç”¨è´£ä»»é“¾æ¨¡å¼æˆ‘ä»¬å¯ä»¥åœ¨æŽ¥æ”¶åˆ°ä¸€ä¸ªWebè¯·æ±‚æ—¶ï¼Œå…ˆè¿›è¡Œå„ç§filteré€»è¾‘çš„æ“ä½œï¼Œfilteréƒ½å¤„ç†å®Œä¹‹åŽæ‰æ‰§è¡Œservletã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä¸åŒçš„filterä»£è¡¨äº†ä¸åŒçš„èŒè´£ï¼Œæœ€ç»ˆå®ƒä»¬å½¢æˆäº†ä¸€ä¸ªè´£ä»»é“¾ã€‚ ç®€å•æ¥è¯´ï¼Œè´£ä»»é“¾æ¨¡å¼çš„ç›®çš„å°±æ˜¯é¿å…è¯·æ±‚çš„å‘é€è€…å’ŒæŽ¥æ”¶è€…ä¹‹é—´çš„è€¦åˆå…³ç³»ï¼Œå°†è¿™ä¸ªå¯¹è±¡è¿žæˆä¸€æ¡é“¾ï¼Œå¹¶æ²¿ç€è¿™æ¡é“¾ä¼ é€’è¯¥è¯·æ±‚ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªå¯¹è±¡å¤„ç†å®ƒä¸ºæ­¢ã€‚ çŽ°åœ¨ä¸¾ä¸€ä¸ªæ›´å…·ä½“çš„ðŸŒ°ã€‚è®¡ç®—æœºå­¦é™¢çš„å­¦ç”Ÿä¼šç®¡ç†äº†ä¸€ä¸ªå­¦ç”Ÿä¼šåŸºé‡‘ï¼Œç”¨äºŽå„ç§æ´»åŠ¨å’Œç»„ç»‡äººå‘˜å·¥ä½œçš„å¼€æ”¯ã€‚å½“è¦å‘ç”Ÿä¸€ç¬”æ”¯å‡ºæ—¶ï¼Œå¦‚æžœé‡‘é¢åœ¨100å…ƒä¹‹å†…ï¼Œå¯ç”±å„ä¸ªåˆ†éƒ¨é•¿å®¡æ‰¹ï¼›å¦‚æžœé‡‘é¢è¶…è¿‡äº†100å…ƒï¼Œé‚£ä¹ˆå°±éœ€è¦ä¼šé•¿åŒæ„ï¼›ä½†å‡ä½¿é‡‘é¢è¾ƒå¤§ï¼Œè¾¾åˆ°äº†500å…ƒä»¥ä¸Šï¼Œé‚£ä¹ˆå°±éœ€è¦å­¦é™¢çš„è¾…å¯¼å‘˜é™ˆè€å¸ˆæ‰¹å‡†ã€‚æ­¤å¤–ï¼Œå­¦é™¢é‡Œè¿˜æœ‰ä¸€ä¸ªä¸å®£çš„è§„å®šï¼Œç»è´¹çš„ä¸Šé™ä¸º1000å…ƒï¼Œå¦‚æžœè¶…å‡ºåˆ™é»˜è®¤æ‰“å›žç”³è¯·ã€‚ å½“ç„¶æˆ‘ä»¬å¯ä»¥ç”¨æœ€ç®€å•çš„if-elseæ¥å®žçŽ°ç»è´¹å®¡æ‰¹çš„éœ€æ±‚ã€‚ç„¶è€Œæ ¹æ®å¼€é—­åŽŸåˆ™ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶ä¸­çš„é€»è¾‘è¿›è¡Œè§£è€¦ã€‚ä¸‹é¢æˆ‘ä»¬å°±ç”¨é¢å‘å¯¹è±¡çš„æ€è·¯ç»“åˆè´£ä»»é“¾æ¨¡å¼ï¼Œæ¥è®¾è®¡ä¸€ä¸ªç¨‹åºã€‚ data class ApplyEvent(val monkey: Int, val title: String)interface ApplyHandler { val successor: ApplyHandler? fun handleEvent(event: ApplyEvent)}class GroupLeader(override val successor: ApplyHandler?): ApplyHandler { override fun handleEvent(event: ApplyEvent) { when { event.monkey &lt;= 100 -&gt; print(&quot;Group Leader handled application: ${event.title}&quot;) else -&gt; when(successor) { is ApplyHandler -&gt; successor.handleEvent(event) else -&gt; print(&quot;Group Leader: This application cannot be handdle&quot;) } } }}class President(override val successor: ApplyHandler?) :ApplyHandler { override fun handleEvent(event: ApplyEvent) { when { event.monkey &lt;= 500 -&gt; print(&quot;President handled application: ${event.title}&quot;) else -&gt; when(successor) { is ApplyHandler -&gt; successor.handleEvent(event) else -&gt; print(&quot;President: This application cannot be handdle.&quot;) } } }}class College(override val successor: ApplyHandler?) :ApplyHandler { override fun handleEvent(event: ApplyEvent) { when { event.monkey &gt; 1000 -&gt; print(&quot;College: This application is refused.&quot;) else -&gt; print(&quot;College handled application: ${event.title}.&quot;) } }} æˆ‘ä»¬å£°æ˜Žäº†GroupLeader,President,Collegeä¸‰ä¸ªç±»æ¥ä»£è¡¨å­¦ç”Ÿä¼šéƒ¨é•¿ï¼Œåˆ†ä¼šé•¿ï¼Œä¼šé•¿åŠå­¦é™¢ï¼Œå®ƒä»¬éƒ½å®žçŽ°äº†ApplyHandleræŽ¥å£ã€‚æŽ¥å£åŒ…å«äº†ä¸€ä¸ªå¯ç©ºçš„åŽç»§è€…å¯¹è±¡successorï¼Œä»¥åŠå¯¹ç”³è¯·äº‹ä»¶çš„å¤„ç†æ–¹æ³•handleEventã€‚ å½“æˆ‘ä»¬æŠŠä¸€ä¸ªç”³è¯·ç»è´¹çš„äº‹ä»¶ä¼ é€’ç»™GroupLeaderå¯¹è±¡è¿›è¡Œå¤„ç†æ—¶ï¼Œå®ƒä¼šæ ¹æ®å…·ä½“çš„ç»è´¹é‡‘é¢æ¥åˆ¤æ–­é‡‘é¢æ¥åˆ¤æ–­æ˜¯å¦å°†ç”³è¯·è½¬äº¤ç»™successorå¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯Presidentç±»æ¥å¤„ç†ã€‚ä»¥æ­¤ç±»æŽ¨ï¼Œæœ€ç»ˆå½¢æˆäº†ä¸€ä¸ªè´£ä»»é“¾æœºåˆ¶ï¼š st=&gt;start: ç»è´¹ç”³è¯·op1=&gt;operation: å­¦ç”Ÿéƒ¨é•¿op2=&gt;operation: åˆ†ä¼šé•¿op3=&gt;operation: ä¼šé•¿op4=&gt;operation: å­¦é™¢cond1=&gt;condition: æ˜¯å¦å°äºŽ100å…ƒcond2=&gt;condition: æ˜¯å¦å°äºŽ500å…ƒcond3=&gt;condition: æ˜¯å¦å°äºŽ1000å…ƒe1=&gt;end: ç”³è¯·æˆåŠŸe2=&gt;end: ç”³è¯·å¤±è´¥st-&gt;cond1cond1(yes)-&gt;op1-&gt;e1cond1(no)-&gt;cond2cond2(yes)-&gt;op2-&gt;e1cond2(no)-&gt;cond3cond3(yes)-&gt;op3-&gt;e1cond3(no)-&gt;e2 fun main(args: Array&lt;String&gt;) { val College = College(null) val president = President(college) val groupLeader = GroupLeader(president) groupLeader.handleEvent(ApplyEvent(10,&quot;buy a pen&quot;)) groupLeader.handleEvent(ApplyEvent(200,&quot;team building&quot;)) groupLeader.handleEvent(ApplyEvent(600,&quot;hold a debate match&quot;)) groupLeader.handleEvent(ApplyEvent(1200,&quot;annual meeting of the college&quot;))}//resultGroup Leader handled application: buy a pen.President handled application: team building.College handled applicatioon: hold a debate match.College: This application is refused. æ¢³ç†ä¸€ä¸‹è´£ä»»é“¾çš„æœºåˆ¶ï¼Œæ•´ä¸ªé“¾æ¡çš„æ¯ä¸ªå¤„ç†çŽ¯èŠ‚éƒ½æœ‰å¯¹å…¶è¾“å…¥å‚æ•°çš„æ•ˆéªŒæ ‡å‡†ï¼Œå½“è¾“å…¥å‚æ•°å¤„äºŽæŸä¸ªè´£ä»»é“¾çŽ¯èŠ‚çš„æœ‰æ•ˆæŽ¥æ”¶èŒƒå›´ä¹‹å†…ï¼Œè¯¥çŽ¯èŠ‚æ‰èƒ½å¯¹å…¶ä½œå‡ºæ­£å¸¸çš„å¤„ç†æ“ä½œã€‚åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªä¸“é—¨çš„æœ¯è¯­æ¥æè¿°è¿™ç§æƒ…å†µï¼Œè¿™å°±æ˜¯â€œåå‡½æ•°â€ã€‚ å®žçŽ°åå‡½æ•°ç±»åž‹ï¼šPartialFunctioné‚£ï¼Œä»€ä¹ˆæ˜¯åå‡½æ•°å‘¢ï¼Ÿ åå‡½æ•°æ˜¯æ•°å­¦ä¸­çš„æ¦‚å¿µï¼ŒæŒ‡çš„æ˜¯å®šä¹‰åŸŸXä¸­å¯èƒ½å­˜åœ¨æŸäº›å€¼åœ¨å€¼åŸŸYä¸­æ²¡æœ‰å¯¹åº”çš„å€¼ã€‚ ä¸ºäº†æ–¹ä¾¿ç†è§£ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠåå‡½æ•°ä¸Žæ™®é€šå‡½æ•°è¿›è¡Œæ¯”è¾ƒã€‚åœ¨ä¸€ä¸ªæ™®é€šå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç»™æŒ‡å®šç±»åž‹çš„å‚æ•°ä¼ å…¥ä»»æ„è¯¥ç±»åž‹çš„å€¼ï¼Œæ¯”å¦‚(Int)-&gt;Unitï¼Œå¯ä»¥æŽ¥æ”¶ä»»ä½•Intå€¼ã€‚è€Œåœ¨ä¸€ä¸ªåå‡½æ•°ä¸­ï¼ŒæŒ‡å®šç±»åž‹çš„å‚æ•°å¹¶ä¸æŽ¥æ”¶ä»»æ„è¯¥ç±»åž‹çš„å€¼ï¼Œæ¯”å¦‚ï¼š fun mustGreaterThan5(x: Int): Boolean { if (x &gt; 5) { return true } throw Exception(&quot;x must be greator than 5&quot;)}&gt;&gt;&gt; mustGreatorThan5(6)true&gt;&gt;&gt; mustGreatorThan5(1)java.lang.Exception: x must be greatoor than 5 at Line17.mustGreatorThan5(Unknow Source) ä¹‹æ‰€ä»¥æé«˜åå‡½æ•°æ˜¯å› ä¸ºåœ¨ä¸€äº›å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå¦‚Scalaï¼Œæœ‰ä¸€ç§PartialFunctionç±»åž‹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥ç®€åŒ–è´£ä»»é“¾æ¨¡å¼çš„å®žçŽ°ã€‚ç”±äºŽKotlinçš„è¯­è¨€ç‰¹æ€§è¶³å¤Ÿçµæ´»å¼ºå¤§ï¼Œè™½ç„¶å®ƒçš„æ ‡å‡†åº“æ²¡æœ‰æ”¯æŒPartialFunctionï¼Œç„¶è€Œä¸€äº›å¼€æºåº“ï¼ˆå¦‚Arrowï¼‰å·²ç»å®žçŽ°äº†è¿™ä¸ªåŠŸèƒ½ã€‚æˆ‘ä»¬æ¥å®šä¹‰ä¸€ä¸ªPartialFunctionç±»åž‹ï¼š class PartialFunction&lt;in P1, out R&gt; ( private val definetAt: (P1) -&gt; Boolean, private val f: (P1) -&gt; R) : (P1) -&gt; R { override fun invoke(p1: P1): R { if (definetAt(p1)) { return f(p1) } throw IllegalArgumentException(&quot;Value: ($p1) isn't supported by this function&quot;) } fun isDefinetAt(p1: P1) = definetAt(p1)} çŽ°åœ¨æ¥åˆ†æžä¸‹PartialFunctionç±»çš„å…·ä½“ä½œç”¨ï¼š å£°æ˜Žç±»å¯¹è±¡æ—¶éœ€è¦æŽ¥æ”¶ä¸¤ä¸ªæž„é€ å‚æ•°ï¼ŒdefinetAtä¸ºæ•ˆéªŒå‡½æ•°ï¼Œfä¸ºå¤„ç†å‡½æ•° å½“PartialFunctionç±»å¯¹è±¡æ‰§è¡Œinvokeæ–¹æ³•æ—¶ï¼ŒdefinetAtä¼šå¯¹è¾“å‡ºå‚æ•°p1è¿›è¡Œæœ‰æ•ˆæ€§æ•ˆéªŒ å¦‚æžœæ•ˆéªŒç»“æžœé€šè¿‡ï¼Œåˆ™æ‰§è¡Œfå‡½æ•°ï¼ŒåŒæ—¶å°†p1ä½œä¸ºå‚æ•°ä¼ é€’ç»™å®ƒï¼Œåä¹‹æŠ›å‡ºå¼‚å¸¸ å¦‚ä¸ŠPartialFunctionç±»å·²ç»å¯ä»¥å¤„ç†è´£ä»»é“¾æ¨¡å¼ä¸­å„ä¸ªçŽ¯èŠ‚å¯¹äºŽè¾“å…¥çš„æ•ˆéªŒåŠå¤„ç†é€»è¾‘çš„é—®é¢˜ï¼Œä½†æ˜¯ä¾æ—§æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯å¦‚ä½•å°†è¯·æ±‚åœ¨æ•´ä¸ªé“¾æ¡ä¸­è¿›è¡Œä¼ é€’ã€‚ æŽ¥ä¸‹æ¥æˆ‘ä»¬åˆ©ç”¨Kotlinçš„æ‰©å±•å‡½æ•°ç»™PartialFunctionç±»å¢žåŠ ä¸€ä¸ªorElseæ–¹æ³•ã€‚åœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ³¨æ„ä¸‹è¿™ä¸ªç±»ä¸­çš„isDefinedAtæ–¹æ³•ï¼Œå®ƒå…¶å®žå¹¶æ²¡æœ‰ä»€ä¹ˆç‰¹æ®Šä¹‹å¤„ï¼Œä»…ä»…åªæ˜¯ä½œä¸ºæ‹·è´definetAtçš„ä¸€ä¸ªå†…éƒ¨æ–¹æ³•ï¼Œä¸ºäº†åœ¨orElseæ–¹æ³•ä¸­èƒ½å¤Ÿè¢«è°ƒç”¨ã€‚ infix fun &lt;P1, R&gt; PartialFunction&lt;P1, R&gt;.orElse(that: PartialFunction&lt;P1, R&gt;): PartialFunction&lt;P1, R&gt; { return PartialFunction({ this.isDefinedAt(it) || that.isDefinedAt(it) }) { when { this.isDefinedAt(it) -&gt; this(it) else -&gt; that(it) } }} åœ¨orElseæ–¹æ³•ä¸­å¯ä»¥ä¼ å…¥å¦ä¸€ä¸ªPartialFunctionç±»å¯¹è±¡thatï¼Œå®ƒä¹Ÿå°±æ˜¯è´£ä»»é“¾æ¨¡å¼ä¸­çš„åŽç»§è€…ã€‚å½“isDefinedAtæ–¹æ³•æ‰§è¡Œç»“æžœä¸ºfalseçš„æ—¶å€™ï¼Œé‚£ä¹ˆå°±è°ƒç”¨thatå¯¹è±¡æ¥å¤„ç†ç”³è¯·ã€‚ è¿™é‡Œç”¨infixå…³é”®å­—æ¥è®©orElseæˆä¸ºä¸€ä¸ªä¸­è¾å‡½æ•°ï¼Œä»Žè€Œè®©é“¾å¼è°ƒç”¨å˜å¾—æ›´åŠ ç›´è§‚ã€‚ ç”¨orElseæž„å»ºè´£ä»»é“¾æŽ¥ä¸‹æ¥æˆ‘ä»¬å°±ç”¨è®¾è®¡å¥½çš„PartialFunctionç±»åŠæ‰©å±•çš„orElseæ–¹æ³•ï¼Œæ¥é‡æ–°å®žçŽ°ä»¥ä¸‹æœ€å¼€å§‹çš„ä¾‹å­ã€‚é¦–å…ˆæ¥çœ‹çœ‹å¦‚ä½•ç”¨PartialFunctionå®šä¹‰groupLeaderå¯¹è±¡ï¼š data class ApplyEvent(val money: Int, val title: String)val groupLeader = { val definetAt: (ApplyEvent) -&gt; Boolean = { it.money &lt;= 200 } val handler: (ApplyEvent) -&gt; Unit = { println(&quot;Group Leader handled application: ${it.title}.&quot;) } PartialFunction(definetAt, handler)}() è¿™é‡Œæˆ‘ä»¬å€ŸåŠ©äº†è‡ªè¿è¡ŒLambdaçš„è¯­æ³•æ¥æž„å»ºä¸€ä¸ªPartialFunctionçš„å¯¹è±¡groupLeaderã€‚definetAtç”¨äºŽæ•ˆéªŒç”³è¯·çš„ç»è´¹é‡‘é¢æ˜¯å¦åœ¨å­¦ç”Ÿä¼šéƒ¨é•¿å¯å®¡æ‰¹çš„èŒƒå›´ä¹‹å†…ï¼Œhandlerå‡½æ•°ç”¨æ¥å¤„ç†ç«¥å¹´å„å›½é‡‘é¢æ•ˆéªŒåŽçš„å®¡æ‰¹æ“ä½œã€‚ åŒç†ï¼Œæˆ‘ä»¬ç”¨ç±»ä¼¼çš„æ–¹æ³•å†å®šä¹‰å‰©ä¸‹çš„presidentå’Œcollegeå¯¹è±¡ï¼š val president = { val definetAt: (ApplyEvent) -&gt; Boolean = { it.money &lt;= 500 } val handler: (ApplyEvent) -&gt; Unit = { println(&quot;President handled application: ${it.title}.&quot;) } PartialFunction(definetAt, handler)}()val college = { val definetAt: (ApplyEvent) -&gt; Boolean = { true } val handler: (ApplyEvent) -&gt; Unit = { when { it.money &gt; 1000 -&gt; println(&quot;College: This application is refused.&quot;) else -&gt; println(&quot;College handled application: ${it.title}.&quot;) } } PartialFunction(definetAt,handler)} æœ€åŽæˆ‘ä»¬ç”¨orElseæ¥æž„å»ºä¸€ä¸ªåŸºäºŽè´£ä»»é“¾æ¨¡å¼å’ŒPartialFunctionç±»åž‹çš„ä¸­è¾è¡¨è¾¾å¼applyChain: val applyChain = groupLeader orElse president orElse college&gt;&gt;&gt; applyChain(ApplyEvent(600,&quot;hold a debate match&quot;))College handled application: hold a debate match å€ŸåŠ©PartialFunctionç±»çš„å°è£…ï¼Œæˆ‘ä»¬ä¸ä»…å¤§å¹…åº¦å‡å°‘äº†ç¨‹åºçš„ä»£ç é‡ï¼Œè€Œä¸”åœ¨æž„å»ºè´£ä»»é“¾æ—¶ï¼Œå¯ä»¥ç”¨orElseèŽ·å¾—æ›´å¥½çš„è¯­æ³•è¡¨è¾¾ã€‚","link":"/2020/01/19/%E7%94%A8%E5%81%8F%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"title":"ç”Ÿè€Œä¸ºäººï¼Œå¯¹ä¸èµ·","text":"ä¸è¦å¸é£Ÿé¦™çƒŸï¼Œè‹¥éžèŠ‚æ—¥ï¼Œä¹Ÿåˆ«é¥®é…’ï¼Œé•¿å¤§åŽï¼Œè¯·å¤šåŠ çˆ±æƒœé‚£æ€§æ ¼å†…å‘ï¼Œä¸çˆ±æµ“å¦†çš„å§‘å¨˜ã€‚ &amp;emsp;&amp;emsp;â€œä»Žå°äº†è§£äº†äººç±»çš„ç§ç§å‘åŠ£ä¹‹å¤„ï¼Œå¯¹è¿™ç§å‘åŠ£æ·±æ·±åŽŒæ¶ï¼Œä½†ä»–éšåŽå‘çŽ°è‡ªå·±èº«ä¸Šä¹Ÿæœ‰è¿™ç§å‘åŠ£ï¼Œè¿›è€Œå¯¹è‡ªå·±ä¹Ÿäº§ç”Ÿäº†è¿™ç§åŽŒæ¶ã€‚ä½†æ˜¯ï¼Œå¶è—å¹¶æ²¡æœ‰åŠ›é‡åŽ»é˜»æ­¢ï¼Œç”šè‡³æ²¡æœ‰åŠ›é‡åŽ»åŠªåŠ›ï¼Œåªå¥½éšæ³¢é€æµï¼Œåšä¸€ä¸ªè¢«åŠ¨çš„äººã€‚ä¸ºäº†è„±ç¦»è¿™ç§ç½ªæ¶æ„Ÿï¼Œä»–çš„ç²¾ç¥žé¢†åŸŸé‡Œäº§ç”Ÿäº†ä¸€ç§è‡ªæˆ‘åˆ‡å‰²çŽ°è±¡ï¼ŒæŠŠè¿™äº›å‘åŠ£ï¼Œå…·çŽ°åŒ–æˆäº†é‚£ä¸ªé»‘è‰²çš„å°äººã€‚é‚£ä¸ªå°äººï¼Œå¯ä»¥è¯´æ˜¯å¶è—è‡ªå·±çš„ç½ªï¼Œä½†ä¹Ÿå¯ä»¥è¯´æ˜¯å¶è—è‡ªå·±ã€‚ä¸€èˆ¬äººï¼Œå…¶å®žæ˜¯ç»ˆç”Ÿå’Œå°äººå…±ç”Ÿä¸‹åŽ»çš„ï¼Œä½†å¶è—å¯¹äºŽå†…å¿ƒä¸–ç•Œæœ‰å¾ˆé«˜çš„è¿½æ±‚ï¼Œå¸Œæœ›æŠŠè¿™ä»¶äº‹æƒ…æ€è€ƒé€å½»ï¼Œæ‰€ä»¥æœ€åŽåªå¥½é™·å…¥äº†æžç«¯ï¼Œé€‰æ‹©æ”¾å¼ƒè‡ªå·±çš„ç”Ÿå‘½ã€‚å…¶å®žï¼Œäº†è§£åˆ°äººæ€§æœ¬æ¶è¿™ä¸€ç‚¹ï¼Œå…¶å®žä¸ä¸€å®šè¦èµ°å‘è¿™æ ·çš„æžç«¯ï¼Œä¸å¦‚æ”¾å¼ƒæŽ‰å¯¹äººæ€§çš„è™šå‡é¢„æœŸï¼Œæƒ³ç€æ€Žæ ·åœ¨æ¯ä»¶äº‹æƒ…ä¸ŠåŠªåŠ›å˜å¥½ï¼Œå¯èƒ½æ˜¯æ›´ç§¯æžçš„åšæ³•ã€‚ä¸è¿‡ï¼Œäººå¹¶ä¸èƒ½æ€»æ˜¯è¿™ä¹ˆåšå¼ºä¸Žé˜³å…‰ï¼Œæ‰€ä»¥å¶è—å¹¶ä¸éš¾å–å¾—è¯»è€…æŸç§ç¨‹åº¦ä¸Šçš„å…±æƒ…ï¼Œå› ä¸ºå®žé™…ä¸Šå¾ˆå¤šäººéƒ½æ›¾ç»å°è¯•è¿‡åƒå¶è—è¿™æ ·æ€è€ƒã€‚åªæ˜¯ï¼Œæœ€åŽä¸ä¸€å®šä¼šé€‰æ‹©è¿™ä¹ˆæžç«¯çš„æ–¹å¼ã€‚ä¸€éƒ¨æ–‡å­¦ä½œå“å¦‚æžœèƒ½å¤Ÿå¼•èµ·å¹¿æ³›çš„äººçš„å…±æƒ…ï¼Œé‚£ä¹ˆå°±æ˜¯æœ‰ä»·å€¼çš„ã€‚åªæ˜¯ï¼Œæˆ‘è¿™è¾¹ä»»ç„¶å¸Œæœ›è¯»è€…çœ‹åˆ°è¿™éƒ¨ä½œå“ä»¥åŽï¼Œæ˜¯æœ‰â€œåˆ«äººä¹Ÿæœ‰åŒæ ·ç»åŽ†ï¼Œèƒ½å¤Ÿç†è§£è‡ªå·±â€çš„æ²»æ„ˆï¼Œè€Œä¸è¦åœ¨è¿™ç§åŽŒæ¶çš„æƒ…ç»ªä¸­ç»§ç»­å‘å±•ã€‚å¶è—çº¤ç»†è€Œç½ªæ¶çš„çµé­‚ï¼Œå› ä¸ºä»–æœ¬èº«çš„è‡ªæˆ‘åçœå’Œç½ªæ¶æ„Ÿï¼Œè¿žåŒä»–çš„è¯šå®žå’Œä¸æ„¿æ„ä¼¤å®³ä»»ä½•äººçš„å‡ºå‘ç‚¹ï¼Œå…·æœ‰ä¸€ç§å€¼å¾—ç§°é¢‚çš„ä»·å€¼ï¼Œè¿™ä¹Ÿæ˜¯æœ€åŽè¯´â€œå¦‚åŒç¥žä¸€æ ·çš„å¥½å­©å­â€çš„åŽŸå› ã€‚æ— è®ºå¦‚ä½•ï¼Œäººçš„ç”Ÿå‘½å®è´µï¼Œåƒä¸‡è¦çæƒœã€‚äººæ€§ä¸ç¾Žå¥½ï¼Œå´æ­£æ˜¯æˆ‘ä»¬æ¯å¤©åŠªåŠ›çš„ä»·å€¼ï¼Œé»‘å¤œç»™äº†æˆ‘é»‘è‰²çš„çœ¼ç›ï¼Œæˆ‘å´ç”¨ä»–åŽ»å¯»æ‰¾å…‰æ˜Žã€‚â€ &amp;emsp;&amp;emsp;å¤§å¤šæ•°äººè¿žé€‰æ‹©æžç«¯æ–¹å¼çš„æƒåˆ©éƒ½æ²¡æœ‰ï¼Œç¢Œç¢Œç»ˆç”Ÿï¼Œæµ‘æµ‘å™©å™©ã€‚æˆ‘æœ‰æ•æ„Ÿçš„å†…å¿ƒï¼Œèƒ½å¤Ÿçœ‹åˆ°ç§ç§å‘åŠ£ï¼Œå´ä»¥â€œtoo lowâ€çš„æ–¹å¼åœ¨æ€ç»´å±‚é¢è—è§†ä¸€åˆ‡ï¼Œä»¿ä½›è‡ªå·±çœ‹é€ä¸–äº‹ï¼Œä¸äº‰ä¸æŠ¢ã€‚å´æ˜¯ä¸€ç§å¦¥åï¼Œæ›´å¦‚åŒé˜¿Qä¸€èˆ¬çš„æ‡¦å¼±ï¼ŒçœŸæ­£çš„å¦ç„¶åº”è¯¥å¦‚åŒé’»çŸ³ä¸€èˆ¬ç’€ç’¨ï¼Œè‡ªé¡¾ç‹¬è‡ªæ•£å‘å…‰è¾‰ï¼Œæ™¶èŽ¹å‰”é€ï¼Œå´åšéŸ§ä¸æ‘§ã€‚ &amp;emsp;&amp;emsp;è¦æ˜¯æœ‰ä¸€é¢—ç¾Žå¥½çš„ç§å­è¢«é£Žå¹èµ·ï¼Œåº”è¯¥æ”¾ä»»ä»–éšé£Žé£˜è½ï¼Œé£Žå„¿åœä¸‹æ¥çš„åœ°æ–¹ä¾¿æ˜¯ä»–çš„å®¶ï¼Œä¸€å®šè¦é¥±å—é£Žå¹é›¨æ‰“ï¼Œé£Žè¶Šç‹‚ï¼Œæ ¹èŒŽè¶Šæ˜¯æ·±å…¥åœŸå£¤ï¼Œé›¨è¶Šå¤§ï¼Œæ ‘æžæ›´åŠ è‹åŠ²æœ‰åŠ›ã€‚ å“Žï¼ŒçœŸæ˜¯æ ‘æ¬²æ­¢è€Œé£Žä¸å‡€é™ï¼ &amp;emsp;&amp;emsp;è¦æ˜¯ä¸€åªé¸Ÿï¼Œå«å¾—åƒé¸­å­ï¼Œæ¸¸å¾—åƒé¸­å­ï¼Œèµ°å¾—ä¹Ÿåƒé¸­å­ï¼Œé•¿ç€ç¾½æ¯›ä¹Ÿæœ‰è„šè¹¼ï¼Œè¿˜å’Œé¸­å­ä¸€èµ·ï¼Œé‚£å½“ç„¶ä¼šåˆ¤æ–­è¿™åªé¸Ÿå°±æ˜¯ä¸€åªé¸­å­ï¼Œå¯¹å—ï¼Ÿ &amp;emsp;&amp;emsp;äººæ€§ä¸ç¾Žå¥½ï¼Œå´æ­£æ˜¯æˆ‘ä»¬æ¯å¤©åŠªåŠ›çš„ä»·å€¼ï¼Œé»‘å¤œç»™äº†æˆ‘é»‘è‰²çš„çœ¼ç›ï¼Œæˆ‘å´ç”¨ä»–åŽ»å¯»æ‰¾å…‰æ˜Žã€‚","link":"/2019/01/27/%E7%94%9F%E8%80%8C%E4%B8%BA%E4%BA%BA%EF%BC%8C%E5%AF%B9%E4%B8%8D%E8%B5%B7/"},{"title":"ç¬¬ä¸€ç¯‡","text":"æˆ‘è¿™ç§åº”è¯¥æ˜¯ä¸ä¼šåŽ»å†™åšå®¢çš„ï¼Œè‡ªå·±çš„å°è±¡ç¬”è®°ä¹Ÿæ˜¯ä¿¡æ‰‹ææ¥ï¼Œæƒ³åˆ°æ‹¿å°±å†™åˆ°æ‹¿ï¼Œå‡Œä¹±çš„å¾ˆã€‚æ°å¥½çœ‹åˆ°æœ‰äººç”¨Hexoï¼Œå°±å¼„ä¸€ä¸ªçŽ©çŽ©ã€‚ä¸è¿‡åªæ”¯æŒmdï¼Œæ­£å¥½Bearä¸‹ä¸‹æ¥ä»Žæ¥æ²¡æœ‰ç”¨è¿‡ï¼Œå€Ÿæ­¤æ‹¿å‡ºæ¥ç”¨ä¸€ä¸‹ã€‚å¸Œæœ›åšæŒä¸‹åŽ»å¤šæ€»ç»“ï¼Œå¤šåˆ†äº«ã€‚","link":"/2017/11/23/%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"è¿ç®—ç¬¦é‡è½½å’Œè¿­ä»£å™¨æ¨¡å¼","text":"æ‰€è°“è¿­ä»£å™¨ï¼Œå®ƒçš„æ ¸å¿ƒä½œç”¨å°±æ˜¯å°†éåŽ†å’Œå®žçŽ°åˆ†ç¦»å¼€æ¥ï¼Œåœ¨éåŽ†çš„åŒæ—¶ä¸éœ€è¦æš´éœ²å¯¹è±¡çš„å†…éƒ¨è¡¨ç¤ºã€‚ è¿­ä»£å™¨ï¼ˆiteratorï¼‰æ˜¯Javaä¸­æˆ‘ä»¬éžå¸¸ç†Ÿæ‚‰çš„ä¸œè¥¿äº†ï¼Œæ•°æ®ç»“æž„å¦‚Listå’ŒSetéƒ½å†…ç½®äº†è¿­ä»£å™¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæä¾›çš„æ–¹æ³•æ¥é¡ºåºåœ°è®¿é—®ä¸€ä¸ªèšåˆå¯¹è±¡ä¸­æ¯ä¸ªå…ƒç´ ã€‚ æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå®šä¹‰æŸäº›å®¹å™¨ç±»ï¼Œè¿™äº›ç±»ä¸­åŒ…å«äº†å¤§é‡ç›¸åŒç±»åž‹çš„å¯¹è±¡ã€‚å¦‚æžœä½ æƒ³ç»™è¿™ä¸ªå®¹å™¨ç±»çš„å¯¹è±¡ç›´æŽ¥æä¾›è¿­ä»£çš„æ–¹æ³•ï¼Œå¦‚hasNext,next,firstç­‰ï¼Œé‚£ä¹ˆå°±å¯ä»¥è‡ªå®šä¹‰ä¸€ä¸ªè¿­ä»£å™¨ã€‚ç„¶è€Œé€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸éœ€è¦è‡ªå·±å†å®žçŽ°ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå› ä¸ºJavaæ ‡å‡†åº“æä¾›äº†java.util.IteratoræŽ¥å£ï¼Œä½ å¯ä»¥ç”¨å®¹å™¨ç±»å®žçŽ°è¯¥æŽ¥å£ï¼Œç„¶åŽå†å®žçŽ°éœ€è¦çš„è¿­ä»£å™¨æ–¹æ³•ã€‚ è¿™ç§è®¾è®¡æ¨¡å¼å°±æ˜¯è¿­ä»£å™¨æ¨¡å¼ï¼Œå®ƒçš„æ ¸å¿ƒä½œç”¨å°±æ˜¯å°†éåŽ†å’Œå®žçŽ°åˆ†ç¦»å¼€æ¥ï¼Œåœ¨éåŽ†çš„åŒæ—¶ä¸éœ€è¦æš´éœ²å¯¹è±¡çš„å†…éƒ¨è¡¨ç¤ºã€‚è¿­ä»£å™¨æ¨¡å¼éžå¸¸å®¹æ˜“ç†è§£ï¼Œä½ å¯èƒ½å·²ç»éžå¸¸ç†Ÿæ‚‰ã€‚ä½†æˆ‘ä»¬è¿˜æ˜¯ä¸¾ä¸ªå…·ä½“çš„ä¾‹å­æ¥ä»‹ç»ä¸‹è¿™ç§æ¨¡å¼ï¼ŒæŽ¥ç€å¼•å‡ºKotlinä¸­ç›¸å…³çš„è¯­æ³•ç‰¹æ€§ï¼Œç»§è€Œè¿›è¡Œæ”¹è‰¯ã€‚ æ–¹æ¡ˆ1ï¼šå®žçŽ°IteratoræŽ¥å£data class Book(val name: String)class Bookcase(val books: list&lt;Book&gt;): Iterator&lt;Book&gt; { private val iterator: Iterator&lt;Book&gt; init { this.iterator = books.iterator() } override fun hasNext() = this.iterator.hasNext() override fun next() = this.iterator.next()}//invokeval bookcase = Bookcase(listOf(Book(&quot;Dive into Kotlin&quot;),Book(&quot;Thinking in Java&quot;)))while(bookcase.hasNext()) { println(&quot;The book is ${bookcase.next().name}&quot;)}The book name is Dive into KotlinThe book name is Thinking in Java ç”±äºŽBookcaseå¯¹è±¡æ‹¥æœ‰ä¸ŽListå®žä¾‹ç›¸åŒçš„è¿­ä»£å™¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç›´æŽ¥è°ƒç”¨åŽè€…è¿­ä»£å™¨æ‰€æœ‰çš„æ–¹æ³•ã€‚ä¸€ç§æ›´ç®€æ´çš„éåŽ†æ‰“å°æ–¹å¼å¦‚ä¸‹ï¼š for(book in bookcase) { println(&quot;The book name is ${book.name}&quot;)} æ–¹æ¡ˆ2ï¼šé‡è½½iteratoræ–¹æ³•Kotlinå´æœ‰æ›´å¥½çš„è§£å†³æ–¹æ¡ˆã€‚Kotlinæœ‰ä¸€ä¸ªéžå¸¸å¼ºå¤§çš„è¯­è¨€ç‰¹æ€§ï¼Œé‚£å°±æ˜¯åˆ©ç”¨operatorå…³é”®å­—å†…ç½®äº†å¾ˆå¤šè¿ç®—ç¬¦é‡è½½åŠŸèƒ½ã€‚æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡é‡è½½Bookcaseç±»çš„iteratoræ–¹æ³•ï¼Œå®žçŽ°ä¸€ç§è¯­æ³•ä¸Šæ›´åŠ ç²¾ç®€çš„ç‰ˆæœ¬ï¼š data class Book(val name: String)class Bookcase(val books:List&lt;Book&gt;) { operator fun iterator(): Iterator&lt;Book&gt; = this.books.iterator()} è¿™æ ·æˆ‘ä»¬ç”¨ä¸€è¡Œä»£ç å°±å®žçŽ°äº†ä»¥ä¸Šæ‰€æœ‰æ•ˆæžœã€‚ç”±äºŽKotlinæ”¯æŒæ‰©å±•å‡½æ•°ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ç»™æ‰€æœ‰çš„å¯¹è±¡éƒ½å†…ç½®ä¸€ä¸ªè¿­ä»£å™¨ã€‚ æ–¹æ¡ˆ3ï¼šé€šè¿‡æ‰©å±•å‡½æ•°å‡è®¾çŽ°åœ¨çš„Bookæ˜¯å¼•å…¥çš„ä¸€ä¸ªç±»ï¼Œä½ å¹¶ä¸èƒ½ä¿®æ”¹å®ƒçš„æºç ï¼Œé‚£ä¹ˆå¦‚ä½•ç”¨æ‰©å±•çš„è¯­æ³•æ¥ç»™Bookcaseç±»å¯¹è±¡å¢žåŠ è¿­ä»£çš„åŠŸèƒ½ï¼š data class Book(val name: String) {}class Bookcase(val Books: list&lt;Book&gt;) {}operator fun Bookcase.iterator(): Iterator&lt;Book&gt; = books.iterator() ä»£ç ä¾æ—§éžå¸¸ç®€æ´ï¼Œå‡å¦‚æƒ³å¯¹è¿­ä»£å™¨çš„é€»è¾‘æœ‰æ›´å¤šçš„æŽ§åˆ¶æƒï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥é€šè¿‡objectè¡¨è¾¾å¼æ¥å®žçŽ°ï¼š operator fun Bookcase.iterator():Iterator&lt;Book&gt; = object: Iterator&lt;Book&gt; { val iterator = books.iterator() override fun hasNext() = iterator.hasNext() override fun next() = iterator.next()} æ€»çš„æ¥è¯´ï¼Œè¿­ä»£å™¨æ¨¡å¼å¹¶ä¸æ˜¯ä¸€ç§å¾ˆå¸¸ç”¨çš„è®¾è®¡æ¨¡å¼ï¼Œä½†é€šè¿‡å®ƒæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥äº†è§£Kotlinä¸­çš„æ‰©å±•å‡½æ•°çš„åº”ç”¨ï¼Œä»¥åŠè¿ç®—ç¬¦é‡è½½åŠŸèƒ½çš„å¼ºå¤§ä¹‹å¤„ã€‚","link":"/2020/01/19/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"githubè®¿é—®åŠcloneè¿‡æ…¢é—®é¢˜","text":"å¢™ç›¸å…³ å‰è¨€Githubæ˜¯å¼€æºä¸–ç•Œçš„ä¸€æ‰‡å¤§é—¨ï¼Œä¼Ÿå¤§çš„å¢™å¯¹GitHubç½‘å¼€ä¸€é¢ï¼Œæ²¡æœ‰åƒå¯¹Googleé‚£æ ·ç›´æŽ¥æ–©å°½æ€ç»ï¼Œä½†æ˜¯å¯¹å®ƒåšäº†ä¸¥æ ¼çš„é™é€Ÿã€‚git cloneï¼ˆæœ‰äº›åœ°åŒºè¾ƒå¿«ï¼Œæœ‰äº›åœ°åŒºè¾ƒæ…¢ï¼‰ï¼›ä½†æ€»ä½“æ¥è¯´,åŸºæœ¬éƒ½åœ¨10KiB/s-40KiB/sä¹‹é—´ã€‚åœ¨æ‹‰å–Flutteræºç æ—¶å‡ºçŽ°5-9KiB/sçš„æƒ…å†µï¼Œæ‰€ä»¥æœ‰äº†è¿™ç¯‡æ–‡ç«  ä¿®æ”¹ç«¯å£ é¦–å…ˆéœ€è¦æ‰“å¼€ShadowSocksï¼Œæˆ‘ä¸ä¼šé…ç½®å…¨å±€æ¨¡å¼ï¼Œä¸€æ˜¯æ¯æœˆæµé‡é—®é¢˜ï¼ŒäºŒæ˜¯è®¿é—®ä¸€äº›å›½å†…ç½‘ç«™åè€Œä¼šæ…¢ï¼Œæ‰€ä»¥å¯¹äºŽPACè‡ªåŠ¨æ¨¡å¼æ¥è¯´å¯ä»¥å¦‚ä¸‹é…ç½® git config --global http.https://github.com.proxy https://127.0.0.1:xxxxgit config --global https.https://github.com.proxy https://127.0.0.1:xxxx å…¶ä¸­ç«¯å£å·ï¼Œå¯ä»¥åœ¨ShadowSocksä¸ŠæŸ¥æ‰¾socks5ç«¯å£ï¼Œç„¶åŽå°±äº«å—40M/sçš„ç•…å¿«å§ã€‚ æŒ‡å®šIPå¦‚æžœä¿®æ”¹ç«¯å£çš„æ–¹æ³•ä¹Ÿæ— æµŽäºŽäº‹ï¼Œè¿˜å¯ä»¥é€šè¿‡æŒ‡å®šhostçš„æ–¹å¼ï¼ŒæŒ‡å®šæœ€è¿‘dnsæœåŠ¡å•†ä»¥è¾¾åˆ°å¿«é€Ÿçš„æ•ˆæžœã€‚ DNSå·¥ä½œæ–¹å¼å½“æˆ‘ä»¬è®¿é—®github.comæ—¶ï¼Œæµè§ˆå™¨å¹¶ä¸çŸ¥é“è¿™ä¸ªåŸŸåå¯¹åº”çš„çœŸå®žipåœ°å€ï¼Œæœ€å…ˆå›žåŽ»è¯¢é—®æœ¬åœ°dnsç¼“å­˜ï¼Œæ˜¯å¦è®¤è¯†è¿™ä¸ªåŸŸåçš„é—¨ç‰Œå·ï¼Œå¦‚æžœä¸è®¤è¯†æŽ¥ç€å¾€ä¸Šé—®ï¼Œå½“åœ°è¿è¡Œå•†ä¹Ÿä¸è®¤è¯†è¿™ä¸ªåŸŸåçš„è¯ï¼Œç»§ç»­é—®ä¸Šçº§ï¼ŒçŸ¥é“é—®å‡ºæ¥github.comçš„é—¨ç‰Œå·ä¸ºæ­¢ï¼è¿™ä¸ªé—®è·¯è¿‡ç¨‹ç§°ä¸ºDNSå¯»å€ï¼Œå¦‚æžœé—®è·¯çš„æ—¶é—´è¿‡é•¿ï¼Œé‚£ä¹ˆè¿”å›žé€Ÿåº¦è‡ªç„¶å¾ˆæ…¢ã€‚é‚£ä¹ˆå¦‚æžœæˆ‘ä»¬ç›´æŽ¥å‘Šè¯‰æµè§ˆå™¨ç›®çš„åœ°ï¼Œé‚£ä¹ˆæµè§ˆå™¨ä¹Ÿå°±ä¸ä¼šä¸€æ­¥æ­¥åŽ»é—®è·¯äº†ï¼Œæ‰€ä»¥ä¹Ÿå°±èƒ½è¾¾åˆ°åŠ å¿«è®¿é—®é€Ÿåº¦çš„è¦æ±‚ã€‚ æ­£å¸¸æ¥è¯´ï¼Œç½‘ç«™çš„ä¸»åŸŸåä¸‹ä¼šå­˜åœ¨å¤šä¸ªå­åŸŸåï¼Œç”±è¿™äº›åŸŸåç»„åˆåœ¨ä¸€èµ·æä¾›å®Œæ•´çš„æœåŠ¡ã€‚æ‰€ä»¥æˆ‘ä»¬ä¸ä»…è¦å‘Šè¯‰æœ¬æœºgithub.comçš„ä¸»åŸŸåï¼Œè¿˜è¦æŠŠç›¸å…³çš„å­åŸŸåä¹Ÿå‘Šè¯‰æœ¬æœºã€‚å°±åƒçŽ°å®žä¸­ï¼Œæ¯ä¸ªäººéƒ½æœ‰è‡ªå·±çš„å®¶ï¼Œè€Œè¿™ä¸ªå®¶æœ‰å…·ä½“çš„åœ°å€ï¼Œä¸€äº›æœ‰é’±äººå¯èƒ½æœ‰å‡ ä¸ªå®¶ã€‚ å¯¹åº”åˆ°è®¡ç®—æœºä¸–ç•Œä¸­ï¼Œå¦‚æžœåŸŸåæ˜¯ç”¨æˆ·ï¼Œé‚£ä¹ˆipåœ°å€å°±æ˜¯ç”¨æˆ·çš„å®¶ï¼ŒåŒä¸€ä¸ªåŸŸåå¯ä»¥å¯¹åº”å¤šä¸ªipåœ°å€ï¼ŒåŒä¸€ä¸ªipåœ°å€ä¹Ÿå¯ä»¥æœ‰å¤šå¤šä¸ªåŸŸåã€‚åŸŸååˆ°ipåœ°å€çš„è¿‡ç¨‹åŒæ ·éœ€è¦æ‰¾äººè¯¢é—®ï¼Œè¿™ä¸ªä¿¡æ¯ä¸€èˆ¬ä¼šå­˜åœ¨dnsæœåŠ¡å•†é‚£é‡Œï¼Œå°±åƒæˆ‘ä»¬çš„åœ°å€ç™»è®°åˆ°ç›¸å…³æœºæž„ä¸€æ ·. å­åŸŸåä¿¡æ¯ipaddress.com ç½‘ç«™ä¸ºä¾‹ï¼ŒæŸ¥è¯¢ä¸‹ github.com ç½‘ç«™çš„ç›¸å…³ä¿¡æ¯ã€‚å¾—åˆ°å¦‚ä¸‹åŸŸåä¿¡æ¯ã€‚ å°±è¿‘cdnåŠ é€Ÿå¤§åž‹ç½‘ç«™æœåŠ¡å™¨éƒ½ä¸ä¼šåªæœ‰ä¸€å°æœåŠ¡å™¨ï¼Œè€Œæ˜¯å¤šå°æœåŠ¡å™¨ç»„æˆé›†ç¾¤ä¸€èµ·å¯¹å¤–æä¾›æœåŠ¡ã€‚å…¨ä¸–ç•Œéƒ½åœ¨ä½¿ç”¨ ** githubï¼Œå¦‚æžœæ¯æ¬¡éƒ½è®¿é—®ç¾Žå›½æœåŠ¡å™¨ï¼Œå³ä½¿æµè§ˆå™¨çŸ¥é“ç›®çš„åœ°ï¼Œä½†æ˜¯è·ç¦»å¤ªè¿œè¿˜æ˜¯ä¼šå¾ˆæ…¢ï¼Œæ‰€ä»¥èƒ½å¤Ÿå°±è¿‘è®¿é—®github.com**å°±èƒ½å¤§å¹…æé«˜è®¿é—®é€Ÿåº¦äº†ã€‚tool.chinaz.com ç½‘ç«™ä¸ºä¾‹ï¼ŒæŸ¥è¯¢ä¸‹ github.com å„å­åŸŸåçš„å°±è¿‘åœ°å€ã€‚ æ‰€ä»¥åªéœ€è¦é€‰æ‹©TTLå€¼æœ€å°çš„ä½œä¸ºä¼˜åŒ–æ ‡å‡†ï¼Œå¹¶å†™å…¥/etc/hosts(macOS)æ–‡ä»¶ä¸­ # github related website 13.250.177.223 github.com 31.13.83.8 github.global.ssl.fastly.net 203.98.7.65 gist.github.com 13.229.189.0 codeload.github.com 185.199.109.153 desktop.github.com 185.199.108.153 guides.github.com 185.199.108.153 blog.github.com 18.204.240.114 status.github.com 185.199.108.153 developer.github.com 185.199.108.153 services.github.com 140.82.113.22 enterprise.github.com 34.195.49.195 education.github.com 185.199.108.153 pages.github.com 34.196.237.103 classroom.github.com æœ€åŽè¿›è¡Œdnsåˆ·æ–° sudo dscacheutil -flushcache","link":"/2019/07/16/%E9%83%A8%E5%88%86%E5%9C%B0%E5%8C%BAgithub%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81%E5%A5%87%E6%85%A2%E9%97%AE%E9%A2%98/"},{"title":"é™é»˜å®‰è£…ã€è‡ªå¯åŠ¨å®žè·µ","text":"æœ€è¿‘åœ¨åšé—¨ç¦æœºå†…åµŒappï¼Œé—¨ç¦æœºåŸºäºŽapi22åŽŸç”Ÿç³»ç»Ÿï¼Œæ¶‰åŠåˆ°çš„æŠ€æœ¯ç‚¹åŒ…æ‹¬é™é»˜å®‰è£…ã€è‡ªå¯åŠ¨ã€‚ç¿»é˜…å¤§é‡æºç ã€blogä»¥åŽå¾—åˆ°è§£å†³æ–¹æ¡ˆï¼Œå› æ­¤è®°å½•ä¸‹æ¥ã€‚ é™é»˜å®‰è£… é™é»˜å®‰è£…ï¼Œå³ä¸å¼¹çª—ç³»ç»Ÿå®‰è£…ç•Œé¢çš„æƒ…å†µä¸‹ï¼Œå®Œæˆå®‰è£…åŠ¨ä½œï¼Œåœ¨ç”¨æˆ·ä¸çŸ¥æƒ…çš„æƒ…å†µä¸‹å®Œæˆå®‰è£…åŠ¨ä½œæ˜¾ç„¶æ˜¯éžå¸¸å±é™©çš„è¡Œä¸º ï¼Œå› æ­¤é™é»˜å®‰è£…ä¸ä¼šå¼€å‘ç»™å¼€å‘è€…ï¼Œä¸è¿‡åœ¨Google Playå•†åº—å·²ç»è‡ªå®šä¹‰Romä¸Šéƒ½æœ‰å¼€å‘æ­¤æƒé™ï¼Œå……åˆ†è¯´æ˜Žæ‹¥æœ‰æƒé™çš„é‡è¦ æ€§ï¼Œè‡ªå®¶çš„ç³»ç»Ÿæƒ³å’‹æ ·å°±å’‹æ ·ã€‚ æƒé™ &lt;uses-permission android:name=&quot;android.permission.INSTALL_PACKAGES&quot; /&gt; å®‰è£…ä»£ç æœ‰ç”¨pushåˆ°system/appåŽ»è°ƒç”¨@hideå®žçŽ°çš„ï¼Œæœ‰ç”¨docå‘½ä»¤å®žçŽ°çš„ï¼Œå¯¹é¡¹ç›®éœ€æ±‚è€Œè¨€äºŒè€…çš†å¯ï¼Œè€ƒè™‘åˆ°é¡¹ç›®åŒ…å«è¿‡å¤š.soæ–‡ä»¶ï¼Œè€Œ.soæ–‡ä»¶éœ€è¦pushåˆ°/system/libèµ‹äºˆæƒé™ï¼Œæ•…ç›´æŽ¥é‡‡ç”¨äº†ç¬¬äºŒç§ç­–ç•¥ä½¿ç”¨docå‘½ä»¤æžå®šï¼Œå³ï¼ˆåœ¨å­çº¿ç¨‹å®‰è£…ï¼Œé¿å…ANRï¼Œéœ€è¦rootæƒé™ï¼‰ï¼š pm install -r å®žçŽ°ä»£ç  /** * install slient * * @param context * @param filePath * @return 0 means normal, 1 means file not exist, 2 means other exception error */ public static int installSlient(Context context, String filePath) { File file = new File(filePath); if (filePath == null || filePath.length() == 0 || (file = new File(filePath)) == null || file.length() &lt;= 0 || !file.exists() || !file.isFile()) { return 1; } String[] args = { &quot;pm&quot;, &quot;install&quot;, &quot;-r&quot;, filePath }; ProcessBuilder processBuilder = new ProcessBuilder(args); Process process = null; BufferedReader successResult = null; BufferedReader errorResult = null; StringBuilder successMsg = new StringBuilder(); StringBuilder errorMsg = new StringBuilder(); int result; try { process = processBuilder.start(); successResult = new BufferedReader(new InputStreamReader(process.getInputStream())); errorResult = new BufferedReader(new InputStreamReader(process.getErrorStream())); String s; while ((s = successResult.readLine()) != null) { successMsg.append(s); } while ((s = errorResult.readLine()) != null) { errorMsg.append(s); } } catch (IOException e) { e.printStackTrace(); result = 2; } catch (Exception e) { e.printStackTrace(); result = 2; } finally { try { if (successResult != null) { successResult.close(); } if (errorResult != null) { errorResult.close(); } } catch (IOException e) { e.printStackTrace(); } if (process != null) { process.destroy(); } } // TODO should add memory is not enough here if (successMsg.toString().contains(&quot;Success&quot;) || successMsg.toString().contains(&quot;success&quot;)) { result = 0; } else { result = 2; } Log.d(&quot;installSlient&quot;, &quot;successMsg:&quot; + successMsg + &quot;, ErrorMsg:&quot; + errorMsg); return result; } è‡ªå¯åŠ¨æ— éžå°±æ˜¯é™æ€å¹¿æ’­æ‹‰èµ·laucherActivity,ä¸è¿‡è¿™é‡Œéœ€è¦æ³¨æ„çš„é—®é¢˜æ˜¯ï¼Œä½†é™é»˜å®‰è£…æˆåŠŸåŽï¼Œappè¿›ç¨‹ä¼šè¢«æ€æ­»ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­è‡ªèº«æ— æ³•æŽ¥æ”¶åˆ°å¹¿æ’­,è¿™æ—¶å€™å°±éœ€è¦è¾…åŠ©appäº†ï¼Œè¿™ä¸ªappç”¨æ¥å¤„ç†æŽ¥æ”¶android.intent.action.PACKAGE_ADDEDå¹¿æ’­ï¼Œå¹¶å‘é€å¹¿æ’­ç»™å®¿ä¸»appä»Žè€Œå®žçŽ°è‡ªå¯åŠ¨ï¼Œè¿™ä¸ªè¿‡ç¨‹ä»£ç æ˜¯å¾ˆç®€å•çš„ã€‚å¦‚æžœæƒ³è¦ä¼˜åŒ–çš„è¯å¯ä»¥åŽ»åšå®šæ—¶è½®è¯¢ç›¸äº’æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜æ´»ï¼Œå¹¶ç›¸äº’æ‹‰èµ·ã€‚å¦‚ä½•å®šæ—¶è½®è¯¢ï¼Œå¦‚ä½•æ£€æŸ¥ï¼Œæ•´ä¸ªç­–ç•¥ï¼Œä¼šåœ¨åŽç»­ä¸­ç¼–å†™â€¦ å‚è€ƒ:Trinea-Androidå¸¸ç”¨ä»£ç ä¹‹æ™®é€šåŠç³»ç»Ÿæƒé™é™é»˜å®‰è£…APKpm.java","link":"/2018/05/26/%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85%E3%80%81%E8%87%AA%E5%90%AF%E5%8A%A8%E5%AE%9E%E8%B7%B5/"},{"title":"è½¯é”®ç›˜ç›¸å…³","text":"Androidè½¯é”®ç›˜ç›¸å…³å¤„ç† é¡¹ç›®ä¸­æœ‰ç±»ä¼¼é™Œé™Œè¾“å…¥æ¡†çš„UIï¼Œå› ä¸ºEdittextä¸åœ¨è¾“å…¥æ¡†åº•éƒ¨ï¼Œå¯¼è‡´è½¯é”®ç›˜å¼¹å‡ºæ—¶æ˜¾ç¤ºåœ¨Edittextåº•éƒ¨è€Œé®æŒ¡æŽ‰è¾“å…¥æ¡†éƒ¨åˆ†UIï¼Œç›®å‰é‡‡ç”¨çš„æ–¹æ³•æ˜¯å¯¹Viewtreeè¿›è¡Œç›‘å¬ï¼Œè½¯é”®ç›˜å¼¹èµ·æ¥æ—¶ï¼Œè¿›è¡ŒscrollToç§»åŠ¨è¾“å…¥æ¡† private void configureViewTreeObserver(View root, View scrollToView) { root.getViewTreeObserver().addOnGlobalLayoutListener(() -&gt; { Rect rect = new Rect(); //èŽ·å–åˆ°ç•Œé¢å¯è§åŒºåŸŸçš„çŸ©å½¢ root.getWindowVisibleDisplayFrame(rect); //æ ¹å¸ƒå±€é«˜åº¦ - å¯è§åŒºåŸŸé«˜åº¦ = è½¯é”®ç›˜é«˜åº¦ int keyboardHeight = root.getRootView().getHeight() - rect.bottom; if (keyboardHeight &gt; 100) { //å¦‚æžœåƒç´ æ•°å¤§äºŽ100æžå¤§å¯èƒ½æ˜¯è½¯é”®ç›˜å¼¹å‡º mIsKeyboardOpened = true; //å¤„ç†Edittextä¸åœ¨è¾“å…¥æ¡†åº•éƒ¨çš„æƒ…å†µ int[] location = new int[2]; scrollToView.getLocationInWindow(location); //è¾“å…¥æ¡†åœ¨ç•Œé¢ä¸ŠYè½´åæ ‡ + è¾“å…¥æ¡†é«˜åº¦ - å¯è§åŒºåŸŸåº•éƒ¨ root.scrollTo(0, location[1] + scrollToView.getHeight() - rect.bottom); } else { //è½¯é”®ç›˜æ”¶èµ· root.scrollTo(0, 0); if (mIsKeyboardOpened) { mIsKeyboardOpened = false; DanmakuInputDialog.this.dismiss(); } } }); } ##android:windowSoftInputModeå±žæ€§è¾“å…¥æ¡†ä»¥DialogFragmentçš„æ–¹å¼è¿›è¡Œè§†å›¾å åŠ å®žçŽ°ï¼Œæ²¡æœ‰ç”¨åˆ°windowSoftInputModeå±žæ€§ï¼Œä¸è¿‡è¿™é‡Œä¹Ÿæ€»ç»“ä¸€ä¸‹ &lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot;. . . &gt; activityä¸»çª—å£ä¸Žè½¯é”®ç›˜çš„äº¤äº’æ¨¡å¼ï¼Œå¯ä»¥ç”¨æ¥é¿å…è¾“å…¥æ³•é¢æ¿é®æŒ¡é—®é¢˜ï¼ŒAndroid1.5åŽçš„ä¸€ä¸ªæ–°ç‰¹æ€§ã€‚è¿™ä¸ªå±žæ€§èƒ½å½±å“ä¸¤ä»¶äº‹æƒ…ï¼š å½“æœ‰ç„¦ç‚¹äº§ç”Ÿæ—¶ï¼Œè½¯é”®ç›˜æ˜¯éšè—è¿˜æ˜¯æ˜¾ç¤º æ˜¯å¦å‡å°‘æ´»åŠ¨ä¸»çª—å£å¤§å°ä»¥ä¾¿è…¾å‡ºç©ºé—´æ”¾è½¯é”®ç›˜ å„å€¼å¦‚ä¸‹ï¼š stateUnspecifiedï¼šè½¯é”®ç›˜çš„çŠ¶æ€å¹¶æ²¡æœ‰æŒ‡å®šï¼Œç³»ç»Ÿå°†é€‰æ‹©ä¸€ä¸ªåˆé€‚çš„çŠ¶æ€æˆ–ä¾èµ–äºŽä¸»é¢˜çš„è®¾ç½® stateUnchangedï¼šå½“è¿™ä¸ªactivityå‡ºçŽ°æ—¶ï¼Œè½¯é”®ç›˜å°†ä¸€ç›´ä¿æŒåœ¨ä¸Šä¸€ä¸ªactivityé‡Œçš„çŠ¶æ€ï¼Œæ— è®ºæ˜¯éšè—è¿˜æ˜¯æ˜¾ç¤º stateHiddenï¼šç”¨æˆ·é€‰æ‹©activityæ—¶ï¼Œè½¯é”®ç›˜æ€»æ˜¯è¢«éšè— stateAlwaysHiddenï¼šå½“è¯¥Activityä¸»çª—å£èŽ·å–ç„¦ç‚¹æ—¶ï¼Œè½¯é”®ç›˜ä¹Ÿæ€»æ˜¯è¢«éšè—çš„ stateVisibleï¼šè½¯é”®ç›˜é€šå¸¸æ˜¯å¯è§çš„ stateAlwaysVisibleï¼šç”¨æˆ·é€‰æ‹©activityæ—¶ï¼Œè½¯é”®ç›˜æ€»æ˜¯æ˜¾ç¤ºçš„çŠ¶æ€ adjustUnspecifiedï¼šé»˜è®¤è®¾ç½®ï¼Œé€šå¸¸ç”±ç³»ç»Ÿè‡ªè¡Œå†³å®šæ˜¯éšè—è¿˜æ˜¯æ˜¾ç¤º adjustResizeï¼šè¯¥Activityæ€»æ˜¯è°ƒæ•´å±å¹•çš„å¤§å°ä»¥ä¾¿ç•™å‡ºè½¯é”®ç›˜çš„ç©ºé—´ adjustPanï¼šå½“å‰çª—å£çš„å†…å®¹å°†è‡ªåŠ¨ç§»åŠ¨ä»¥ä¾¿å½“å‰ç„¦ç‚¹ä»Žä¸è¢«é”®ç›˜è¦†ç›–å’Œç”¨æˆ·èƒ½æ€»æ˜¯çœ‹åˆ°è¾“å…¥å†…å®¹çš„éƒ¨åˆ† ##android:imeOptinoså±žæ€§Androidåœ¨æ¨ªå±æ—¶å”¤èµ·è½¯é”®ç›˜ä¼šé»˜è®¤å…¨å±å±•ç¤ºï¼Œå½“ä½¿ç”¨imeOptionsæ—¶å¯ä»¥è§£å†³é—®é¢˜ã€‚ &lt;Edittext android:imeOptions=&quot;flagNoExtractUi&quot;&gt; android:imeOptions=â€flagNoExtractUiâ€ //ä½¿è½¯é”®ç›˜ä¸å…¨å±æ˜¾ç¤ºï¼Œåªå ç”¨ä¸€éƒ¨åˆ†å±å¹• åŒæ—¶,è¿™ä¸ªå±žæ€§è¿˜èƒ½æŽ§ä»¶è½¯é”®ç›˜å³ä¸‹è§’æŒ‰é”®çš„æ˜¾ç¤ºå†…å®¹,é»˜è®¤æƒ…å†µä¸‹ä¸ºå›žè½¦é”® android:imeOptions=â€actionNoneâ€ //è¾“å…¥æ¡†å³ä¾§ä¸å¸¦ä»»ä½•æç¤º android:imeOptions=â€actionGoâ€ //å³ä¸‹è§’æŒ‰é”®å†…å®¹ä¸ºâ€™å¼€å§‹â€™ android:imeOptions=â€actionSearchâ€ //å³ä¸‹è§’æŒ‰é”®ä¸ºæ”¾å¤§é•œå›¾ç‰‡ï¼Œæœç´¢ android:imeOptions=â€actionSendâ€ //å³ä¸‹è§’æŒ‰é”®å†…å®¹ä¸ºâ€™å‘é€â€™ android:imeOptions=â€actionNextâ€ //å³ä¸‹è§’æŒ‰é”®å†…å®¹ä¸ºâ€™ä¸‹ä¸€æ­¥â€™ android:imeOptions=â€actionDoneâ€ //å³ä¸‹è§’æŒ‰é”®å†…å®¹ä¸ºâ€™å®Œæˆâ€™","link":"/2018/12/03/%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Test automation","slug":"Test-automation","link":"/tags/Test-automation/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"Tensorflow","slug":"Tensorflow","link":"/tags/Tensorflow/"},{"name":"dart","slug":"dart","link":"/tags/dart/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"adb","slug":"adb","link":"/tags/adb/"},{"name":"cocoaPods","slug":"cocoaPods","link":"/tags/cocoaPods/"},{"name":"system","slug":"system","link":"/tags/system/"},{"name":"syntactic sugar","slug":"syntactic-sugar","link":"/tags/syntactic-sugar/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"éšæ„","slug":"éšæ„","link":"/tags/%E9%9A%8F%E6%84%8F/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"WebRTC","slug":"WebRTC","link":"/categories/WebRTC/"},{"name":"Flutter","slug":"Flutter","link":"/categories/Flutter/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"MediaPipe","slug":"MediaPipe","link":"/categories/MediaPipe/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"éšç¬”","slug":"éšç¬”","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"openGL","slug":"openGL","link":"/categories/openGL/"},{"name":"vm","slug":"vm","link":"/categories/vm/"},{"name":"life","slug":"life","link":"/categories/life/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"I'm Hanniballol! All work and no play makes jack a dull boy. Resume Of Me ðŸ¤­å¹½ç„¶æ‹¿é“çœŸä»–å¨˜çš„å¥½å–ï¼","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}